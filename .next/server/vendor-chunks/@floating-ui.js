"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var aria_hidden__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! aria-hidden */ \"(ssr)/./node_modules/aria-hidden/dist/es2015/index.js\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_4__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_4__.useEffect;\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>\"floating-ui-\" + count++;\nfunction useFloatingId() {\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_4__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    index(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!serverHandoffComplete) {\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return id;\n}\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = react__WEBPACK_IMPORTED_MODULE_4__[/*#__PURE__*/ \"useId\".toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */ const useId = useReactId || useFloatingId;\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */ const FloatingArrow = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.forwardRef(function FloatingArrow(_ref, ref) {\n    let { context: { placement, elements: { floating }, middlewareData: { arrow } }, width = 14, height = 7, tipRadius = 0, strokeWidth = 0, staticOffset, stroke, d, style: { transform, ...restStyle } = {}, ...rest } = _ref;\n    if (true) {\n        if (!ref) {\n            console.warn(\"Floating UI: The `ref` prop is required for the `FloatingArrow`\", \"component.\");\n        }\n    }\n    const clipPathId = useId();\n    if (!floating) {\n        return null;\n    }\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    strokeWidth *= 2;\n    const halfStrokeWidth = strokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const [side, alignment] = placement.split(\"-\");\n    const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform.isRTL(floating);\n    const isCustomShape = !!d;\n    const isVerticalSide = side === \"top\" || side === \"bottom\";\n    const yOffsetProp = staticOffset && alignment === \"end\" ? \"bottom\" : \"top\";\n    let xOffsetProp = staticOffset && alignment === \"end\" ? \"right\" : \"left\";\n    if (staticOffset && isRTL) {\n        xOffsetProp = alignment === \"end\" ? \"left\" : \"right\";\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : \"\";\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : \"\";\n    const dValue = d || \"M0,0\" + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + \" Z\";\n    const rotation = {\n        top: isCustomShape ? \"rotate(180deg)\" : \"\",\n        left: isCustomShape ? \"rotate(90deg)\" : \"rotate(-90deg)\",\n        bottom: isCustomShape ? \"\" : \"rotate(180deg)\",\n        right: isCustomShape ? \"rotate(-90deg)\" : \"rotate(90deg)\"\n    }[side];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"svg\", _extends({}, rest, {\n        \"aria-hidden\": true,\n        ref: ref,\n        width: isCustomShape ? width : width + strokeWidth,\n        height: width,\n        viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n        style: {\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            [xOffsetProp]: arrowX,\n            [yOffsetProp]: arrowY,\n            [side]: isVerticalSide || isCustomShape ? \"100%\" : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n            transform: \"\" + rotation + (transform != null ? transform : \"\"),\n            ...restStyle\n        }\n    }), strokeWidth > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"path\", {\n        clipPath: \"url(#\" + clipPathId + \")\",\n        fill: \"none\",\n        stroke: stroke,\n        strokeWidth: strokeWidth + (d ? 0 : 1),\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"path\", {\n        stroke: strokeWidth && !d ? rest.fill : \"none\",\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"clipPath\", {\n        id: clipPathId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"rect\", {\n        x: -halfStrokeWidth,\n        y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n        width: width + strokeWidth,\n        height: width\n    })));\n});\nfunction createPubSub() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach((handler)=>handler(data));\n        },\n        on (event, listener) {\n            map.set(event, [\n                ...map.get(event) || [],\n                listener\n            ]);\n        },\n        off (event, listener) {\n            var _map$get2;\n            map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l)=>l !== listener)) || []);\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(null);\nconst useFloatingParentNodeId = ()=>{\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_4__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = ()=>react__WEBPACK_IMPORTED_MODULE_4__.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */ function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(()=>{\n        const node = {\n            id,\n            parentId\n        };\n        tree == null ? void 0 : tree.addNode(node);\n        return ()=>{\n            tree == null ? void 0 : tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingNode(_ref) {\n    let { children, id } = _ref;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ])\n    }, children);\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingTree(_ref2) {\n    let { children } = _ref2;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const events = react__WEBPACK_IMPORTED_MODULE_4__.useState(()=>createPubSub())[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            nodesRef,\n            addNode,\n            removeNode,\n            events\n        ])\n    }, children);\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction getWindow(value) {\n    return getDocument(value).defaultView || window;\n}\nfunction isElement(value) {\n    return value ? value instanceof Element || value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n    return value ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    const OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    const androidRe = /Android/i;\n    if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== \"mouse\" || // iOS VoiceOver returns 0.333• for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n    return \"nativeEvent\" in event;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode && child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && isShadowRoot(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\nfunction createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nconst safePolygonIdentifier = /*#__PURE__*/ createAttribute(\"safe-polygon\");\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !isMouseLikePointerType(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */ function useHover(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, elements: { domReference, floating }, refs } = context;\n    const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(()=>{});\n    const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    }, [\n        dataRef\n    ]);\n    // When dismissing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onDismiss() {\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            blockMouseMoveRef.current = true;\n        }\n        events.on(\"dismiss\", onDismiss);\n        return ()=>{\n            events.off(\"dismiss\", onDismiss);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled || !handleCloseRef.current || !open) {\n            return;\n        }\n        function onLeave(event) {\n            if (isHoverOpen()) {\n                onOpenChange(false, event);\n            }\n        }\n        const html = getDocument(floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(function(event, runElseBranch) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = setTimeout(()=>onOpenChange(false, event), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeout(timeoutRef.current);\n            onOpenChange(false, event);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    }, []);\n    const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = getDocument(refs.floating.current).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    }, [\n        refs\n    ]);\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function isClickLikeOpenEvent() {\n            return dataRef.current.openEvent ? [\n                \"click\",\n                \"mousedown\"\n            ].includes(dataRef.current.openEvent.type) : false;\n        }\n        function onMouseEnter(event) {\n            clearTimeout(timeoutRef.current);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, \"open\") === 0) {\n                return;\n            }\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = setTimeout(()=>{\n                    onOpenChange(true, event);\n                }, openDelay);\n            } else {\n                onOpenChange(true, event);\n            }\n        }\n        function onMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            unbindMouseMoveRef.current();\n            const doc = getDocument(floating);\n            clearTimeout(restTimeoutRef.current);\n            if (handleCloseRef.current) {\n                // Prevent clearing `onScrollMouseLeave` timeout.\n                if (!open) {\n                    clearTimeout(timeoutRef.current);\n                }\n                handlerRef.current = handleCloseRef.current({\n                    ...context,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        // Should the event expose that it was closed by `safePolygon`?\n                        closeWithDelay(event);\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            // Allow interactivity without `safePolygon` on touch devices. With a\n            // pointer, a short close delay is an alternative, so it should work\n            // consistently.\n            const shouldClose = pointerTypeRef.current === \"touch\" ? !contains(floating, event.relatedTarget) : true;\n            if (shouldClose) {\n                closeWithDelay(event);\n            }\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n                ...context,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    clearPointerEvents();\n                    cleanupMouseMoveHandler();\n                    closeWithDelay(event);\n                }\n            })(event);\n        }\n        if (isElement(domReference)) {\n            const ref = domReference;\n            open && ref.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            floating == null ? void 0 : floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            move && ref.addEventListener(\"mousemove\", onMouseEnter, {\n                once: true\n            });\n            ref.addEventListener(\"mouseenter\", onMouseEnter);\n            ref.addEventListener(\"mouseleave\", onMouseLeave);\n            return ()=>{\n                open && ref.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                floating == null ? void 0 : floating.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                move && ref.removeEventListener(\"mousemove\", onMouseEnter);\n                ref.removeEventListener(\"mouseenter\", onMouseEnter);\n                ref.removeEventListener(\"mouseleave\", onMouseLeave);\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        enabled,\n        context,\n        mouseOnly,\n        restMs,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) {\n            return;\n        }\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n            const body = getDocument(floating).body;\n            body.setAttribute(safePolygonIdentifier, \"\");\n            body.style.pointerEvents = \"none\";\n            performedPointerEventsMutationRef.current = true;\n            if (isElement(domReference) && floating) {\n                var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n                const ref = domReference;\n                const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                ref.style.pointerEvents = \"auto\";\n                floating.style.pointerEvents = \"auto\";\n                return ()=>{\n                    ref.style.pointerEvents = \"\";\n                    floating.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        floating,\n        domReference,\n        tree,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    index(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerRef,\n                onPointerEnter: setPointerRef,\n                onMouseMove (event) {\n                    if (open || restMs === 0) {\n                        return;\n                    }\n                    clearTimeout(restTimeoutRef.current);\n                    restTimeoutRef.current = setTimeout(()=>{\n                        if (!blockMouseMoveRef.current) {\n                            onOpenChange(true, event.nativeEvent);\n                        }\n                    }, restMs);\n                }\n            },\n            floating: {\n                onMouseEnter () {\n                    clearTimeout(timeoutRef.current);\n                },\n                onMouseLeave (event) {\n                    events.emit(\"dismiss\", {\n                        type: \"mouseLeave\",\n                        data: {\n                            returnFocus: false\n                        }\n                    });\n                    closeWithDelay(event.nativeEvent, false);\n                }\n            }\n        };\n    }, [\n        events,\n        enabled,\n        restMs,\n        open,\n        onOpenChange,\n        closeWithDelay\n    ]);\n}\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: ()=>{},\n    setState: ()=>{},\n    isInstantPhase: false\n});\nconst useDelayGroupContext = ()=>react__WEBPACK_IMPORTED_MODULE_4__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ const FloatingDelayGroup = (_ref)=>{\n    let { children, delay, timeoutMs = 0 } = _ref;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_4__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    index(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            setState({\n                isInstantPhase: false\n            });\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setState,\n            setCurrentId\n        ])\n    }, children);\n};\nconst useDelayGroup = (_ref2, _ref3)=>{\n    let { open, onOpenChange } = _ref2;\n    let { id } = _ref3;\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = useDelayGroupContext();\n    index(()=>{\n        if (currentId) {\n            setState({\n                delay: {\n                    open: 1,\n                    close: getDelay(initialDelay, \"close\")\n                }\n            });\n            if (currentId !== id) {\n                onOpenChange(false);\n            }\n        }\n    }, [\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    index(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            } else {\n                unset();\n            }\n        }\n    }, [\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    index(()=>{\n        if (open) {\n            setCurrentId(id);\n        }\n    }, [\n        open,\n        setCurrentId,\n        id\n    ]);\n};\n/**\n * Find the real active element. Traverses into shadowRoots.\n */ function activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null){\n        var _activeElement, _activeElement$shadow;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nfunction getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction getChildren(nodes, id) {\n    let allChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while(currentChildren.length){\n        currentChildren = nodes.filter((node)=>{\n            var _currentChildren;\n            return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n)=>{\n                var _node$context2;\n                return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n            });\n        });\n        allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n    return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, direction) {\n    const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_6__.tabbable)(container, getTabbableOptions());\n    if (direction === \"prev\") {\n        allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n    return getTabbableIn(document.body, \"next\");\n}\nfunction getPreviousTabbable() {\n    return getTabbableIn(document.body, \"prev\");\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_6__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n    if (event.key === \"Tab\") {\n        event.target;\n        clearTimeout(timeoutId);\n    }\n}\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_4__.useState();\n    index(()=>{\n        if (isSafari()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n        document.addEventListener(\"keydown\", setActiveElementOnTab);\n        return ()=>{\n            document.removeEventListener(\"keydown\", setActiveElementOnTab);\n        };\n    }, []);\n    const restProps = {\n        ref,\n        tabIndex: 0,\n        // Role is only for VoiceOver\n        role,\n        \"aria-hidden\": role ? undefined : true,\n        [createAttribute(\"focus-guard\")]: \"\",\n        style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"span\", _extends({}, props, restProps));\n});\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(null);\nfunction useFloatingPortalNode(_temp) {\n    let { id, root } = _temp === void 0 ? {} : _temp;\n    const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_4__.useState(null);\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const data = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            id,\n            root,\n            portalContext,\n            uniqueId\n        }), [\n        id,\n        root,\n        portalContext,\n        uniqueId\n    ]);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    index(()=>{\n        return ()=>{\n            portalNode == null ? void 0 : portalNode.remove();\n        };\n    }, [\n        portalNode,\n        data\n    ]);\n    index(()=>{\n        if (dataRef.current === data) return;\n        dataRef.current = data;\n        const { id, root, portalContext, uniqueId } = data;\n        const existingIdRoot = id ? document.getElementById(id) : null;\n        const attr = createAttribute(\"portal\");\n        if (existingIdRoot) {\n            const subRoot = document.createElement(\"div\");\n            subRoot.id = uniqueId;\n            subRoot.setAttribute(attr, \"\");\n            existingIdRoot.appendChild(subRoot);\n            setPortalNode(subRoot);\n        } else {\n            let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n            if (container && !isElement(container)) container = container.current;\n            container = container || document.body;\n            let idWrapper = null;\n            if (id) {\n                idWrapper = document.createElement(\"div\");\n                idWrapper.id = id;\n                container.appendChild(idWrapper);\n            }\n            const subRoot = document.createElement(\"div\");\n            subRoot.id = uniqueId;\n            subRoot.setAttribute(attr, \"\");\n            container = idWrapper || container;\n            container.appendChild(subRoot);\n            setPortalNode(subRoot);\n        }\n    }, [\n        data\n    ]);\n    return portalNode;\n}\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ function FloatingPortal(_ref) {\n    let { children, id, root = null, preserveTabOrder = true } = _ref;\n    const portalNode = useFloatingPortalNode({\n        id,\n        root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_4__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && isOutsideEvent(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        focusManagerState == null ? void 0 : focusManagerState.modal\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: beforeOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _beforeInsideRef$curr;\n                (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n            } else {\n                const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                prevTabbable == null ? void 0 : prevTabbable.focus();\n            }\n        }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"span\", {\n        \"aria-owns\": portalNode.id,\n        style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: afterOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _afterInsideRef$curre;\n                (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n            } else {\n                const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                nextTabbable == null ? void 0 : nextTabbable.focus();\n                (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n            }\n        }\n    }));\n}\nconst usePortalContext = ()=>react__WEBPACK_IMPORTED_MODULE_4__.useContext(PortalContext);\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"button\", _extends({}, props, {\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(props) {\n    const { context, children, disabled = false, order = [\n        \"content\"\n    ], guards: _guards = true, initialFocus = 0, returnFocus = true, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true } = props;\n    const { open, refs, nodeId, onOpenChange, events, dataRef, elements: { domReference, floating } } = context;\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = (0,aria_hidden__WEBPACK_IMPORTED_MODULE_7__.supportsInert)() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    // Controlled by `useListNavigation`.\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const previouslyFocusedElementRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const isInsidePortal = portalContext != null;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isTypeableCombobox = domReference && domReference.getAttribute(\"role\") === \"combobox\" && isTypeableElement(domReference);\n    const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(function(container) {\n        if (container === void 0) {\n            container = floating;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_6__.tabbable)(container, getTabbableOptions()) : [];\n    }, [\n        floating\n    ]);\n    const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floating && type === \"floating\") {\n                return floating;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    }, [\n        domReference,\n        floating,\n        orderRef,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (disabled || !modal) return;\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isTypeableCombobox) {\n                    stopEvent(event);\n                }\n                const els = getTabbableElements();\n                const target = getTarget(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    stopEvent(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floating && event.shiftKey) {\n                    stopEvent(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = getDocument(floating);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        refs,\n        isTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (disabled || !closeOnFocusOut) return;\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            queueMicrotask(()=>{\n                const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context, _node$context2;\n                    return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n                }) || getAncestors(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context3, _node$context4;\n                    return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n                })));\n                // Focus did not move inside the floating tree, and there are no tabbable\n                // portal guards to handle closing.\n                if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n                relatedTarget !== previouslyFocusedElementRef.current) {\n                    preventReturnFocusRef.current = true;\n                    onOpenChange(false, event);\n                }\n            });\n        }\n        if (floating && isHTMLElement(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            !modal && floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                !modal && floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        nodeId,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        var _portalContext$portal;\n        if (disabled) return;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute(\"portal\") + \"]\")) || []);\n        if (floating && modal) {\n            const insideNodes = [\n                floating,\n                ...portalNodes,\n                startDismissButtonRef.current,\n                endDismissButtonRef.current\n            ].filter((x)=>x != null);\n            const suppressorFn = guards ? aria_hidden__WEBPACK_IMPORTED_MODULE_7__.hideOthers : aria_hidden__WEBPACK_IMPORTED_MODULE_7__.suppressOthers;\n            const cleanup = suppressorFn(orderRef.current.includes(\"reference\") || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes, undefined, createAttribute(\"inert\"));\n            return ()=>{\n                cleanup();\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isTypeableCombobox,\n        guards\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        const doc = getDocument(floating);\n        const previouslyFocusedElement = activeElement(doc);\n        // Wait for any layout effect state setters to execute to set `tabIndex`.\n        queueMicrotask(()=>{\n            const focusableElements = getTabbableElements(floating);\n            const initialFocusValue = initialFocusRef.current;\n            const elToFocus = (typeof initialFocusValue === \"number\" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n            const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n            if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n                enqueueFocus(elToFocus, {\n                    preventScroll: elToFocus === floating\n                });\n            }\n        });\n    }, [\n        disabled,\n        open,\n        floating,\n        ignoreInitialFocus,\n        getTabbableElements,\n        initialFocusRef\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        let preventReturnFocusScroll = false;\n        const doc = getDocument(floating);\n        const previouslyFocusedElement = activeElement(doc);\n        const contextData = dataRef.current;\n        previouslyFocusedElementRef.current = previouslyFocusedElement;\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onDismiss(payload) {\n            if (payload.type === \"escapeKey\" && refs.domReference.current) {\n                previouslyFocusedElementRef.current = refs.domReference.current;\n            }\n            if ([\n                \"referencePress\",\n                \"escapeKey\"\n            ].includes(payload.type)) {\n                return;\n            }\n            const returnFocus = payload.data.returnFocus;\n            if (typeof returnFocus === \"object\") {\n                preventReturnFocusRef.current = false;\n                preventReturnFocusScroll = returnFocus.preventScroll;\n            } else {\n                preventReturnFocusRef.current = !returnFocus;\n            }\n        }\n        events.on(\"dismiss\", onDismiss);\n        return ()=>{\n            events.off(\"dismiss\", onDismiss);\n            const activeEl = activeElement(doc);\n            const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n                var _node$context5;\n                return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n            }) || contextData.openEvent && [\n                \"click\",\n                \"mousedown\"\n            ].includes(contextData.openEvent.type);\n            if (shouldFocusReference && refs.domReference.current) {\n                previouslyFocusedElementRef.current = refs.domReference.current;\n            }\n            if (// eslint-disable-next-line react-hooks/exhaustive-deps\n            returnFocusRef.current && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n                enqueueFocus(previouslyFocusedElementRef.current, {\n                    // When dismissing nested floating elements, by the time the rAF has\n                    // executed, the menus will all have been unmounted. When they try\n                    // to get focused, the calls get ignored — leaving the root\n                    // reference focused as desired.\n                    cancelPrevious: false,\n                    preventScroll: preventReturnFocusScroll\n                });\n            }\n        };\n    }, [\n        disabled,\n        floating,\n        returnFocusRef,\n        dataRef,\n        refs,\n        events,\n        tree,\n        nodeId\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(()=>{\n        if (disabled || !portalContext) return;\n        portalContext.setFocusManagerState({\n            ...context,\n            modal,\n            closeOnFocusOut,\n            open\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        disabled,\n        portalContext,\n        modal,\n        open,\n        closeOnFocusOut,\n        context\n    ]);\n    index(()=>{\n        if (disabled) return;\n        if (floating && typeof MutationObserver === \"function\") {\n            const handleMutation = ()=>{\n                const tabIndex = floating.getAttribute(\"tabindex\");\n                if (orderRef.current.includes(\"floating\") || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n                    if (tabIndex !== \"0\") {\n                        floating.setAttribute(\"tabindex\", \"0\");\n                    }\n                } else if (tabIndex !== \"-1\") {\n                    floating.setAttribute(\"tabindex\", \"-1\");\n                }\n            };\n            handleMutation();\n            const observer = new MutationObserver(handleMutation);\n            observer.observe(floating, {\n                childList: true,\n                subtree: true,\n                attributes: true\n            });\n            return ()=>{\n                observer.disconnect();\n            };\n        }\n    }, [\n        disabled,\n        floating,\n        refs,\n        orderRef,\n        getTabbableContent\n    ]);\n    function renderDismissButton(location) {\n        if (disabled || !visuallyHiddenDismiss || !modal) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: (event)=>onOpenChange(false, event.nativeEvent)\n        }, typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\");\n    }\n    const shouldRenderGuards = !disabled && guards && !isTypeableCombobox && (isInsidePortal || modal);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(react__WEBPACK_IMPORTED_MODULE_4__.Fragment, null, shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                const els = getTabbableElements();\n                enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = false;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const nextTabbable = getNextTabbable() || domReference;\n                    nextTabbable == null ? void 0 : nextTabbable.focus();\n                } else {\n                    var _portalContext$before;\n                    (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n                }\n            }\n        }\n    }), !isTypeableCombobox && renderDismissButton(\"start\"), children, renderDismissButton(\"end\"), shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                enqueueFocus(getTabbableElements()[0]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                if (closeOnFocusOut) {\n                    preventReturnFocusRef.current = true;\n                }\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const prevTabbable = getPreviousTabbable() || domReference;\n                    prevTabbable == null ? void 0 : prevTabbable.focus();\n                } else {\n                    var _portalContext$afterO;\n                    (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n                }\n            }\n        }\n    }));\n}\nfunction sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n        return 1;\n    }\n    return 0;\n}\nfunction areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n        return false;\n    }\n    for (const [key, value] of map1.entries()){\n        if (value !== map2.get(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nconst FloatingListContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext({\n    register: ()=>{},\n    unregister: ()=>{},\n    map: /*#__PURE__*/ new Map(),\n    elementsRef: {\n        current: []\n    }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */ function FloatingList(_ref) {\n    let { children, elementsRef, labelsRef } = _ref;\n    const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_4__.useState(()=>new Map());\n    const register = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        setMap((prevMap)=>new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        setMap((prevMap)=>{\n            const map = new Map(prevMap);\n            map.delete(node);\n            return map;\n        });\n    }, []);\n    index(()=>{\n        const newMap = new Map(map);\n        const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n        nodes.forEach((node, index)=>{\n            newMap.set(node, index);\n        });\n        if (!areMapsEqual(map, newMap)) {\n            setMap(newMap);\n        }\n    }, [\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(FloatingListContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n                register,\n                unregister,\n                map,\n                elementsRef,\n                labelsRef\n            }), [\n            register,\n            unregister,\n            map,\n            elementsRef,\n            labelsRef\n        ])\n    }, children);\n}\nfunction useListItem(_temp) {\n    let { label } = _temp === void 0 ? {} : _temp;\n    const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_4__.useState(null);\n    const componentRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const { register, unregister, map, elementsRef, labelsRef } = react__WEBPACK_IMPORTED_MODULE_4__.useContext(FloatingListContext);\n    const ref = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        componentRef.current = node;\n        if (index$1 !== null) {\n            elementsRef.current[index$1] = node;\n            if (labelsRef) {\n                var _node$textContent;\n                const isLabelDefined = label !== undefined;\n                labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n            }\n        }\n    }, [\n        index$1,\n        elementsRef,\n        labelsRef,\n        label\n    ]);\n    index(()=>{\n        const node = componentRef.current;\n        if (node) {\n            register(node);\n            return ()=>{\n                unregister(node);\n            };\n        }\n    }, [\n        register,\n        unregister\n    ]);\n    index(()=>{\n        const index = componentRef.current ? map.get(componentRef.current) : null;\n        if (index != null) {\n            setIndex(index);\n        }\n    }, [\n        map\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            ref,\n            index: index$1 == null ? -1 : index$1\n        }), [\n        index$1,\n        ref\n    ]);\n}\nconst identifier = /*#__PURE__*/ createAttribute(\"scroll-lock\");\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.forwardRef(function FloatingOverlay(_ref, ref) {\n    let { lockScroll = false, ...rest } = _ref;\n    index(()=>{\n        var _window$visualViewpor, _window$visualViewpor2;\n        if (!lockScroll) {\n            return;\n        }\n        const alreadyLocked = document.body.hasAttribute(identifier);\n        if (alreadyLocked) {\n            return;\n        }\n        document.body.setAttribute(identifier, \"\");\n        // RTL <body> scrollbar\n        const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n        const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n        // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n        // technique has fewer side effects.\n        if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n            Object.assign(document.body.style, {\n                overflow: \"hidden\",\n                [paddingProp]: scrollbarWidth + \"px\"\n            });\n            return ()=>{\n                document.body.removeAttribute(identifier);\n                Object.assign(document.body.style, {\n                    overflow: \"\",\n                    [paddingProp]: \"\"\n                });\n            };\n        }\n        // iOS 12 does not support `visualViewport`.\n        const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n        const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n        const scrollX = window.pageXOffset;\n        const scrollY = window.pageYOffset;\n        Object.assign(document.body.style, {\n            position: \"fixed\",\n            overflow: \"hidden\",\n            top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n            left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n            right: \"0\",\n            [paddingProp]: scrollbarWidth + \"px\"\n        });\n        return ()=>{\n            Object.assign(document.body.style, {\n                position: \"\",\n                overflow: \"\",\n                top: \"\",\n                left: \"\",\n                right: \"\",\n                [paddingProp]: \"\"\n            });\n            document.body.removeAttribute(identifier);\n            window.scrollTo(scrollX, scrollY);\n        };\n    }, [\n        lockScroll\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"div\", _extends({\n        ref: ref\n    }, rest, {\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    }));\n});\nfunction isButtonTarget(event) {\n    return isHTMLElement(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isSpaceIgnored(element) {\n    return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */ function useClick(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, elements: { domReference } } = context;\n    const { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) return {};\n        return {\n            reference: {\n                onPointerDown (event) {\n                    pointerTypeRef.current = event.pointerType;\n                },\n                onMouseDown (event) {\n                    // Ignore all buttons except for the \"main\" button.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                    if (event.button !== 0) {\n                        return;\n                    }\n                    if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (eventOption === \"click\") {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                        onOpenChange(false, event.nativeEvent);\n                    } else {\n                        // Prevent stealing focus from the floating element\n                        event.preventDefault();\n                        onOpenChange(true, event.nativeEvent);\n                    }\n                },\n                onClick (event) {\n                    if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                        pointerTypeRef.current = undefined;\n                        return;\n                    }\n                    if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"click\" : true)) {\n                        onOpenChange(false, event.nativeEvent);\n                    } else {\n                        onOpenChange(true, event.nativeEvent);\n                    }\n                },\n                onKeyDown (event) {\n                    pointerTypeRef.current = undefined;\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n                        return;\n                    }\n                    if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                        // Prevent scrolling\n                        event.preventDefault();\n                        didKeyDownRef.current = true;\n                    }\n                    if (event.key === \"Enter\") {\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent);\n                        } else {\n                            onOpenChange(true, event.nativeEvent);\n                        }\n                    }\n                },\n                onKeyUp (event) {\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                        return;\n                    }\n                    if (event.key === \" \" && didKeyDownRef.current) {\n                        didKeyDownRef.current = false;\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent);\n                        } else {\n                            onOpenChange(true, event.nativeEvent);\n                        }\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        dataRef,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        domReference,\n        toggle,\n        open,\n        onOpenChange\n    ]);\n}\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_4__[/*#__PURE__*/ \"useInsertionEffect\".toString()];\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEffectEvent(callback) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_4__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_4__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\nfunction createVirtualElement(domRef, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n        contextElement: domRef.current || undefined,\n        getBoundingClientRect () {\n            var _domRef$current, _data$dataRef$current;\n            const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n                width: 0,\n                height: 0,\n                x: 0,\n                y: 0\n            };\n            const isXAxis = data.axis === \"x\" || data.axis === \"both\";\n            const isYAxis = data.axis === \"y\" || data.axis === \"both\";\n            const canTrackCursorOnAutoUpdate = [\n                \"mouseenter\",\n                \"mousemove\"\n            ].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || \"\") && data.pointerType !== \"touch\";\n            let width = domRect.width;\n            let height = domRect.height;\n            let x = domRect.x;\n            let y = domRect.y;\n            if (offsetX == null && data.x && isXAxis) {\n                offsetX = domRect.x - data.x;\n            }\n            if (offsetY == null && data.y && isYAxis) {\n                offsetY = domRect.y - data.y;\n            }\n            x -= offsetX || 0;\n            y -= offsetY || 0;\n            width = 0;\n            height = 0;\n            if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n                width = data.axis === \"y\" ? domRect.width : 0;\n                height = data.axis === \"x\" ? domRect.height : 0;\n                x = isXAxis && data.x != null ? data.x : x;\n                y = isYAxis && data.y != null ? data.y : y;\n            } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n                height = data.axis === \"x\" ? domRect.height : height;\n                width = data.axis === \"y\" ? domRect.width : width;\n            }\n            isAutoUpdateEvent = true;\n            return {\n                width,\n                height,\n                x,\n                y,\n                top: y,\n                right: x + width,\n                bottom: y + height,\n                left: x\n            };\n        }\n    };\n}\nfunction isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */ function useClientPoint(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, refs, dataRef, elements: { floating } } = context;\n    const { enabled = true, axis = \"both\", x = null, y = null } = props;\n    const initialRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_4__.useState();\n    const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_4__.useState([]);\n    const setReference = useEffectEvent((x, y)=>{\n        if (initialRef.current) return;\n        // Prevent setting if the open event was not a mouse-like one\n        // (e.g. focus to open, then hover over the reference element).\n        // Only apply if the event exists.\n        if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n            return;\n        }\n        refs.setPositionReference(createVirtualElement(refs.domReference, {\n            x,\n            y,\n            axis,\n            dataRef,\n            pointerType\n        }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent((event)=>{\n        if (x != null || y != null) return;\n        if (!open) {\n            setReference(event.clientX, event.clientY);\n        } else if (!cleanupListenerRef.current) {\n            // If there's no cleanup, there's no listener, but we want to ensure\n            // we add the listener if the cursor landed on the floating element and\n            // then back on the reference (i.e. it's interactive).\n            setReactive([]);\n        }\n    });\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n    const addListener = react__WEBPACK_IMPORTED_MODULE_4__.useCallback(()=>{\n        // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n        if (!openCheck || !enabled || x != null || y != null) return;\n        const win = getWindow(refs.floating.current);\n        function handleMouseMove(event) {\n            const target = getTarget(event);\n            if (!contains(refs.floating.current, target)) {\n                setReference(event.clientX, event.clientY);\n            } else {\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            }\n        }\n        if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n            win.addEventListener(\"mousemove\", handleMouseMove);\n            const cleanup = ()=>{\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            };\n            cleanupListenerRef.current = cleanup;\n            return cleanup;\n        }\n        refs.setPositionReference(refs.domReference.current);\n    }, [\n        dataRef,\n        enabled,\n        openCheck,\n        refs,\n        setReference,\n        x,\n        y\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        return addListener();\n    }, [\n        addListener,\n        reactive\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (enabled && !floating) {\n            initialRef.current = false;\n        }\n    }, [\n        enabled,\n        floating\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled && open) {\n            initialRef.current = true;\n        }\n    }, [\n        enabled,\n        open\n    ]);\n    index(()=>{\n        if (enabled && (x != null || y != null)) {\n            initialRef.current = false;\n            setReference(x, y);\n        }\n    }, [\n        enabled,\n        x,\n        y,\n        setReference\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) return {};\n        function setPointerTypeRef(_ref) {\n            let { pointerType } = _ref;\n            setPointerType(pointerType);\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerTypeRef,\n                onPointerEnter: setPointerTypeRef,\n                onMouseMove: handleReferenceEnterOrMove,\n                onMouseEnter: handleReferenceEnterOrMove\n            }\n        };\n    }, [\n        enabled,\n        handleReferenceEnterOrMove\n    ]);\n}\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */ function isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeBubblesProp = (bubbles)=>{\n    var _bubbles$escapeKey, _bubbles$outsidePress;\n    return {\n        escapeKeyBubbles: typeof bubbles === \"boolean\" ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,\n        outsidePressBubbles: typeof bubbles === \"boolean\" ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n    };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ function useDismiss(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, events, nodeId, elements: { reference, domReference, floating }, dataRef } = context;\n    const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles } = props;\n    const tree = useFloatingTree();\n    const nested = useFloatingParentNodeId() != null;\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const { escapeKeyBubbles, outsidePressBubbles } = normalizeBubblesProp(bubbles);\n    const closeOnEscapeKeyDown = useEffectEvent((event)=>{\n        if (!open || !enabled || !escapeKey || event.key !== \"Escape\") {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (!escapeKeyBubbles) {\n            event.stopPropagation();\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context;\n                    if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n        }\n        events.emit(\"dismiss\", {\n            type: \"escapeKey\",\n            data: {\n                returnFocus: {\n                    preventScroll: false\n                }\n            }\n        });\n        onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event);\n    });\n    const closeOnPressOutside = useEffectEvent((event)=>{\n        // Given developers can stop the propagation of the synthetic event,\n        // we can only be confident with a positive value.\n        const insideReactTree = insideReactTreeRef.current;\n        insideReactTreeRef.current = false;\n        if (insideReactTree) {\n            return;\n        }\n        if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n            return;\n        }\n        const target = getTarget(event);\n        // Check if the click occurred on the scrollbar\n        if (isHTMLElement(target) && floating) {\n            // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n            // elements.\n            const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n            const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n            let xCond = canScrollY && event.offsetX > target.clientWidth;\n            // In some browsers it is possible to change the <body> (or window)\n            // scrollbar to the left side, but is very rare and is difficult to\n            // check for. Plus, for modal dialogs with backdrops, it is more\n            // important that the backdrop is checked but not so much the window.\n            if (canScrollY) {\n                const isRTL = getWindow(floating).getComputedStyle(target).direction === \"rtl\";\n                if (isRTL) {\n                    xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n                }\n            }\n            if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n                return;\n            }\n        }\n        const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n            var _node$context;\n            return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n        });\n        if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n            let shouldDismiss = true;\n            children.forEach((child)=>{\n                var _child$context2;\n                if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                    shouldDismiss = false;\n                    return;\n                }\n            });\n            if (!shouldDismiss) {\n                return;\n            }\n        }\n        events.emit(\"dismiss\", {\n            type: \"outsidePress\",\n            data: {\n                returnFocus: nested ? {\n                    preventScroll: true\n                } : isVirtualClick(event) || isVirtualPointerEvent(event)\n            }\n        });\n        onOpenChange(false, event);\n    });\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        function onScroll(event) {\n            onOpenChange(false, event);\n        }\n        const doc = getDocument(floating);\n        escapeKey && doc.addEventListener(\"keydown\", closeOnEscapeKeyDown);\n        outsidePress && doc.addEventListener(outsidePressEvent, closeOnPressOutside);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if (isElement(domReference)) {\n                ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(domReference);\n            }\n            if (isElement(floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(floating));\n            }\n            if (!isElement(reference) && reference && reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            escapeKey && doc.removeEventListener(\"keydown\", closeOnEscapeKeyDown);\n            outsidePress && doc.removeEventListener(outsidePressEvent, closeOnPressOutside);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n        };\n    }, [\n        dataRef,\n        floating,\n        domReference,\n        reference,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        closeOnEscapeKeyDown,\n        closeOnPressOutside\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        insideReactTreeRef.current = false;\n    }, [\n        outsidePress,\n        outsidePressEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onKeyDown: closeOnEscapeKeyDown,\n                [bubbleHandlerKeys[referencePressEvent]]: (event)=>{\n                    if (referencePress) {\n                        events.emit(\"dismiss\", {\n                            type: \"referencePress\",\n                            data: {\n                                returnFocus: false\n                            }\n                        });\n                        onOpenChange(false, event.nativeEvent);\n                    }\n                }\n            },\n            floating: {\n                onKeyDown: closeOnEscapeKeyDown,\n                [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                    insideReactTreeRef.current = true;\n                }\n            }\n        };\n    }, [\n        enabled,\n        events,\n        referencePress,\n        outsidePressEvent,\n        referencePressEvent,\n        onOpenChange,\n        closeOnEscapeKeyDown\n    ]);\n}\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/react\n */ function useFloating(options) {\n    var _options$elements;\n    if (options === void 0) {\n        options = {};\n    }\n    const { open = false, onOpenChange: unstable_onOpenChange, nodeId } = options;\n    const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_4__.useState(null);\n    const domReference = ((_options$elements = options.elements) == null ? void 0 : _options$elements.reference) || _domReference;\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_0__.useFloating)(options);\n    const tree = useFloatingTree();\n    const onOpenChange = useEffectEvent((open, event)=>{\n        if (open) {\n            dataRef.current.openEvent = event;\n        }\n        unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open, event);\n    });\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef({});\n    const events = react__WEBPACK_IMPORTED_MODULE_4__.useState(()=>createPubSub())[0];\n    const floatingId = useId();\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        const positionReference = isElement(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            contextElement: node\n        } : node;\n        position.refs.setReference(positionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((node)=>{\n        if (isElement(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !isElement(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const context = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            ...position,\n            refs,\n            elements,\n            dataRef,\n            nodeId,\n            floatingId,\n            events,\n            open,\n            onOpenChange\n        }), [\n        position,\n        nodeId,\n        floatingId,\n        events,\n        open,\n        onOpenChange,\n        refs,\n        elements\n    ]);\n    index(()=>{\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            elements\n        }), [\n        position,\n        refs,\n        elements,\n        context\n    ]);\n}\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */ function useFocus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, refs, elements: { floating, domReference } } = context;\n    const { enabled = true, keyboardOnly = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(\"\");\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        const doc = getDocument(floating);\n        const win = doc.defaultView || window;\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        win.addEventListener(\"blur\", onBlur);\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n        };\n    }, [\n        floating,\n        domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onDismiss(payload) {\n            if (payload.type === \"referencePress\" || payload.type === \"escapeKey\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"dismiss\", onDismiss);\n        return ()=>{\n            events.off(\"dismiss\", onDismiss);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        return ()=>{\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onPointerDown (_ref) {\n                    let { pointerType } = _ref;\n                    pointerTypeRef.current = pointerType;\n                    blockFocusRef.current = !!(pointerType && keyboardOnly);\n                },\n                onMouseLeave () {\n                    blockFocusRef.current = false;\n                },\n                onFocus (event) {\n                    var _dataRef$current$open;\n                    if (blockFocusRef.current) {\n                        return;\n                    }\n                    // Dismiss with click should ignore the subsequent `focus` trigger,\n                    // but only if the click originated inside the reference element.\n                    if (event.type === \"focus\" && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === \"mousedown\" && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n                        return;\n                    }\n                    onOpenChange(true, event.nativeEvent);\n                },\n                onBlur (event) {\n                    blockFocusRef.current = false;\n                    const relatedTarget = event.relatedTarget;\n                    // Hit the non-modal focus management portal guard. Focus will be\n                    // moved into the floating element immediately after.\n                    const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                    // Wait for the window blur listener to fire.\n                    timeoutRef.current = setTimeout(()=>{\n                        // When focusing the reference element (e.g. regular click), then\n                        // clicking into the floating element, prevent it from hiding.\n                        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                        if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n                            return;\n                        }\n                        onOpenChange(false, event.nativeEvent);\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        keyboardOnly,\n        domReference,\n        refs,\n        dataRef,\n        onOpenChange\n    ]);\n}\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1\n        },\n        ...userProps,\n        ...propsList.map((value)=>value ? value[elementKey] : null).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn)=>fn(...args)).find((val)=>val !== undefined);\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/react#interaction-hooks\n */ function useInteractions(propsList) {\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    // The dependencies are a dynamic array, so we can't use the linter's\n    // suggestion to add it to the deps array.\n    const deps = propsList;\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_4__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    propsList.map((key)=>key == null ? void 0 : key.item));\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n}\nlet isPreventScrollSupported = false;\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nfunction isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    let index = startingIndex;\n    do {\n        var _list$index, _list$index2;\n        index = index + (decrement ? -amount : amount);\n    }while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute(\"disabled\")) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute(\"aria-disabled\")) === \"true\"));\n    return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key == \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */ function useListNavigation(context, props) {\n    const { open, onOpenChange, refs, elements: { domReference, floating } } = context;\n    const { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", cols = 1, scrollItemIntoView = true } = props;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` looping must be enabled to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n            if (!virtual) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` must be virtual to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            console.warn([\n                \"Floating UI: In grid list navigation mode (`cols` > 1), the\",\n                '`orientation` should be either \"horizontal\" or \"both\".'\n            ].join(\" \"));\n        }\n    }\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(onNavigate);\n    const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(!!floating);\n    const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_4__.useState();\n    const focusItem = useEffectEvent(function(listRef, indexRef, forceScrollIntoView) {\n        if (forceScrollIntoView === void 0) {\n            forceScrollIntoView = false;\n        }\n        const item = listRef.current[indexRef.current];\n        if (!item) return;\n        if (virtual) {\n            setActiveId(item.id);\n        } else {\n            enqueueFocus(item, {\n                preventScroll: true,\n                // Mac Safari does not move the virtual cursor unless the focus call\n                // is sync. However, for the very first focus call, we need to wait\n                // for the position to be ready in order to prevent unwanted\n                // scrolling. This means the virtual cursor will not move to the first\n                // item when first opening the floating element, but will on\n                // subsequent calls. `preventScroll` is supported in modern Safari,\n                // so we can use that instead.\n                // iOS Safari must be async or the first item will not be focused.\n                sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n            });\n        }\n        requestAnimationFrame(()=>{\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    });\n    index(()=>{\n        document.createElement(\"div\").focus({\n            get preventScroll () {\n                isPreventScrollSupported = true;\n                return false;\n            }\n        });\n    }, []);\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                onNavigate(selectedIndex);\n            }\n        } else if (previousMountedRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current(null);\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (activeIndex == null) {\n                forceSyncFocus.current = false;\n                if (selectedIndex != null) {\n                    return;\n                }\n                // Reset while the floating element was open (e.g. the list changed).\n                if (previousMountedRef.current) {\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                }\n                // Initial sync.\n                if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                    let runs = 0;\n                    const waitForListPopulated = ()=>{\n                        if (listRef.current[0] == null) {\n                            // Avoid letting the browser paint if possible on the first try,\n                            // otherwise use rAF. Don't try more than twice, since something\n                            // is wrong otherwise.\n                            if (runs < 2) {\n                                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                                scheduler(waitForListPopulated);\n                            }\n                            runs++;\n                        } else {\n                            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                            keyRef.current = null;\n                            onNavigate(indexRef.current);\n                        }\n                    };\n                    waitForListPopulated();\n                }\n            } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n                indexRef.current = activeIndex;\n                focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n                forceScrollIntoViewRef.current = false;\n            }\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        activeIndex,\n        selectedIndex,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (previousMountedRef.current && !floating && tree) {\n            var _nodes$find, _nodes$find$context;\n            const nodes = tree.nodesRef.current;\n            const parent = (_nodes$find = nodes.find((node)=>node.id === parentId)) == null ? void 0 : (_nodes$find$context = _nodes$find.context) == null ? void 0 : _nodes$find$context.elements.floating;\n            const activeEl = activeElement(getDocument(floating));\n            const treeContainsActiveEl = nodes.some((node)=>node.context && contains(node.context.elements.floating, activeEl));\n            if (parent && !treeContainsActiveEl) {\n                parent.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }, [\n        enabled,\n        floating,\n        tree,\n        parentId\n    ]);\n    index(()=>{\n        previousOnNavigateRef.current = onNavigate;\n        previousMountedRef.current = !!floating;\n    });\n    index(()=>{\n        if (!open) {\n            keyRef.current = null;\n        }\n    }, [\n        open\n    ]);\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!open) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1) {\n                onNavigate(index);\n            }\n        }\n        const props = {\n            onFocus (_ref) {\n                let { currentTarget } = _ref;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref2)=>{\n                let { currentTarget } = _ref2;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref3) {\n                    let { currentTarget } = _ref3;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave (_ref4) {\n                    let { pointerType } = _ref4;\n                    if (!isPointerModalityRef.current || pointerType === \"touch\") {\n                        return;\n                    }\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                    onNavigate(null);\n                    if (!virtual) {\n                        enqueueFocus(refs.floating.current, {\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        open,\n        refs,\n        focusItem,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        const disabledIndices = disabledIndicesRef.current;\n        function onKeyDown(event) {\n            isPointerModalityRef.current = false;\n            forceSyncFocus.current = true;\n            // If the floating element is animating out, ignore navigation. Otherwise,\n            // the `activeIndex` gets set to 0 despite not being open so the next time\n            // the user ArrowDowns, the first item won't be focused.\n            if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n                return;\n            }\n            if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n                stopEvent(event);\n                onOpenChange(false, event.nativeEvent);\n                if (isHTMLElement(domReference)) {\n                    domReference.focus();\n                }\n                return;\n            }\n            const currentIndex = indexRef.current;\n            const minIndex = getMinIndex(listRef, disabledIndices);\n            const maxIndex = getMaxIndex(listRef, disabledIndices);\n            if (event.key === \"Home\") {\n                stopEvent(event);\n                indexRef.current = minIndex;\n                onNavigate(indexRef.current);\n            }\n            if (event.key === \"End\") {\n                stopEvent(event);\n                indexRef.current = maxIndex;\n                onNavigate(indexRef.current);\n            }\n            // Grid navigation.\n            if (cols > 1) {\n                const prevIndex = indexRef.current;\n                if (event.key === ARROW_UP) {\n                    stopEvent(event);\n                    if (prevIndex === -1) {\n                        indexRef.current = maxIndex;\n                    } else {\n                        indexRef.current = findNonDisabledIndex(listRef, {\n                            startingIndex: prevIndex,\n                            amount: cols,\n                            decrement: true,\n                            disabledIndices\n                        });\n                        if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n                            const col = prevIndex % cols;\n                            const maxCol = maxIndex % cols;\n                            const offset = maxIndex - (maxCol - col);\n                            if (maxCol === col) {\n                                indexRef.current = maxIndex;\n                            } else {\n                                indexRef.current = maxCol > col ? offset : offset - cols;\n                            }\n                        }\n                    }\n                    if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                        indexRef.current = prevIndex;\n                    }\n                    onNavigate(indexRef.current);\n                }\n                if (event.key === ARROW_DOWN) {\n                    stopEvent(event);\n                    if (prevIndex === -1) {\n                        indexRef.current = minIndex;\n                    } else {\n                        indexRef.current = findNonDisabledIndex(listRef, {\n                            startingIndex: prevIndex,\n                            amount: cols,\n                            disabledIndices\n                        });\n                        if (loop && prevIndex + cols > maxIndex) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex % cols - cols,\n                                amount: cols,\n                                disabledIndices\n                            });\n                        }\n                    }\n                    if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                        indexRef.current = prevIndex;\n                    }\n                    onNavigate(indexRef.current);\n                }\n                // Remains on the same row/column.\n                if (orientation === \"both\") {\n                    const prevRow = Math.floor(prevIndex / cols);\n                    if (event.key === ARROW_RIGHT) {\n                        stopEvent(event);\n                        if (prevIndex % cols !== cols - 1) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex,\n                                disabledIndices\n                            });\n                            if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                                indexRef.current = findNonDisabledIndex(listRef, {\n                                    startingIndex: prevIndex - prevIndex % cols - 1,\n                                    disabledIndices\n                                });\n                            }\n                        } else if (loop) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex - prevIndex % cols - 1,\n                                disabledIndices\n                            });\n                        }\n                        if (isDifferentRow(indexRef.current, cols, prevRow)) {\n                            indexRef.current = prevIndex;\n                        }\n                    }\n                    if (event.key === ARROW_LEFT) {\n                        stopEvent(event);\n                        if (prevIndex % cols !== 0) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex,\n                                disabledIndices,\n                                decrement: true\n                            });\n                            if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                                indexRef.current = findNonDisabledIndex(listRef, {\n                                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                                    decrement: true,\n                                    disabledIndices\n                                });\n                            }\n                        } else if (loop) {\n                            indexRef.current = findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex + (cols - prevIndex % cols),\n                                decrement: true,\n                                disabledIndices\n                            });\n                        }\n                        if (isDifferentRow(indexRef.current, cols, prevRow)) {\n                            indexRef.current = prevIndex;\n                        }\n                    }\n                    const lastRow = Math.floor(maxIndex / cols) === prevRow;\n                    if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                        if (loop && lastRow) {\n                            indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                                startingIndex: prevIndex - prevIndex % cols - 1,\n                                disabledIndices\n                            });\n                        } else {\n                            indexRef.current = prevIndex;\n                        }\n                    }\n                    onNavigate(indexRef.current);\n                    return;\n                }\n            }\n            if (isMainOrientationKey(event.key, orientation)) {\n                stopEvent(event);\n                // Reset the index if no item is focused.\n                if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n                    indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                    onNavigate(indexRef.current);\n                    return;\n                }\n                if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                    if (loop) {\n                        indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        }));\n                    }\n                } else {\n                    if (loop) {\n                        indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        }));\n                    }\n                }\n                if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                    onNavigate(null);\n                } else {\n                    onNavigate(indexRef.current);\n                }\n            }\n        }\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && isVirtualClick(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && isVirtualPointerEvent(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": activeId\n        };\n        return {\n            reference: {\n                ...ariaActiveDescendantProp,\n                onKeyDown (event) {\n                    isPointerModalityRef.current = false;\n                    const isArrowKey = event.key.indexOf(\"Arrow\") === 0;\n                    if (virtual && open) {\n                        return onKeyDown(event);\n                    }\n                    // If a floating element should not open on arrow key down, avoid\n                    // setting `activeIndex` while it's closed.\n                    if (!open && !openOnArrowKeyDown && isArrowKey) {\n                        return;\n                    }\n                    const isNavigationKey = isArrowKey || event.key === \"Enter\" || event.key.trim() === \"\";\n                    const isMainKey = isMainOrientationKey(event.key, orientation);\n                    const isCrossKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n                    if (isNavigationKey) {\n                        keyRef.current = nested && isMainKey ? null : event.key;\n                    }\n                    if (nested) {\n                        if (isCrossKey) {\n                            stopEvent(event);\n                            if (open) {\n                                indexRef.current = getMinIndex(listRef, disabledIndices);\n                                onNavigate(indexRef.current);\n                            } else {\n                                onOpenChange(true, event.nativeEvent);\n                            }\n                        }\n                        return;\n                    }\n                    if (isMainKey) {\n                        if (selectedIndex != null) {\n                            indexRef.current = selectedIndex;\n                        }\n                        stopEvent(event);\n                        if (!open && openOnArrowKeyDown) {\n                            onOpenChange(true, event.nativeEvent);\n                        } else {\n                            onKeyDown(event);\n                        }\n                        if (open) {\n                            onNavigate(indexRef.current);\n                        }\n                    }\n                },\n                onFocus () {\n                    if (open) {\n                        onNavigate(null);\n                    }\n                },\n                onPointerDown: checkVirtualPointer,\n                onMouseDown: checkVirtualMouse,\n                onClick: checkVirtualMouse\n            },\n            floating: {\n                \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n                ...ariaActiveDescendantProp,\n                onKeyDown,\n                onPointerMove () {\n                    isPointerModalityRef.current = true;\n                }\n            },\n            item\n        };\n    }, [\n        domReference,\n        refs,\n        activeId,\n        disabledIndicesRef,\n        latestOpenRef,\n        listRef,\n        enabled,\n        orientation,\n        rtl,\n        virtual,\n        open,\n        hasActiveIndex,\n        nested,\n        selectedIndex,\n        openOnArrowKeyDown,\n        allowEscape,\n        cols,\n        loop,\n        focusItemOnOpen,\n        onNavigate,\n        onOpenChange,\n        item\n    ]);\n}\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */ function useMergeRefs(refs) {\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (typeof ref === \"function\") {\n                    ref(value);\n                } else if (ref != null) {\n                    ref.current = value;\n                }\n            });\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ function useRole(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, floatingId } = context;\n    const { enabled = true, role = \"dialog\" } = props;\n    const referenceId = useId();\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        const floatingProps = {\n            id: floatingId,\n            role\n        };\n        if (!enabled) {\n            return {};\n        }\n        if (role === \"tooltip\") {\n            return {\n                reference: {\n                    \"aria-describedby\": open ? floatingId : undefined\n                },\n                floating: floatingProps\n            };\n        }\n        return {\n            reference: {\n                \"aria-expanded\": open ? \"true\" : \"false\",\n                \"aria-haspopup\": role === \"alertdialog\" ? \"dialog\" : role,\n                \"aria-controls\": open ? floatingId : undefined,\n                ...role === \"listbox\" && {\n                    role: \"combobox\"\n                },\n                ...role === \"menu\" && {\n                    id: referenceId\n                }\n            },\n            floating: {\n                ...floatingProps,\n                ...role === \"menu\" && {\n                    \"aria-labelledby\": referenceId\n                }\n            }\n        };\n    }, [\n        enabled,\n        role,\n        open,\n        floatingId,\n        referenceId\n    ]);\n}\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === \"function\" ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_4__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!open) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        durationMs\n    ]);\n    return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements: { floating } } = context;\n    const { duration = 250 } = props;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_4__.useState(false);\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_4__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    // `initiated` check prevents this `setState` call from breaking\n    // <FloatingPortal />. This call is necessary to ensure subsequent opens\n    // after the initial one allows the correct side animation to play when the\n    // placement has changed.\n    index(()=>{\n        if (initiated && !isMounted) {\n            setStatus(\"unmounted\");\n        }\n    }, [\n        initiated,\n        isMounted\n    ]);\n    index(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                setStatus(\"open\");\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        } else {\n            setInitiated(true);\n            setStatus(\"close\");\n        }\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = props;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const fnArgs = react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>({\n            side,\n            placement\n        }), [\n        side,\n        placement\n    ]);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_4__.useState(()=>({\n            ...execWithArgsOrReturn(unstable_common, fnArgs),\n            ...execWithArgsOrReturn(unstable_initial, fnArgs)\n        }));\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(()=>{\n        const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n        const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n        const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n        const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status,\n        fnArgs\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ function useTypeahead(context, props) {\n    var _ref;\n    const { open, dataRef } = context;\n    const { listRef, activeIndex, onMatch: unstable_onMatch, onTypingChange: unstable_onTypingChange, enabled = true, findMatch = null, resetMs = 750, ignoreKeys = [], selectedIndex = null } = props;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef();\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(()=>{\n        if (open) {\n            clearTimeout(timeoutIdRef.current);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref2;\n            prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setTypingChange(value) {\n            if (value) {\n                if (!dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            } else {\n                if (dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            }\n        }\n        function getMatchingIndex(list, orderedList, string) {\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n            return str ? list.indexOf(str) : -1;\n        }\n        function onKeyDown(event) {\n            const listContent = listRef.current;\n            if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n                if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n                    setTypingChange(false);\n                } else if (event.key === \" \") {\n                    stopEvent(event);\n                }\n            }\n            if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n            event.key.length !== 1 || // Modifier key.\n            event.ctrlKey || event.metaKey || event.altKey) {\n                return;\n            }\n            if (open && event.key !== \" \") {\n                stopEvent(event);\n                setTypingChange(true);\n            }\n            // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n            // allow it in this case, too.\n            const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n                var _text$, _text$2;\n                return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n            });\n            // Allows the user to cycle through items that start with the same letter\n            // in rapid succession.\n            if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n            }\n            stringRef.current += event.key;\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = setTimeout(()=>{\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n                setTypingChange(false);\n            }, resetMs);\n            const prevIndex = prevIndexRef.current;\n            const index = getMatchingIndex(listContent, [\n                ...listContent.slice((prevIndex || 0) + 1),\n                ...listContent.slice(0, (prevIndex || 0) + 1)\n            ], stringRef.current);\n            if (index !== -1) {\n                onMatch(index);\n                matchIndexRef.current = index;\n            } else if (event.key !== \" \") {\n                stringRef.current = \"\";\n                setTypingChange(false);\n            }\n        }\n        return {\n            reference: {\n                onKeyDown\n            },\n            floating: {\n                onKeyDown,\n                onKeyUp (event) {\n                    if (event.key === \" \") {\n                        setTypingChange(false);\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        open,\n        dataRef,\n        listRef,\n        resetMs,\n        ignoreKeysRef,\n        findMatchRef,\n        onMatch,\n        onTypingChange\n    ]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n    return {\n        ...state,\n        rects: {\n            ...state.rects,\n            floating: {\n                ...state.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (state) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = props;\n            const { rects, elements: { floating } } = state;\n            const item = listRef.current[index];\n            if (true) {\n                if (!state.placement.startsWith(\"bottom\")) {\n                    console.warn([\n                        'Floating UI: `placement` side must be \"bottom\" when using the',\n                        \"`inner` middleware.\"\n                    ].join(\" \"));\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...state,\n                ...await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n            };\n            const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = Math.max(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n            el.style.maxHeight = maxHeight + \"px\";\n            el.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(true));\n                } else {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(false));\n                }\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, el.offsetHeight), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */ function useInnerOffset(context, props) {\n    const { open, elements } = context;\n    const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_4__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_4__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test(getUserAgent())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_4__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            floating: {\n                onKeyDown () {\n                    controlledScrollingRef.current = true;\n                },\n                onWheel () {\n                    controlledScrollingRef.current = false;\n                },\n                onPointerMove () {\n                    controlledScrollingRef.current = false;\n                },\n                onScroll () {\n                    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                    if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                        return;\n                    }\n                    if (prevScrollTopRef.current !== null) {\n                        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                            (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onChange((d)=>d + scrollDiff));\n                        }\n                    }\n                    // [Firefox] Wait for the height change to have been applied.\n                    requestAnimationFrame(()=>{\n                        prevScrollTopRef.current = el.scrollTop;\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        overflowRef,\n        elements.floating,\n        scrollRef,\n        onChange\n    ]);\n}\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safePolygon\n */ function safePolygon(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n        const currentTime = performance.now();\n        const elapsedTime = currentTime - lastCursorTime;\n        if (lastX === null || lastY === null || elapsedTime === 0) {\n            lastX = x;\n            lastY = y;\n            lastCursorTime = currentTime;\n            return null;\n        }\n        const deltaX = x - lastX;\n        const deltaY = y - lastY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        const speed = distance / elapsedTime; // px / ms\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return speed;\n    }\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeout(timeoutId);\n                onClose();\n            }\n            clearTimeout(timeoutId);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = getTarget(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = contains(elements.floating, target);\n            const isOverReferenceEl = contains(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            const isFloatingWider = rect.width > refRect.width;\n            const isFloatingTaller = rect.height > refRect.height;\n            const left = (isFloatingWider ? refRect : rect).left;\n            const right = (isFloatingWider ? refRect : rect).right;\n            const top = (isFloatingTaller ? refRect : rect).top;\n            const bottom = (isFloatingTaller ? refRect : rect).bottom;\n            if (isOverFloatingEl) {\n                hasLanded = true;\n                if (!isLeave) {\n                    return;\n                }\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2)=>{\n                let { context } = _ref2;\n                return context == null ? void 0 : context.open;\n            })) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            left,\n                            refRect.top + 1\n                        ],\n                        [\n                            left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            left,\n                            rect.top + 1\n                        ],\n                        [\n                            left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n            }\n            function getPolygon(_ref3) {\n                let [x, y] = _ref3;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            if (isPointInPolygon([\n                clientX,\n                clientY\n            ], rectPoly)) {\n                return;\n            } else if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isLeave && requireIntent) {\n                const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n                const cursorSpeedThreshold = 0.1;\n                if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n                    return close();\n                }\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], getPolygon([\n                x,\n                y\n            ]))) {\n                close();\n            } else if (!hasLanded && requireIntent) {\n                timeoutId = window.setTimeout(close, 40);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThIO0FBQ2tFO0FBQ2pLO0FBQzRCO0FBQ2E7QUFDcEM7QUFDZ0I7QUFFcEQsU0FBUzBCO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxJQUFJUSxRQUFRLE9BQU9DLGFBQWEsY0FBY3hCLGtEQUFlQSxHQUFHQyw0Q0FBU0E7QUFFekUsSUFBSXdCLHdCQUF3QjtBQUM1QixJQUFJQyxRQUFRO0FBQ1osTUFBTUMsUUFBUSxJQUFNLGlCQUFpQkQ7QUFDckMsU0FBU0U7SUFDUCxNQUFNLENBQUNDLElBQUlDLE1BQU0sR0FBRy9CLDJDQUFjLENBQUMsSUFBTTBCLHdCQUF3QkUsVUFBVUs7SUFDM0VULE1BQU07UUFDSixJQUFJTSxNQUFNLE1BQU07WUFDZEMsTUFBTUg7UUFDUjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHLEVBQUU7SUFDTDVCLDRDQUFlLENBQUM7UUFDZCxJQUFJLENBQUMwQix1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QXFCO2dCQUM1QyxPQUFPM2tCO1lBQ1Q7WUFDQSxJQUFJLENBQUNxa0IsV0FBV2YsZUFBZTtnQkFDN0IsTUFBTTZCLGNBQWN0QixlQUFlcHZCLE1BQU1rSixPQUFPLEVBQUVsSixNQUFNbUosT0FBTztnQkFDL0QsTUFBTXduQix1QkFBdUI7Z0JBQzdCLElBQUlELGdCQUFnQixRQUFRQSxjQUFjQyxzQkFBc0I7b0JBQzlELE9BQU9wbEI7Z0JBQ1Q7WUFDRjtZQUNBLElBQUksQ0FBQ3lpQixpQkFBaUI7Z0JBQUM5a0I7Z0JBQVNDO2FBQVEsRUFBRW1uQixXQUFXO2dCQUFDenhCO2dCQUFHRTthQUFFLElBQUk7Z0JBQzdEd007WUFDRixPQUFPLElBQUksQ0FBQ3VqQixhQUFhRCxlQUFlO2dCQUN0QzdlLFlBQVl4TSxPQUFPZ0YsVUFBVSxDQUFDK0MsT0FBTztZQUN2QztRQUNGO0lBQ0Y7SUFDQTRQLEdBQUd6UixTQUFTLEdBQUc7UUFDYkM7SUFDRjtJQUNBLE9BQU93UjtBQUNUO0FBRXlmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b2JhbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QuZXNtLmpzP2U3NDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGxhdGZvcm0sIGdldE92ZXJmbG93QW5jZXN0b3JzLCB1c2VGbG9hdGluZyBhcyB1c2VGbG9hdGluZyQxLCBvZmZzZXQsIGRldGVjdE92ZXJmbG93IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdXBwb3J0c0luZXJ0LCBoaWRlT3RoZXJzLCBzdXBwcmVzc090aGVycyB9IGZyb20gJ2FyaWEtaGlkZGVuJztcbmltcG9ydCB7IHRhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxubGV0IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IGZhbHNlO1xubGV0IGNvdW50ID0gMDtcbmNvbnN0IGdlbklkID0gKCkgPT4gXCJmbG9hdGluZy11aS1cIiArIGNvdW50Kys7XG5mdW5jdGlvbiB1c2VGbG9hdGluZ0lkKCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA/IGdlbklkKCkgOiB1bmRlZmluZWQpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHNldElkKGdlbklkKCkpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlcnZlckhhbmRvZmZDb21wbGV0ZSkge1xuICAgICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUlkIH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlUmVhY3RJZCA9IFJlYWN0Wy8qI19fUFVSRV9fKi8ndXNlSWQnLnRvU3RyaW5nKCldO1xuXG4vKipcbiAqIFVzZXMgUmVhY3QgMTgncyBidWlsdC1pbiBgdXNlSWQoKWAgd2hlbiBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgdG8gYVxuICogc2xpZ2h0bHkgbGVzcyBwZXJmb3JtYW50IChyZXF1aXJpbmcgYSBkb3VibGUgcmVuZGVyKSBpbXBsZW1lbnRhdGlvbiBmb3JcbiAqIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSWRcbiAqL1xuY29uc3QgdXNlSWQgPSB1c2VSZWFjdElkIHx8IHVzZUZsb2F0aW5nSWQ7XG5cbi8qKlxuICogUmVuZGVycyBhIHBvaW50aW5nIGFycm93IHRyaWFuZ2xlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nQXJyb3dcbiAqL1xuY29uc3QgRmxvYXRpbmdBcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nQXJyb3coX3JlZiwgcmVmKSB7XG4gIGxldCB7XG4gICAgY29udGV4dDoge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlRGF0YToge1xuICAgICAgICBhcnJvd1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGggPSAxNCxcbiAgICBoZWlnaHQgPSA3LFxuICAgIHRpcFJhZGl1cyA9IDAsXG4gICAgc3Ryb2tlV2lkdGggPSAwLFxuICAgIHN0YXRpY09mZnNldCxcbiAgICBzdHJva2UsXG4gICAgZCxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfSA9IHt9LFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIXJlZikge1xuICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZyBVSTogVGhlIGByZWZgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgRmxvYXRpbmdBcnJvd2AnLCAnY29tcG9uZW50LicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbGlwUGF0aElkID0gdXNlSWQoKTtcbiAgaWYgKCFmbG9hdGluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gU3Ryb2tlcyBtdXN0IGJlIGRvdWJsZSB0aGUgYm9yZGVyIHdpZHRoLCB0aGlzIGVuc3VyZXMgdGhlIHN0cm9rZSdzIHdpZHRoXG4gIC8vIHdvcmtzIGFzIHlvdSdkIGV4cGVjdC5cbiAgc3Ryb2tlV2lkdGggKj0gMjtcbiAgY29uc3QgaGFsZlN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggLyAyO1xuICBjb25zdCBzdmdYID0gd2lkdGggLyAyICogKHRpcFJhZGl1cyAvIC04ICsgMSk7XG4gIGNvbnN0IHN2Z1kgPSBoZWlnaHQgLyAyICogdGlwUmFkaXVzIC8gNDtcbiAgY29uc3QgW3NpZGUsIGFsaWdubWVudF0gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKTtcbiAgY29uc3QgaXNSVEwgPSBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZyk7XG4gIGNvbnN0IGlzQ3VzdG9tU2hhcGUgPSAhIWQ7XG4gIGNvbnN0IGlzVmVydGljYWxTaWRlID0gc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbSc7XG4gIGNvbnN0IHlPZmZzZXRQcm9wID0gc3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBsZXQgeE9mZnNldFByb3AgPSBzdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIGlmIChzdGF0aWNPZmZzZXQgJiYgaXNSVEwpIHtcbiAgICB4T2Zmc2V0UHJvcCA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGNvbnN0IGFycm93WCA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueCkgIT0gbnVsbCA/IHN0YXRpY09mZnNldCB8fCBhcnJvdy54IDogJyc7XG4gIGNvbnN0IGFycm93WSA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueSkgIT0gbnVsbCA/IHN0YXRpY09mZnNldCB8fCBhcnJvdy55IDogJyc7XG4gIGNvbnN0IGRWYWx1ZSA9IGQgfHwgJ00wLDAnICsgKFwiIEhcIiArIHdpZHRoKSArIChcIiBMXCIgKyAod2lkdGggLSBzdmdYKSArIFwiLFwiICsgKGhlaWdodCAtIHN2Z1kpKSArIChcIiBRXCIgKyB3aWR0aCAvIDIgKyBcIixcIiArIGhlaWdodCArIFwiIFwiICsgc3ZnWCArIFwiLFwiICsgKGhlaWdodCAtIHN2Z1kpKSArICcgWic7XG4gIGNvbnN0IHJvdGF0aW9uID0ge1xuICAgIHRvcDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoMTgwZGVnKScgOiAnJyxcbiAgICBsZWZ0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSg5MGRlZyknIDogJ3JvdGF0ZSgtOTBkZWcpJyxcbiAgICBib3R0b206IGlzQ3VzdG9tU2hhcGUgPyAnJyA6ICdyb3RhdGUoMTgwZGVnKScsXG4gICAgcmlnaHQ6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKC05MGRlZyknIDogJ3JvdGF0ZSg5MGRlZyknXG4gIH1bc2lkZV07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICByZWY6IHJlZixcbiAgICB3aWR0aDogaXNDdXN0b21TaGFwZSA/IHdpZHRoIDogd2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoLFxuICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIChoZWlnaHQgPiB3aWR0aCA/IGhlaWdodCA6IHdpZHRoKSxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBbeE9mZnNldFByb3BdOiBhcnJvd1gsXG4gICAgICBbeU9mZnNldFByb3BdOiBhcnJvd1ksXG4gICAgICBbc2lkZV06IGlzVmVydGljYWxTaWRlIHx8IGlzQ3VzdG9tU2hhcGUgPyAnMTAwJScgOiBcImNhbGMoMTAwJSAtIFwiICsgc3Ryb2tlV2lkdGggLyAyICsgXCJweClcIixcbiAgICAgIHRyYW5zZm9ybTogXCJcIiArIHJvdGF0aW9uICsgKHRyYW5zZm9ybSAhPSBudWxsID8gdHJhbnNmb3JtIDogJycpLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfVxuICB9KSwgc3Ryb2tlV2lkdGggPiAwICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgY2xpcFBhdGg6IFwidXJsKCNcIiArIGNsaXBQYXRoSWQgKyBcIilcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBzdHJva2U6IHN0cm9rZVxuICAgIC8vIEFjY291bnQgZm9yIHRoZSBzdHJva2Ugb24gdGhlIGZpbGwgcGF0aCByZW5kZXJlZCBiZWxvdy5cbiAgICAsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoICsgKGQgPyAwIDogMSksXG4gICAgZDogZFZhbHVlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIHN0cm9rZTogc3Ryb2tlV2lkdGggJiYgIWQgPyByZXN0LmZpbGwgOiAnbm9uZScsXG4gICAgZDogZFZhbHVlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIsIHtcbiAgICBpZDogY2xpcFBhdGhJZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHg6IC1oYWxmU3Ryb2tlV2lkdGgsXG4gICAgeTogaGFsZlN0cm9rZVdpZHRoICogKGlzQ3VzdG9tU2hhcGUgPyAtMSA6IDEpLFxuICAgIHdpZHRoOiB3aWR0aCArIHN0cm9rZVdpZHRoLFxuICAgIGhlaWdodDogd2lkdGhcbiAgfSkpKTtcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVQdWJTdWIoKSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0LmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKGRhdGEpKTtcbiAgICB9LFxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgbWFwLnNldChldmVudCwgWy4uLihtYXAuZ2V0KGV2ZW50KSB8fCBbXSksIGxpc3RlbmVyXSk7XG4gICAgfSxcbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgbWFwLnNldChldmVudCwgKChfbWFwJGdldDIgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5maWx0ZXIobCA9PiBsICE9PSBsaXN0ZW5lcikpIHx8IFtdKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IEZsb2F0aW5nTm9kZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IEZsb2F0aW5nVHJlZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufTtcbmNvbnN0IHVzZUZsb2F0aW5nVHJlZSA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdUcmVlQ29udGV4dCk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbm9kZSBpbnRvIHRoZSBmbG9hdGluZyB0cmVlLCByZXR1cm5pbmcgaXRzIGlkLlxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ05vZGVJZChjdXN0b21QYXJlbnRJZCkge1xuICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcmVhY3RQYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gY3VzdG9tUGFyZW50SWQgfHwgcmVhY3RQYXJlbnRJZDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfTtcbiAgICB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUucmVtb3ZlTm9kZShub2RlKTtcbiAgICB9O1xuICB9LCBbdHJlZSwgaWQsIHBhcmVudElkXSk7XG4gIHJldHVybiBpZDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBwYXJlbnQgbm9kZSBjb250ZXh0IGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nTm9kZShfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nTm9kZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgaWQsXG4gICAgICBwYXJlbnRJZFxuICAgIH0pLCBbaWQsIHBhcmVudElkXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cyB3aGVuIHRoZXkgYXJlIG5vdCBjaGlsZHJlbiBvZlxuICogZWFjaCBvdGhlciBvbiB0aGUgRE9NIChpLmUuIHBvcnRhbGxlZCB0byBhIGNvbW1vbiBub2RlLCByYXRoZXIgdGhhbiB0aGVpclxuICogcmVzcGVjdGl2ZSBwYXJlbnQpLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1RyZWUoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IG5vZGVzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgYWRkTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBbLi4ubm9kZXNSZWYuY3VycmVudCwgbm9kZV07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVtb3ZlTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBub2Rlc1JlZi5jdXJyZW50LmZpbHRlcihuID0+IG4gIT09IG5vZGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGV2ZW50cyA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZVB1YlN1YigpKVswXTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nVHJlZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgbm9kZXNSZWYsXG4gICAgICBhZGROb2RlLFxuICAgICAgcmVtb3ZlTm9kZSxcbiAgICAgIGV2ZW50c1xuICAgIH0pLCBbbm9kZXNSZWYsIGFkZE5vZGUsIHJlbW92ZU5vZGUsIGV2ZW50c10pXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG59XG5cbi8vIEF2b2lkIENocm9tZSBEZXZUb29scyBibHVlIHdhcm5pbmcuXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gdWFEYXRhLnBsYXRmb3JtO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm07XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBicmFuZCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gYnJhbmQgKyBcIi9cIiArIHZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3codmFsdWUpIHtcbiAgcmV0dXJuIGdldERvY3VtZW50KHZhbHVlKS5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50IDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50IDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBCcm93c2VycyB3aXRob3V0IGBTaGFkb3dSb290YCBzdXBwb3J0XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL2IzNWQ1YzAyZmU5MDBiYWRjY2QwY2YxYThmMjNiYjU5MzQxOWYyMzgvcGFja2FnZXMvQHJlYWN0LWFyaWEvdXRpbHMvc3JjL2lzVmlydHVhbEV2ZW50LnRzXG5mdW5jdGlvbiBpc1ZpcnR1YWxDbGljayhldmVudCkge1xuICBpZiAoZXZlbnQubW96SW5wdXRTb3VyY2UgPT09IDAgJiYgZXZlbnQuaXNUcnVzdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYW5kcm9pZFJlID0gL0FuZHJvaWQvaTtcbiAgaWYgKChhbmRyb2lkUmUudGVzdChnZXRQbGF0Zm9ybSgpKSB8fCBhbmRyb2lkUmUudGVzdChnZXRVc2VyQWdlbnQoKSkpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMTtcbiAgfVxuICByZXR1cm4gZXZlbnQuZGV0YWlsID09PSAwICYmICFldmVudC5wb2ludGVyVHlwZTtcbn1cbmZ1bmN0aW9uIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQud2lkdGggPT09IDAgJiYgZXZlbnQuaGVpZ2h0ID09PSAwIHx8IGV2ZW50LndpZHRoID09PSAxICYmIGV2ZW50LmhlaWdodCA9PT0gMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09ICdtb3VzZScgfHxcbiAgLy8gaU9TIFZvaWNlT3ZlciByZXR1cm5zIDAuMzMz4oCiIGZvciB3aWR0aC9oZWlnaHQuXG4gIGV2ZW50LndpZHRoIDwgMSAmJiBldmVudC5oZWlnaHQgPCAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBDaHJvbWUgRGV2VG9vbHMgZG9lcyBub3QgY29tcGxhaW4gYWJvdXQgbmF2aWdhdG9yLnZlbmRvclxuICByZXR1cm4gL2FwcGxlL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbn1cbmZ1bmN0aW9uIGlzTWFjKCkge1xuICByZXR1cm4gZ2V0UGxhdGZvcm0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21hYycpICYmICFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG59XG5mdW5jdGlvbiBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCBzdHJpY3QpIHtcbiAgLy8gT24gc29tZSBMaW51eCBtYWNoaW5lcyB3aXRoIENocm9taXVtLCBtb3VzZSBpbnB1dHMgcmV0dXJuIGEgYHBvaW50ZXJUeXBlYFxuICAvLyBvZiBcInBlblwiOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIwMTVcbiAgY29uc3QgdmFsdWVzID0gWydtb3VzZScsICdwZW4nXTtcbiAgaWYgKCFzdHJpY3QpIHtcbiAgICB2YWx1ZXMucHVzaCgnJywgdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHBvaW50ZXJUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RFdmVudChldmVudCkge1xuICByZXR1cm4gJ25hdGl2ZUV2ZW50JyBpbiBldmVudDtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gbmV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGUobmFtZSkge1xuICByZXR1cm4gXCJkYXRhLWZsb2F0aW5nLXVpLVwiICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuY29uc3Qgc2FmZVBvbHlnb25JZGVudGlmaWVyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgnc2FmZS1wb2x5Z29uJyk7XG5mdW5jdGlvbiBnZXREZWxheSh2YWx1ZSwgcHJvcCwgcG9pbnRlclR5cGUpIHtcbiAgaWYgKHBvaW50ZXJUeXBlICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWVbcHJvcF07XG59XG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIGhvdmVyaW5nIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCBsaWtlXG4gKiBDU1MgYDpob3ZlcmAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXJcbiAqL1xuZnVuY3Rpb24gdXNlSG92ZXIoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGV2ZW50cyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9LFxuICAgIHJlZnNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBkZWxheSA9IDAsXG4gICAgaGFuZGxlQ2xvc2UgPSBudWxsLFxuICAgIG1vdXNlT25seSA9IGZhbHNlLFxuICAgIHJlc3RNcyA9IDAsXG4gICAgbW92ZSA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaGFuZGxlQ2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYoaGFuZGxlQ2xvc2UpO1xuICBjb25zdCBkZWxheVJlZiA9IHVzZUxhdGVzdFJlZihkZWxheSk7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgaGFuZGxlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCByZXN0VGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBibG9ja01vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdW5iaW5kTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHt9KTtcbiAgY29uc3QgaXNIb3Zlck9wZW4gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkb3BlbjtcbiAgICBjb25zdCB0eXBlID0gKF9kYXRhUmVmJGN1cnJlbnQkb3BlbiA9IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JG9wZW4udHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuaW5jbHVkZXMoJ21vdXNlJykpICYmIHR5cGUgIT09ICdtb3VzZWRvd24nO1xuICB9LCBbZGF0YVJlZl0pO1xuXG4gIC8vIFdoZW4gZGlzbWlzc2luZyBiZWZvcmUgb3BlbmluZywgY2xlYXIgdGhlIGRlbGF5IHRpbWVvdXRzIHRvIGNhbmNlbCBpdFxuICAvLyBmcm9tIHNob3dpbmcuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRGlzbWlzcygpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIGV2ZW50cy5vbignZGlzbWlzcycsIG9uRGlzbWlzcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ2Rpc21pc3MnLCBvbkRpc21pc3MpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBldmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIWhhbmRsZUNsb3NlUmVmLmN1cnJlbnQgfHwgIW9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25MZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudChmbG9hdGluZykuZG9jdW1lbnRFbGVtZW50O1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBodG1sLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICB9O1xuICB9LCBbZmxvYXRpbmcsIG9wZW4sIG9uT3BlbkNoYW5nZSwgZW5hYmxlZCwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGNvbnN0IGNsb3NlV2l0aERlbGF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBydW5FbHNlQnJhbmNoKSB7XG4gICAgaWYgKHJ1bkVsc2VCcmFuY2ggPT09IHZvaWQgMCkge1xuICAgICAgcnVuRWxzZUJyYW5jaCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCksIGNsb3NlRGVsYXkpO1xuICAgIH0gZWxzZSBpZiAocnVuRWxzZUJyYW5jaCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50KTtcbiAgICB9XG4gIH0sIFtkZWxheVJlZiwgb25PcGVuQ2hhbmdlXSk7XG4gIGNvbnN0IGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNsZWFyUG9pbnRlckV2ZW50cyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChyZWZzLmZsb2F0aW5nLmN1cnJlbnQpLmJvZHk7XG4gICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGJvZHkucmVtb3ZlQXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllcik7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW3JlZnNdKTtcblxuICAvLyBSZWdpc3RlcmluZyB0aGUgbW91c2UgZXZlbnRzIG9uIHRoZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gYnlwYXNzIFJlYWN0J3NcbiAgLy8gZGVsZWdhdGlvbiBzeXN0ZW0uIElmIHRoZSBjdXJzb3Igd2FzIG9uIGEgZGlzYWJsZWQgZWxlbWVudCBhbmQgdGhlbiBlbnRlcmVkXG4gIC8vIHRoZSByZWZlcmVuY2UgKG5vIGdhcCksIGBtb3VzZWVudGVyYCBkb2Vzbid0IGZpcmUgaW4gdGhlIGRlbGVnYXRpb24gc3lzdGVtLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NsaWNrTGlrZU9wZW5FdmVudCgpIHtcbiAgICAgIHJldHVybiBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUpIDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHx8IHJlc3RNcyA+IDAgJiYgZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQpO1xuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBjbGVhcmluZyBgb25TY3JvbGxNb3VzZUxlYXZlYCB0aW1lb3V0LlxuICAgICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgICAvLyBTaG91bGQgdGhlIGV2ZW50IGV4cG9zZSB0aGF0IGl0IHdhcyBjbG9zZWQgYnkgYHNhZmVQb2x5Z29uYD9cbiAgICAgICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlclJlZi5jdXJyZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBpbnRlcmFjdGl2aXR5IHdpdGhvdXQgYHNhZmVQb2x5Z29uYCBvbiB0b3VjaCBkZXZpY2VzLiBXaXRoIGFcbiAgICAgIC8vIHBvaW50ZXIsIGEgc2hvcnQgY2xvc2UgZGVsYXkgaXMgYW4gYWx0ZXJuYXRpdmUsIHNvIGl0IHNob3VsZCB3b3JrXG4gICAgICAvLyBjb25zaXN0ZW50bHkuXG4gICAgICBjb25zdCBzaG91bGRDbG9zZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcgPyAhY29udGFpbnMoZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNsb3NlcyBhZnRlciBzY3JvbGxpbmcgZXZlbiBpZiB0aGUgcG9pbnRlclxuICAgIC8vIGRpZCBub3QgbW92ZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvZGlzY3Vzc2lvbnMvMTY5MlxuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICBvcGVuICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIGZsb2F0aW5nID09IG51bGwgPyB2b2lkIDAgOiBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIG1vdmUgJiYgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG9wZW4gJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgICBmbG9hdGluZyA9PSBudWxsID8gdm9pZCAwIDogZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIG1vdmUgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIHJlc3RNcywgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3BlbiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmXSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX2hhbmRsZUNsb3NlUmVmJGN1cnJlO1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuX19vcHRpb25zLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmJvZHk7XG4gICAgICBib2R5LnNldEF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIsICcnKTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZykge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuLCBfdHJlZSRub2Rlc1JlZiRjdXJyZW4yO1xuICAgICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsb2F0aW5nID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsID8gdm9pZCAwIDogKF90cmVlJG5vZGVzUmVmJGN1cnJlbjIgPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbjIuZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgIGlmIChwYXJlbnRGbG9hdGluZykge1xuICAgICAgICAgIHBhcmVudEZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBwYXJlbnRJZCwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfVxuICB9LCBbb3BlbiwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJSZWYoZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclJlZixcbiAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgICBpZiAob3BlbiB8fCByZXN0TXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RNcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgICAgIGV2ZW50cy5lbWl0KCdkaXNtaXNzJywge1xuICAgICAgICAgICAgdHlwZTogJ21vdXNlTGVhdmUnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICByZXR1cm5Gb2N1czogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudC5uYXRpdmVFdmVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZCwgcmVzdE1zLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGNsb3NlV2l0aERlbGF5XSk7XG59XG5cbmNvbnN0IEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGRlbGF5OiAwLFxuICBpbml0aWFsRGVsYXk6IDAsXG4gIHRpbWVvdXRNczogMCxcbiAgY3VycmVudElkOiBudWxsLFxuICBzZXRDdXJyZW50SWQ6ICgpID0+IHt9LFxuICBzZXRTdGF0ZTogKCkgPT4ge30sXG4gIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxufSk7XG5jb25zdCB1c2VEZWxheUdyb3VwQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgZ3JvdXAgb2YgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBzaG91bGQgc2hhcmUgYVxuICogYGRlbGF5YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0RlbGF5R3JvdXBcbiAqL1xuY29uc3QgRmxvYXRpbmdEZWxheUdyb3VwID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gX3JlZjtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VSZWR1Y2VyKChwcmV2LCBuZXh0KSA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ubmV4dFxuICB9KSwge1xuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyxcbiAgICBpbml0aWFsRGVsYXk6IGRlbGF5LFxuICAgIGN1cnJlbnRJZDogbnVsbCxcbiAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxDdXJyZW50SWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldEN1cnJlbnRJZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGN1cnJlbnRJZCA9PiB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgY3VycmVudElkXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50SWQpIHtcbiAgICAgIGlmIChpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gc3RhdGUuY3VycmVudElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3N0YXRlLmN1cnJlbnRJZF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgc2V0Q3VycmVudElkXG4gICAgfSksIFtzdGF0ZSwgc2V0U3RhdGUsIHNldEN1cnJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCB1c2VEZWxheUdyb3VwID0gKF9yZWYyLCBfcmVmMykgPT4ge1xuICBsZXQge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlXG4gIH0gPSBfcmVmMjtcbiAgbGV0IHtcbiAgICBpZFxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWQsXG4gICAgc2V0Q3VycmVudElkLFxuICAgIGluaXRpYWxEZWxheSxcbiAgICBzZXRTdGF0ZSxcbiAgICB0aW1lb3V0TXNcbiAgfSA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoY3VycmVudElkKSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGRlbGF5OiB7XG4gICAgICAgICAgb3BlbjogMSxcbiAgICAgICAgICBjbG9zZTogZ2V0RGVsYXkoaW5pdGlhbERlbGF5LCAnY2xvc2UnKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChjdXJyZW50SWQgIT09IGlkKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbaWQsIG9uT3BlbkNoYW5nZSwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaW5pdGlhbERlbGF5XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBmdW5jdGlvbiB1bnNldCgpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGRlbGF5OiBpbml0aWFsRGVsYXksXG4gICAgICAgIGN1cnJlbnRJZDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3BlbiAmJiBjdXJyZW50SWQgPT09IGlkKSB7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh1bnNldCwgdGltZW91dE1zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW29wZW4sIHNldFN0YXRlLCBjdXJyZW50SWQsIGlkLCBvbk9wZW5DaGFuZ2UsIGluaXRpYWxEZWxheSwgdGltZW91dE1zXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0Q3VycmVudElkKGlkKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZXRDdXJyZW50SWQsIGlkXSk7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHJlYWwgYWN0aXZlIGVsZW1lbnQuIFRyYXZlcnNlcyBpbnRvIHNoYWRvd1Jvb3RzLlxuICovXG5mdW5jdGlvbiBhY3RpdmVFbGVtZW50KGRvYykge1xuICBsZXQgYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICB3aGlsZSAoKChfYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiAoX2FjdGl2ZUVsZW1lbnQkc2hhZG93ID0gX2FjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmVFbGVtZW50JHNoYWRvdy5hY3RpdmVFbGVtZW50KSAhPSBudWxsKSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50LCBfYWN0aXZlRWxlbWVudCRzaGFkb3c7XG4gICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuXG5sZXQgcmFmSWQgPSAwO1xuZnVuY3Rpb24gZW5xdWV1ZUZvY3VzKGVsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHByZXZlbnRTY3JvbGwgPSBmYWxzZSxcbiAgICBjYW5jZWxQcmV2aW91cyA9IHRydWUsXG4gICAgc3luYyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjYW5jZWxQcmV2aW91cyAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gIGNvbnN0IGV4ZWMgPSAoKSA9PiBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuZm9jdXMoe1xuICAgIHByZXZlbnRTY3JvbGxcbiAgfSk7XG4gIGlmIChzeW5jKSB7XG4gICAgZXhlYygpO1xuICB9IGVsc2Uge1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGV4ZWMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuY2VzdG9ycyhub2RlcywgaWQpIHtcbiAgdmFyIF9ub2RlcyRmaW5kO1xuICBsZXQgYWxsQW5jZXN0b3JzID0gW107XG4gIGxldCBjdXJyZW50UGFyZW50SWQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQucGFyZW50SWQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50SWQpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBjdXJyZW50UGFyZW50SWQpO1xuICAgIGN1cnJlbnRQYXJlbnRJZCA9IGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5wYXJlbnRJZDtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGFsbEFuY2VzdG9ycyA9IGFsbEFuY2VzdG9ycy5jb25jYXQoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsQW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlcywgaWQpIHtcbiAgbGV0IGFsbENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBpZCAmJiAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pO1xuICB9KTtcbiAgbGV0IGN1cnJlbnRDaGlsZHJlbiA9IGFsbENoaWxkcmVuO1xuICB3aGlsZSAoY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIGN1cnJlbnRDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIHZhciBfY3VycmVudENoaWxkcmVuO1xuICAgICAgcmV0dXJuIChfY3VycmVudENoaWxkcmVuID0gY3VycmVudENoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRDaGlsZHJlbi5zb21lKG4gPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDI7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBuLmlkICYmICgoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5vcGVuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFsbENoaWxkcmVuID0gYWxsQ2hpbGRyZW4uY29uY2F0KGN1cnJlbnRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGFsbENoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0XG4gIC8vIGBjb21wb3NlZFBhdGgoKWAsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBET00gZG9uJ3QuXG4gIHJldHVybiBldmVudC50YXJnZXQ7XG59XG5cbmNvbnN0IFRZUEVBQkxFX1NFTEVDVE9SID0gXCJpbnB1dDpub3QoW3R5cGU9J2hpZGRlbiddKTpub3QoW2Rpc2FibGVkXSksXCIgKyBcIltjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSdmYWxzZSddKSx0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSlcIjtcbmZ1bmN0aW9uIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5tYXRjaGVzKFRZUEVBQkxFX1NFTEVDVE9SKTtcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5jb25zdCBnZXRUYWJiYWJsZU9wdGlvbnMgPSAoKSA9PiAoe1xuICBnZXRTaGFkb3dSb290OiB0cnVlLFxuICBkaXNwbGF5Q2hlY2s6XG4gIC8vIEpTRE9NIGRvZXMgbm90IHN1cHBvcnQgdGhlIGB0YWJiYWJsZWAgbGlicmFyeS4gVG8gc29sdmUgdGhpcyB3ZSBjYW5cbiAgLy8gY2hlY2sgaWYgYFJlc2l6ZU9ic2VydmVyYCBpcyBhIHJlYWwgZnVuY3Rpb24gKG5vdCBwb2x5ZmlsbGVkKSwgd2hpY2hcbiAgLy8gZGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBKU0RPTS1saWtlLlxuICB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgUmVzaXplT2JzZXJ2ZXIudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpID8gJ2Z1bGwnIDogJ25vbmUnXG59KTtcbmZ1bmN0aW9uIGdldFRhYmJhYmxlSW4oY29udGFpbmVyLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgYWxsVGFiYmFibGUgPSB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgYWxsVGFiYmFibGUucmV2ZXJzZSgpO1xuICB9XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gYWxsVGFiYmFibGUuaW5kZXhPZihhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGNvbnRhaW5lcikpKTtcbiAgY29uc3QgbmV4dFRhYmJhYmxlRWxlbWVudHMgPSBhbGxUYWJiYWJsZS5zbGljZShhY3RpdmVJbmRleCArIDEpO1xuICByZXR1cm4gbmV4dFRhYmJhYmxlRWxlbWVudHNbMF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUoKSB7XG4gIHJldHVybiBnZXRUYWJiYWJsZUluKGRvY3VtZW50LmJvZHksICduZXh0Jyk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1RhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAncHJldicpO1xufVxuZnVuY3Rpb24gaXNPdXRzaWRlRXZlbnQoZXZlbnQsIGNvbnRhaW5lcikge1xuICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICByZXR1cm4gIXJlbGF0ZWRUYXJnZXQgfHwgIWNvbnRhaW5zKGNvbnRhaW5lckVsZW1lbnQsIHJlbGF0ZWRUYXJnZXQpO1xufVxuZnVuY3Rpb24gZGlzYWJsZUZvY3VzSW5zaWRlKGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZUVsZW1lbnRzID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnJztcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFiaW5kZXhdJyk7XG4gIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgdGFiaW5kZXggPSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gU2VlIERpZWdvIEhheidzIFNhbmRib3ggZm9yIG1ha2luZyB0aGlzIGxvZ2ljIHdvcmsgd2VsbCBvbiBTYWZhcmkvaU9TOlxuLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvRm9jdXNUcmFwLnRzeFxuXG5jb25zdCBISURERU5fU1RZTEVTID0ge1xuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCcsXG4gIHRvcDogMCxcbiAgbGVmdDogMFxufTtcbmxldCB0aW1lb3V0SWQ7XG5mdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50T25UYWIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICBldmVudC50YXJnZXQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH1cbn1cbmNvbnN0IEZvY3VzR3VhcmQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb2N1c0d1YXJkKHByb3BzLCByZWYpIHtcbiAgY29uc3QgW3JvbGUsIHNldFJvbGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICAvLyBVbmxpa2Ugb3RoZXIgc2NyZWVuIHJlYWRlcnMgc3VjaCBhcyBOVkRBIGFuZCBKQVdTLCB0aGUgdmlydHVhbCBjdXJzb3JcbiAgICAgIC8vIG9uIFZvaWNlT3ZlciBkb2VzIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQsIHNvIHdlIGNhbiB1c2UgdGhlIGZvY3VzXG4gICAgICAvLyB0cmFwIGVsZW1lbnQuIE9uIFNhZmFyaSwgb25seSBidXR0b25zIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQuXG4gICAgICAvLyBOQjogXCJncm91cFwiIHJvbGUgaW4gdGhlIFNhbmRib3ggbm8gbG9uZ2VyIGFwcGVhcnMgdG8gd29yaywgbXVzdCBiZSBhXG4gICAgICAvLyBidXR0b24gcm9sZS5cbiAgICAgIHNldFJvbGUoJ2J1dHRvbicpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2V0QWN0aXZlRWxlbWVudE9uVGFiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCByZXN0UHJvcHMgPSB7XG4gICAgcmVmLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIC8vIFJvbGUgaXMgb25seSBmb3IgVm9pY2VPdmVyXG4gICAgcm9sZSxcbiAgICAnYXJpYS1oaWRkZW4nOiByb2xlID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICBbY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpXTogJycsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHJlc3RQcm9wcykpO1xufSk7XG5cbmNvbnN0IFBvcnRhbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nUG9ydGFsTm9kZShfdGVtcCkge1xuICBsZXQge1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBkYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGlkLFxuICAgIHJvb3QsXG4gICAgcG9ydGFsQ29udGV4dCxcbiAgICB1bmlxdWVJZFxuICB9KSwgW2lkLCByb290LCBwb3J0YWxDb250ZXh0LCB1bmlxdWVJZF0pO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZSA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsTm9kZS5yZW1vdmUoKTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZSwgZGF0YV0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRhdGFSZWYuY3VycmVudCA9PT0gZGF0YSkgcmV0dXJuO1xuICAgIGRhdGFSZWYuY3VycmVudCA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICByb290LFxuICAgICAgcG9ydGFsQ29udGV4dCxcbiAgICAgIHVuaXF1ZUlkXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgZXhpc3RpbmdJZFJvb3QgPSBpZCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IG51bGw7XG4gICAgY29uc3QgYXR0ciA9IGNyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJyk7XG4gICAgaWYgKGV4aXN0aW5nSWRSb290KSB7XG4gICAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdWJSb290LmlkID0gdW5pcXVlSWQ7XG4gICAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgICBleGlzdGluZ0lkUm9vdC5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb250YWluZXIgPSByb290IHx8IChwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpO1xuICAgICAgaWYgKGNvbnRhaW5lciAmJiAhaXNFbGVtZW50KGNvbnRhaW5lcikpIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICBsZXQgaWRXcmFwcGVyID0gbnVsbDtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBpZFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaWRXcmFwcGVyLmlkID0gaWQ7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpZFdyYXBwZXIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgICAgc3ViUm9vdC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuICAgICAgY29udGFpbmVyID0gaWRXcmFwcGVyIHx8IGNvbnRhaW5lcjtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gICAgfVxuICB9LCBbZGF0YV0pO1xuICByZXR1cm4gcG9ydGFsTm9kZTtcbn1cbi8qKlxuICogUG9ydGFscyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbnRvIGEgZ2l2ZW4gY29udGFpbmVyIGVsZW1lbnQg4oCUIGJ5IGRlZmF1bHQsXG4gKiBvdXRzaWRlIG9mIHRoZSBhcHAgcm9vdCBhbmQgaW50byB0aGUgYm9keS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbFxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1BvcnRhbChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgcm9vdCA9IG51bGwsXG4gICAgcHJlc2VydmVUYWJPcmRlciA9IHRydWVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHBvcnRhbE5vZGUgPSB1c2VGbG9hdGluZ1BvcnRhbE5vZGUoe1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSk7XG4gIGNvbnN0IFtmb2N1c01hbmFnZXJTdGF0ZSwgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGJlZm9yZU91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVyT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYmVmb3JlSW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlckluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID1cbiAgLy8gVGhlIEZvY3VzTWFuYWdlciBhbmQgdGhlcmVmb3JlIGZsb2F0aW5nIGVsZW1lbnQgYXJlIGN1cnJlbnRseSBvcGVuL1xuICAvLyByZW5kZXJlZC5cbiAgISFmb2N1c01hbmFnZXJTdGF0ZSAmJlxuICAvLyBHdWFyZHMgYXJlIG9ubHkgZm9yIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50LlxuICAhZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwgJiZcbiAgLy8gRG9uJ3QgcmVuZGVyIGlmIHVubW91bnQgaXMgdHJhbnNpdGlvbmluZy5cbiAgZm9jdXNNYW5hZ2VyU3RhdGUub3BlbiAmJiBwcmVzZXJ2ZVRhYk9yZGVyICYmICEhKHJvb3QgfHwgcG9ydGFsTm9kZSk7XG5cbiAgLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvVGFiYmFibGVQb3J0YWwudHN4XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwb3J0YWxOb2RlIHx8ICFwcmVzZXJ2ZVRhYk9yZGVyIHx8IGZvY3VzTWFuYWdlclN0YXRlICE9IG51bGwgJiYgZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudHMgaW5zaWRlIHRoZSBwb3J0YWwgZWxlbWVudCBhcmUgdGFiYmFibGUgb25seSB3aGVuIHRoZVxuICAgIC8vIHBvcnRhbCBoYXMgYWxyZWFkeSBiZWVuIGZvY3VzZWQsIGVpdGhlciBieSB0YWJiaW5nIGludG8gYSBmb2N1cyB0cmFwXG4gICAgLy8gZWxlbWVudCBvdXRzaWRlIG9yIHVzaW5nIHRoZSBtb3VzZS5cbiAgICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAocG9ydGFsTm9kZSAmJiBpc091dHNpZGVFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNpbmcgPSBldmVudC50eXBlID09PSAnZm9jdXNpbic7XG4gICAgICAgIGNvbnN0IG1hbmFnZUZvY3VzID0gZm9jdXNpbmcgPyBlbmFibGVGb2N1c0luc2lkZSA6IGRpc2FibGVGb2N1c0luc2lkZTtcbiAgICAgICAgbWFuYWdlRm9jdXMocG9ydGFsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpc3RlbiB0byB0aGUgZXZlbnQgb24gdGhlIGNhcHR1cmUgcGhhc2Ugc28gdGhleSBydW4gYmVmb3JlIHRoZSBmb2N1c1xuICAgIC8vIHRyYXAgZWxlbWVudHMgb25Gb2N1cyBwcm9wIGlzIGNhbGxlZC5cbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBwcmVzZXJ2ZVRhYk9yZGVyLCBmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcHJlc2VydmVUYWJPcmRlcixcbiAgICAgIGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBhZnRlck91dHNpZGVSZWYsXG4gICAgICBiZWZvcmVJbnNpZGVSZWYsXG4gICAgICBhZnRlckluc2lkZVJlZixcbiAgICAgIHBvcnRhbE5vZGUsXG4gICAgICBzZXRGb2N1c01hbmFnZXJTdGF0ZVxuICAgIH0pLCBbcHJlc2VydmVUYWJPcmRlciwgcG9ydGFsTm9kZV0pXG4gIH0sIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICByZWY6IGJlZm9yZU91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2JlZm9yZUluc2lkZVJlZiRjdXJyO1xuICAgICAgICAoX2JlZm9yZUluc2lkZVJlZiRjdXJyID0gYmVmb3JlSW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYmVmb3JlSW5zaWRlUmVmJGN1cnIuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoKSB8fCAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLnJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJhcmlhLW93bnNcIjogcG9ydGFsTm9kZS5pZCxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSwgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxOb2RlKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgIHJlZjogYWZ0ZXJPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9hZnRlckluc2lkZVJlZiRjdXJyZTtcbiAgICAgICAgKF9hZnRlckluc2lkZVJlZiRjdXJyZSA9IGFmdGVySW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYWZ0ZXJJbnNpZGVSZWYkY3VycmUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsID8gdm9pZCAwIDogbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUuY2xvc2VPbkZvY3VzT3V0KSAmJiAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cbmNvbnN0IHVzZVBvcnRhbENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KFBvcnRhbENvbnRleHQpO1xuXG5jb25zdCBWaXN1YWxseUhpZGRlbkRpc21pc3MgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBWaXN1YWxseUhpZGRlbkRpc21pc3MocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICByZWY6IHJlZixcbiAgICB0YWJJbmRleDogLTEsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfSkpO1xufSk7XG4vKipcbiAqIFByb3ZpZGVzIGZvY3VzIG1hbmFnZW1lbnQgZm9yIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRm9jdXNNYW5hZ2VyXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRm9jdXNNYW5hZ2VyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgb3JkZXIgPSBbJ2NvbnRlbnQnXSxcbiAgICBndWFyZHM6IF9ndWFyZHMgPSB0cnVlLFxuICAgIGluaXRpYWxGb2N1cyA9IDAsXG4gICAgcmV0dXJuRm9jdXMgPSB0cnVlLFxuICAgIG1vZGFsID0gdHJ1ZSxcbiAgICB2aXN1YWxseUhpZGRlbkRpc21pc3MgPSBmYWxzZSxcbiAgICBjbG9zZU9uRm9jdXNPdXQgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgcmVmcyxcbiAgICBub2RlSWQsXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG5cbiAgLy8gRm9yY2UgdGhlIGd1YXJkcyB0byBiZSByZW5kZXJlZCBpZiB0aGUgYGluZXJ0YCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgY29uc3QgZ3VhcmRzID0gc3VwcG9ydHNJbmVydCgpID8gX2d1YXJkcyA6IHRydWU7XG4gIGNvbnN0IG9yZGVyUmVmID0gdXNlTGF0ZXN0UmVmKG9yZGVyKTtcbiAgY29uc3QgaW5pdGlhbEZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKGluaXRpYWxGb2N1cyk7XG4gIGNvbnN0IHJldHVybkZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKHJldHVybkZvY3VzKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuXG4gIC8vIENvbnRyb2xsZWQgYnkgYHVzZUxpc3ROYXZpZ2F0aW9uYC5cbiAgY29uc3QgaWdub3JlSW5pdGlhbEZvY3VzID0gdHlwZW9mIGluaXRpYWxGb2N1cyA9PT0gJ251bWJlcicgJiYgaW5pdGlhbEZvY3VzIDwgMDtcbiAgY29uc3Qgc3RhcnREaXNtaXNzQnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBlbmREaXNtaXNzQnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBwcmV2ZW50UmV0dXJuRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlzUG9pbnRlckRvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc0luc2lkZVBvcnRhbCA9IHBvcnRhbENvbnRleHQgIT0gbnVsbDtcblxuICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGEgY29tYm9ib3ggYW5kIGlzIHR5cGVhYmxlIChlLmcuIGlucHV0L3RleHRhcmVhKSxcbiAgLy8gdGhlcmUgYXJlIGRpZmZlcmVudCBmb2N1cyBzZW1hbnRpY3MuIFRoZSBndWFyZHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCwgYnV0XG4gIC8vIGFyaWEtaGlkZGVuIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyBzdGlsbC4gRnVydGhlciwgdGhlIHZpc3VhbGx5XG4gIC8vIGhpZGRlbiBkaXNtaXNzIGJ1dHRvbiBzaG91bGQgb25seSBhcHBlYXIgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgbm90IHRoZVxuICAvLyBzdGFydC5cbiAgY29uc3QgaXNUeXBlYWJsZUNvbWJvYm94ID0gZG9tUmVmZXJlbmNlICYmIGRvbVJlZmVyZW5jZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ2NvbWJvYm94JyAmJiBpc1R5cGVhYmxlRWxlbWVudChkb21SZWZlcmVuY2UpO1xuICBjb25zdCBnZXRUYWJiYWJsZUNvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250YWluZXIgPSBmbG9hdGluZztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpIDogW107XG4gIH0sIFtmbG9hdGluZ10pO1xuICBjb25zdCBnZXRUYWJiYWJsZUVsZW1lbnRzID0gUmVhY3QudXNlQ2FsbGJhY2soY29udGFpbmVyID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIG9yZGVyUmVmLmN1cnJlbnQubWFwKHR5cGUgPT4ge1xuICAgICAgaWYgKGRvbVJlZmVyZW5jZSAmJiB0eXBlID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICByZXR1cm4gZG9tUmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGUgPT09ICdmbG9hdGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZsb2F0aW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pLmZsYXQoKTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIW1vZGFsKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGZsb2F0aW5nKSkpICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCAmJiAhaXNUeXBlYWJsZUNvbWJvYm94KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIHJlZnMsIGlzVHlwZWFibGVDb21ib2JveCwgZ2V0VGFiYmFibGVDb250ZW50LCBnZXRUYWJiYWJsZUVsZW1lbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFjbG9zZU9uRm9jdXNPdXQpIHJldHVybjtcblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZWRUb1VucmVsYXRlZE5vZGUgPSAhKGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQsIGZsb2F0aW5nKSB8fCBjb250YWlucyhwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUsIHJlbGF0ZWRUYXJnZXQpIHx8IHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpIHx8IHRyZWUgJiYgKGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0LCBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucygoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KSB8fCBnZXRBbmNlc3RvcnModHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQzLCBfbm9kZSRjb250ZXh0NDtcbiAgICAgICAgICByZXR1cm4gKChfbm9kZSRjb250ZXh0MyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQzLmVsZW1lbnRzLmZsb2F0aW5nKSA9PT0gcmVsYXRlZFRhcmdldCB8fCAoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBGb2N1cyBkaWQgbm90IG1vdmUgaW5zaWRlIHRoZSBmbG9hdGluZyB0cmVlLCBhbmQgdGhlcmUgYXJlIG5vIHRhYmJhYmxlXG4gICAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmIG1vdmVkVG9VbnJlbGF0ZWROb2RlICYmICFpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgLy8gRml4IFJlYWN0IDE4IFN0cmljdCBNb2RlIHJldHVybkZvY3VzIGR1ZSB0byBkb3VibGUgcmVuZGVyaW5nLlxuICAgICAgICByZWxhdGVkVGFyZ2V0ICE9PSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZyAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAhbW9kYWwgJiYgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICAhbW9kYWwgJiYgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG5vZGVJZCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gRG9uJ3QgaGlkZSBwb3J0YWxzIG5lc3RlZCB3aXRoaW4gdGhlIHBhcmVudCBwb3J0YWwuXG4gICAgY29uc3QgcG9ydGFsTm9kZXMgPSBBcnJheS5mcm9tKChwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiAoX3BvcnRhbENvbnRleHQkcG9ydGFsID0gcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX3BvcnRhbENvbnRleHQkcG9ydGFsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIgKyBjcmVhdGVBdHRyaWJ1dGUoJ3BvcnRhbCcpICsgXCJdXCIpKSB8fCBbXSk7XG4gICAgaWYgKGZsb2F0aW5nICYmIG1vZGFsKSB7XG4gICAgICBjb25zdCBpbnNpZGVOb2RlcyA9IFtmbG9hdGluZywgLi4ucG9ydGFsTm9kZXMsIHN0YXJ0RGlzbWlzc0J1dHRvblJlZi5jdXJyZW50LCBlbmREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnRdLmZpbHRlcih4ID0+IHggIT0gbnVsbCk7XG4gICAgICBjb25zdCBzdXBwcmVzc29yRm4gPSBndWFyZHMgPyBoaWRlT3RoZXJzIDogc3VwcHJlc3NPdGhlcnM7XG4gICAgICBjb25zdCBjbGVhbnVwID0gc3VwcHJlc3NvckZuKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ3JlZmVyZW5jZScpIHx8IGlzVHlwZWFibGVDb21ib2JveCA/IGluc2lkZU5vZGVzLmNvbmNhdChkb21SZWZlcmVuY2UgfHwgW10pIDogaW5zaWRlTm9kZXMsIHVuZGVmaW5lZCwgY3JlYXRlQXR0cmlidXRlKCdpbmVydCcpKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcG9ydGFsQ29udGV4dCwgaXNUeXBlYWJsZUNvbWJvYm94LCBndWFyZHNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZyk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZztcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyhmbG9hdGluZywgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaWdub3JlSW5pdGlhbEZvY3VzICYmICFmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsICYmIG9wZW4pIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsVG9Gb2N1cywge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGVsVG9Gb2N1cyA9PT0gZmxvYXRpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgb3BlbiwgZmxvYXRpbmcsIGlnbm9yZUluaXRpYWxGb2N1cywgZ2V0VGFiYmFibGVFbGVtZW50cywgaW5pdGlhbEZvY3VzUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nKSByZXR1cm47XG4gICAgbGV0IHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSBkYXRhUmVmLmN1cnJlbnQ7XG4gICAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQ7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbkRpc21pc3MocGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ2VzY2FwZUtleScgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoWydyZWZlcmVuY2VQcmVzcycsICdlc2NhcGVLZXknXS5pbmNsdWRlcyhwYXlsb2FkLnR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHVybkZvY3VzID0gcGF5bG9hZC5kYXRhLnJldHVybkZvY3VzO1xuICAgICAgaWYgKHR5cGVvZiByZXR1cm5Gb2N1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzU2Nyb2xsID0gcmV0dXJuRm9jdXMucHJldmVudFNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gIXJldHVybkZvY3VzO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ2Rpc21pc3MnLCBvbkRpc21pc3MpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdkaXNtaXNzJywgb25EaXNtaXNzKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgY29uc3Qgc2hvdWxkRm9jdXNSZWZlcmVuY2UgPSBjb250YWlucyhmbG9hdGluZywgYWN0aXZlRWwpIHx8IHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUobm9kZSA9PiB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZXh0NTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0NSA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ1LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCk7XG4gICAgICB9KSB8fCBjb250ZXh0RGF0YS5vcGVuRXZlbnQgJiYgWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhjb250ZXh0RGF0YS5vcGVuRXZlbnQudHlwZSk7XG4gICAgICBpZiAoc2hvdWxkRm9jdXNSZWZlcmVuY2UgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICByZXR1cm5Gb2N1c1JlZi5jdXJyZW50ICYmIGlzSFRNTEVsZW1lbnQocHJldmlvdXNseUZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQpICYmICFwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCkge1xuICAgICAgICBlbnF1ZXVlRm9jdXMocHJldmlvdXNseUZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAvLyBXaGVuIGRpc21pc3NpbmcgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBieSB0aGUgdGltZSB0aGUgckFGIGhhc1xuICAgICAgICAgIC8vIGV4ZWN1dGVkLCB0aGUgbWVudXMgd2lsbCBhbGwgaGF2ZSBiZWVuIHVubW91bnRlZC4gV2hlbiB0aGV5IHRyeVxuICAgICAgICAgIC8vIHRvIGdldCBmb2N1c2VkLCB0aGUgY2FsbHMgZ2V0IGlnbm9yZWQg4oCUIGxlYXZpbmcgdGhlIHJvb3RcbiAgICAgICAgICAvLyByZWZlcmVuY2UgZm9jdXNlZCBhcyBkZXNpcmVkLlxuICAgICAgICAgIGNhbmNlbFByZXZpb3VzOiBmYWxzZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIHJlZnMsIGV2ZW50cywgdHJlZSwgbm9kZUlkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIG1vZGFsLFxuICAgICAgY2xvc2VPbkZvY3VzT3V0LFxuICAgICAgb3BlblxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIGNsb3NlT25Gb2N1c091dCwgY29udGV4dF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBoYW5kbGVNdXRhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSBmbG9hdGluZy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdmbG9hdGluZycpIHx8IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKSAhPT0gcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCAmJiBnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodGFiSW5kZXggIT09ICcwJykge1xuICAgICAgICAgICAgZmxvYXRpbmcuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhYkluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgICAgZmxvYXRpbmcuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaGFuZGxlTXV0YXRpb24oKTtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb24pO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZywge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJlZnMsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnRdKTtcbiAgZnVuY3Rpb24gcmVuZGVyRGlzbWlzc0J1dHRvbihsb2NhdGlvbikge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhdmlzdWFsbHlIaWRkZW5EaXNtaXNzIHx8ICFtb2RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaXN1YWxseUhpZGRlbkRpc21pc3MsIHtcbiAgICAgIHJlZjogbG9jYXRpb24gPT09ICdzdGFydCcgPyBzdGFydERpc21pc3NCdXR0b25SZWYgOiBlbmREaXNtaXNzQnV0dG9uUmVmLFxuICAgICAgb25DbGljazogZXZlbnQgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudClcbiAgICB9LCB0eXBlb2YgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID09PSAnc3RyaW5nJyA/IHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA6ICdEaXNtaXNzJyk7XG4gIH1cbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID0gIWRpc2FibGVkICYmIGd1YXJkcyAmJiAhaXNUeXBlYWJsZUNvbWJvYm94ICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKG9yZGVyWzBdID09PSAncmVmZXJlbmNlJyA/IGVsc1swXSA6IGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgPyB2b2lkIDAgOiBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYmVmb3JlO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRiZWZvcmUgPSBwb3J0YWxDb250ZXh0LmJlZm9yZU91dHNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JGJlZm9yZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgIWlzVHlwZWFibGVDb21ib2JveCAmJiByZW5kZXJEaXNtaXNzQnV0dG9uKCdzdGFydCcpLCBjaGlsZHJlbiwgcmVuZGVyRGlzbWlzc0J1dHRvbignZW5kJyksIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYWZ0ZXJJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhnZXRUYWJiYWJsZUVsZW1lbnRzKClbMF0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBpZiAoY2xvc2VPbkZvY3VzT3V0KSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BvcnRhbENvbnRleHQkYWZ0ZXJPLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gc29ydEJ5RG9jdW1lbnRQb3NpdGlvbihhLCBiKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtcbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChtYXAxLCBtYXAyKSB7XG4gIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbWFwMi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEZsb2F0aW5nTGlzdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgdW5yZWdpc3RlcjogKCkgPT4ge30sXG4gIG1hcDogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZWxlbWVudHNSZWY6IHtcbiAgICBjdXJyZW50OiBbXVxuICB9XG59KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3RcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdMaXN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCByZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IG5ldyBNYXAocHJldk1hcCkuc2V0KG5vZGUsIG51bGwpKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0TWFwKHByZXZNYXAgPT4ge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcChwcmV2TWFwKTtcbiAgICAgIG1hcC5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgTWFwKG1hcCk7XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5ld01hcC5rZXlzKCkpLnNvcnQoc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIG5ld01hcC5zZXQobm9kZSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGlmICghYXJlTWFwc0VxdWFsKG1hcCwgbmV3TWFwKSkge1xuICAgICAgc2V0TWFwKG5ld01hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJlZ2lzdGVyLFxuICAgICAgdW5yZWdpc3RlcixcbiAgICAgIG1hcCxcbiAgICAgIGVsZW1lbnRzUmVmLFxuICAgICAgbGFiZWxzUmVmXG4gICAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgbWFwLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gdXNlTGlzdEl0ZW0oX3RlbXApIHtcbiAgbGV0IHtcbiAgICBsYWJlbFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtpbmRleCQxLCBzZXRJbmRleF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9uZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgdW5yZWdpc3RlcixcbiAgICBtYXAsXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTGlzdENvbnRleHQpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb21wb25lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgaWYgKGluZGV4JDEgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnRzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBub2RlO1xuICAgICAgaWYgKGxhYmVsc1JlZikge1xuICAgICAgICB2YXIgX25vZGUkdGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxEZWZpbmVkID0gbGFiZWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGFiZWxzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBpc0xhYmVsRGVmaW5lZCA/IGxhYmVsIDogKF9ub2RlJHRleHRDb250ZW50ID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0Q29udGVudCkgIT0gbnVsbCA/IF9ub2RlJHRleHRDb250ZW50IDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpbmRleCQxLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmLCBsYWJlbF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudFJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZWdpc3Rlcihub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXIobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudFJlZi5jdXJyZW50ID8gbWFwLmdldChjb21wb25lbnRSZWYuY3VycmVudCkgOiBudWxsO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBzZXRJbmRleChpbmRleCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmLFxuICAgIGluZGV4OiBpbmRleCQxID09IG51bGwgPyAtMSA6IGluZGV4JDFcbiAgfSksIFtpbmRleCQxLCByZWZdKTtcbn1cblxuY29uc3QgaWRlbnRpZmllciA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdHRyaWJ1dGUoJ3Njcm9sbC1sb2NrJyk7XG5cbi8qKlxuICogUHJvdmlkZXMgYmFzZSBzdHlsaW5nIGZvciBhIGZpeGVkIG92ZXJsYXkgZWxlbWVudCB0byBkaW0gY29udGVudCBvciBibG9ja1xuICogcG9pbnRlciBldmVudHMgYmVoaW5kIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEl0J3MgYSByZWd1bGFyIGA8ZGl2PmAsIHNvIGl0IGNhbiBiZSBzdHlsZWQgdmlhIGFueSBDU1Mgc29sdXRpb24geW91IHByZWZlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ092ZXJsYXlcbiAqL1xuY29uc3QgRmxvYXRpbmdPdmVybGF5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdPdmVybGF5KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGxvY2tTY3JvbGwgPSBmYWxzZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBpbmRleCgoKSA9PiB7XG4gICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICBpZiAoIWxvY2tTY3JvbGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWxyZWFkeUxvY2tlZCA9IGRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKGlkZW50aWZpZXIpO1xuICAgIGlmIChhbHJlYWR5TG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKGlkZW50aWZpZXIsICcnKTtcblxuICAgIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyXG4gICAgY29uc3Qgc2Nyb2xsYmFyWCA9IE1hdGgucm91bmQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgY29uc3QgcGFkZGluZ1Byb3AgPSBzY3JvbGxiYXJYID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cbiAgICAvLyBPbmx5IGlPUyBkb2Vzbid0IHJlc3BlY3QgYG92ZXJmbG93OiBoaWRkZW5gIG9uIGRvY3VtZW50LmJvZHksIGFuZCB0aGlzXG4gICAgLy8gdGVjaG5pcXVlIGhhcyBmZXdlciBzaWRlIGVmZmVjdHMuXG4gICAgaWYgKCEvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KGdldFBsYXRmb3JtKCkpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBbcGFkZGluZ1Byb3BdOiBzY3JvbGxiYXJXaWR0aCArIFwicHhcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShpZGVudGlmaWVyKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkb2N1bWVudC5ib2R5LnN0eWxlLCB7XG4gICAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAgIFtwYWRkaW5nUHJvcF06ICcnXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBpT1MgMTIgZG9lcyBub3Qgc3VwcG9ydCBgdmlzdWFsVmlld3BvcnRgLlxuICAgIGNvbnN0IG9mZnNldExlZnQgPSAoKF93aW5kb3ckdmlzdWFsVmlld3BvciA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3Bvci5vZmZzZXRMZWZ0KSB8fCAwO1xuICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgIGNvbnN0IHNjcm9sbFggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgY29uc3Qgc2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBPYmplY3QuYXNzaWduKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgdG9wOiAtKHNjcm9sbFkgLSBNYXRoLmZsb29yKG9mZnNldFRvcCkpICsgXCJweFwiLFxuICAgICAgbGVmdDogLShzY3JvbGxYIC0gTWF0aC5mbG9vcihvZmZzZXRMZWZ0KSkgKyBcInB4XCIsXG4gICAgICByaWdodDogJzAnLFxuICAgICAgW3BhZGRpbmdQcm9wXTogc2Nyb2xsYmFyV2lkdGggKyBcInB4XCJcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihkb2N1bWVudC5ib2R5LnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICB0b3A6ICcnLFxuICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgcmlnaHQ6ICcnLFxuICAgICAgICBbcGFkZGluZ1Byb3BdOiAnJ1xuICAgICAgfSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShpZGVudGlmaWVyKTtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICB9O1xuICB9LCBbbG9ja1Njcm9sbF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QsIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgLi4ucmVzdC5zdHlsZVxuICAgIH1cbiAgfSkpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nO1xufVxuZnVuY3Rpb24gaXNTcGFjZUlnbm9yZWQoZWxlbWVudCkge1xuICByZXR1cm4gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG4vKipcbiAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGNsaWNraW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGlja1xuICovXG5mdW5jdGlvbiB1c2VDbGljayhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBldmVudDogZXZlbnRPcHRpb24gPSAnY2xpY2snLFxuICAgIHRvZ2dsZSA9IHRydWUsXG4gICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICBrZXlib2FyZEhhbmRsZXJzID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGRpZEtleURvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgYnV0dG9ucyBleGNlcHQgZm9yIHRoZSBcIm1haW5cIiBidXR0b24uXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uXG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlICYmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlID09PSAnbW91c2Vkb3duJyA6IHRydWUpKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzdGVhbGluZyBmb2N1cyBmcm9tIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdtb3VzZWRvd24nICYmIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQsIHRydWUpICYmIGlnbm9yZU1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA6IHRydWUpKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWtleWJvYXJkSGFuZGxlcnMgfHwgaXNCdXR0b25UYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiAhaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB8fCBpc1NwYWNlSWdub3JlZChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiBkaWRLZXlEb3duUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRpZEtleURvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZGF0YVJlZiwgZXZlbnRPcHRpb24sIGlnbm9yZU1vdXNlLCBrZXlib2FyZEhhbmRsZXJzLCBkb21SZWZlcmVuY2UsIHRvZ2dsZSwgb3Blbiwgb25PcGVuQ2hhbmdlXSk7XG59XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSW5zZXJ0aW9uRWZmZWN0IH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RbLyojX19QVVJFX18qLyd1c2VJbnNlcnRpb25FZmZlY3QnLnRvU3RyaW5nKCldO1xuY29uc3QgdXNlU2FmZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdCB8fCAoZm4gPT4gZm4oKSk7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChjYWxsYmFjaykge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgYW4gZXZlbnQgaGFuZGxlciB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgfVxuICB9KTtcbiAgdXNlU2FmZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50KC4uLmFyZ3MpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbVJlZiwgZGF0YSkge1xuICBsZXQgb2Zmc2V0WCA9IG51bGw7XG4gIGxldCBvZmZzZXRZID0gbnVsbDtcbiAgbGV0IGlzQXV0b1VwZGF0ZUV2ZW50ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29udGV4dEVsZW1lbnQ6IGRvbVJlZi5jdXJyZW50IHx8IHVuZGVmaW5lZCxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICB2YXIgX2RvbVJlZiRjdXJyZW50LCBfZGF0YSRkYXRhUmVmJGN1cnJlbnQ7XG4gICAgICBjb25zdCBkb21SZWN0ID0gKChfZG9tUmVmJGN1cnJlbnQgPSBkb21SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb21SZWYkY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgfHwge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgaXNYQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3gnIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3knIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUgPSBbJ21vdXNlZW50ZXInLCAnbW91c2Vtb3ZlJ10uaW5jbHVkZXMoKChfZGF0YSRkYXRhUmVmJGN1cnJlbnQgPSBkYXRhLmRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRkYXRhUmVmJGN1cnJlbnQudHlwZSkgfHwgJycpICYmIGRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCc7XG4gICAgICBsZXQgd2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgbGV0IHggPSBkb21SZWN0Lng7XG4gICAgICBsZXQgeSA9IGRvbVJlY3QueTtcbiAgICAgIGlmIChvZmZzZXRYID09IG51bGwgJiYgZGF0YS54ICYmIGlzWEF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WCA9IGRvbVJlY3QueCAtIGRhdGEueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRZID09IG51bGwgJiYgZGF0YS55ICYmIGlzWUF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WSA9IGRvbVJlY3QueSAtIGRhdGEueTtcbiAgICAgIH1cbiAgICAgIHggLT0gb2Zmc2V0WCB8fCAwO1xuICAgICAgeSAtPSBvZmZzZXRZIHx8IDA7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc0F1dG9VcGRhdGVFdmVudCB8fCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IDA7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiAwO1xuICAgICAgICB4ID0gaXNYQXhpcyAmJiBkYXRhLnggIT0gbnVsbCA/IGRhdGEueCA6IHg7XG4gICAgICAgIHkgPSBpc1lBeGlzICYmIGRhdGEueSAhPSBudWxsID8gZGF0YS55IDogeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdXRvVXBkYXRlRXZlbnQgJiYgIWNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogd2lkdGg7XG4gICAgICB9XG4gICAgICBpc0F1dG9VcGRhdGVFdmVudCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgICAgbGVmdDogeFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc01vdXNlQmFzZWRFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgIT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9IG51bGw7XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCByZWxhdGl2ZSB0byBhIGNsaWVudCBwb2ludCAoaW4gdGhlIHZpZXdwb3J0KSxcbiAqIHN1Y2ggYXMgdGhlIG1vdXNlIHBvc2l0aW9uLiBCeSBkZWZhdWx0LCBpdCBmb2xsb3dzIHRoZSBtb3VzZSBjdXJzb3IuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpZW50UG9pbnRcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpZW50UG9pbnQoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIHJlZnMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgYXhpcyA9ICdib3RoJyxcbiAgICB4ID0gbnVsbCxcbiAgICB5ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjbGVhbnVwTGlzdGVuZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtwb2ludGVyVHlwZSwgc2V0UG9pbnRlclR5cGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgW3JlYWN0aXZlLCBzZXRSZWFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IHVzZUVmZmVjdEV2ZW50KCh4LCB5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBzZXR0aW5nIGlmIHRoZSBvcGVuIGV2ZW50IHdhcyBub3QgYSBtb3VzZS1saWtlIG9uZVxuICAgIC8vIChlLmcuIGZvY3VzIHRvIG9wZW4sIHRoZW4gaG92ZXIgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQpLlxuICAgIC8vIE9ubHkgYXBwbHkgaWYgdGhlIGV2ZW50IGV4aXN0cy5cbiAgICBpZiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiAhaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShjcmVhdGVWaXJ0dWFsRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZSwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBheGlzLFxuICAgICAgZGF0YVJlZixcbiAgICAgIHBvaW50ZXJUeXBlXG4gICAgfSkpO1xuICB9KTtcbiAgY29uc3QgaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9IGVsc2UgaWYgKCFjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBjbGVhbnVwLCB0aGVyZSdzIG5vIGxpc3RlbmVyLCBidXQgd2Ugd2FudCB0byBlbnN1cmVcbiAgICAgIC8vIHdlIGFkZCB0aGUgbGlzdGVuZXIgaWYgdGhlIGN1cnNvciBsYW5kZWQgb24gdGhlIGZsb2F0aW5nIGVsZW1lbnQgYW5kXG4gICAgICAvLyB0aGVuIGJhY2sgb24gdGhlIHJlZmVyZW5jZSAoaS5lLiBpdCdzIGludGVyYWN0aXZlKS5cbiAgICAgIHNldFJlYWN0aXZlKFtdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHRoZSBwb2ludGVyIGlzIGEgbW91c2UtbGlrZSBwb2ludGVyLCB3ZSB3YW50IHRvIGNvbnRpbnVlIGZvbGxvd2luZyB0aGVcbiAgLy8gbW91c2UgZXZlbiBpZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nIG91dC4gT24gdG91Y2hcbiAgLy8gZGV2aWNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdpbGwgbW92ZSB0b1xuICAvLyB0aGUgZGlzbWlzc2FsIHRvdWNoIHBvaW50LlxuICBjb25zdCBvcGVuQ2hlY2sgPSBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSA/IGZsb2F0aW5nIDogb3BlbjtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHhgL2B5YCBjb29yZGluYXRlcyBzaG91bGRuJ3QgYWRkIGEgbGlzdGVuZXIuXG4gICAgaWYgKCFvcGVuQ2hlY2sgfHwgIWVuYWJsZWQgfHwgeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmICghY29udGFpbnMocmVmcy5mbG9hdGluZy5jdXJyZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCB8fCBpc01vdXNlQmFzZWRFdmVudChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSkge1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gY2xlYW51cDtcbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH1cbiAgICByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICB9LCBbZGF0YVJlZiwgZW5hYmxlZCwgb3BlbkNoZWNrLCByZWZzLCBzZXRSZWZlcmVuY2UsIHgsIHldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGV2ZW50LnRhcmdldCBpcyB3aXRoaW4gdGhlIHByb3ZpZGVkIG5vZGUuIFVzZXMgZXZlbnQuY29tcG9zZWRQYXRoIGlmIGF2YWlsYWJsZSBmb3IgY3VzdG9tIGVsZW1lbnQgc3VwcG9ydC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHdob3NlIHRhcmdldC9jb21wb3NlZFBhdGggdG8gY2hlY2tcbiAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrIGFnYWluc3RcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGV2ZW50LnRhcmdldC9jb21wb3NlZFBhdGggaXMgd2l0aGluIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG5vZGUpO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0IGNvbXBvc2VkUGF0aCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IGRvbSBkb24ndFxuICBjb25zdCBlID0gZXZlbnQ7XG4gIHJldHVybiBlLnRhcmdldCAhPSBudWxsICYmIG5vZGUuY29udGFpbnMoZS50YXJnZXQpO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVCdWJibGVzUHJvcCA9IGJ1YmJsZXMgPT4ge1xuICB2YXIgX2J1YmJsZXMkZXNjYXBlS2V5LCBfYnViYmxlcyRvdXRzaWRlUHJlc3M7XG4gIHJldHVybiB7XG4gICAgZXNjYXBlS2V5QnViYmxlczogdHlwZW9mIGJ1YmJsZXMgPT09ICdib29sZWFuJyA/IGJ1YmJsZXMgOiAoX2J1YmJsZXMkZXNjYXBlS2V5ID0gYnViYmxlcyA9PSBudWxsID8gdm9pZCAwIDogYnViYmxlcy5lc2NhcGVLZXkpICE9IG51bGwgPyBfYnViYmxlcyRlc2NhcGVLZXkgOiBmYWxzZSxcbiAgICBvdXRzaWRlUHJlc3NCdWJibGVzOiB0eXBlb2YgYnViYmxlcyA9PT0gJ2Jvb2xlYW4nID8gYnViYmxlcyA6IChfYnViYmxlcyRvdXRzaWRlUHJlc3MgPSBidWJibGVzID09IG51bGwgPyB2b2lkIDAgOiBidWJibGVzLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9idWJibGVzJG91dHNpZGVQcmVzcyA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIG5vZGVJZCxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9LFxuICAgIGRhdGFSZWZcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBlc2NhcGVLZXkgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzczogdW5zdGFibGVfb3V0c2lkZVByZXNzID0gdHJ1ZSxcbiAgICBvdXRzaWRlUHJlc3NFdmVudCA9ICdwb2ludGVyZG93bicsXG4gICAgcmVmZXJlbmNlUHJlc3MgPSBmYWxzZSxcbiAgICByZWZlcmVuY2VQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICBhbmNlc3RvclNjcm9sbCA9IGZhbHNlLFxuICAgIGJ1YmJsZXNcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IG5lc3RlZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCkgIT0gbnVsbDtcbiAgY29uc3Qgb3V0c2lkZVByZXNzRm4gPSB1c2VFZmZlY3RFdmVudCh0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gdW5zdGFibGVfb3V0c2lkZVByZXNzIDogKCkgPT4gZmFsc2UpO1xuICBjb25zdCBvdXRzaWRlUHJlc3MgPSB0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gb3V0c2lkZVByZXNzRm4gOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3M7XG4gIGNvbnN0IGluc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzc0J1YmJsZXNcbiAgfSA9IG5vcm1hbGl6ZUJ1YmJsZXNQcm9wKGJ1YmJsZXMpO1xuICBjb25zdCBjbG9zZU9uRXNjYXBlS2V5RG93biA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICBpZiAoIW9wZW4gfHwgIWVuYWJsZWQgfHwgIWVzY2FwZUtleSB8fCBldmVudC5rZXkgIT09ICdFc2NhcGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZSA/IGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKSA6IFtdO1xuICAgIGlmICghZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgc2hvdWxkRGlzbWlzcyA9IHRydWU7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHZhciBfY2hpbGQkY29udGV4dDtcbiAgICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0ID0gY2hpbGQuY29udGV4dCkgIT0gbnVsbCAmJiBfY2hpbGQkY29udGV4dC5vcGVuICYmICFjaGlsZC5jb250ZXh0LmRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMpIHtcbiAgICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZERpc21pc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLmVtaXQoJ2Rpc21pc3MnLCB7XG4gICAgICB0eXBlOiAnZXNjYXBlS2V5JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmV0dXJuRm9jdXM6IHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBpc1JlYWN0RXZlbnQoZXZlbnQpID8gZXZlbnQubmF0aXZlRXZlbnQgOiBldmVudCk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uUHJlc3NPdXRzaWRlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIC8vIEdpdmVuIGRldmVsb3BlcnMgY2FuIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBzeW50aGV0aWMgZXZlbnQsXG4gICAgLy8gd2UgY2FuIG9ubHkgYmUgY29uZmlkZW50IHdpdGggYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICBjb25zdCBpbnNpZGVSZWFjdFRyZWUgPSBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudDtcbiAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGlmIChpbnNpZGVSZWFjdFRyZWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgJiYgIW91dHNpZGVQcmVzcyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRXaW5kb3coZmxvYXRpbmcpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgICBpZiAoaXNSVEwpIHtcbiAgICAgICAgICB4Q29uZCA9IGV2ZW50Lm9mZnNldFggPD0gdGFyZ2V0Lm9mZnNldFdpZHRoIC0gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoeENvbmQgfHwgY2FuU2Nyb2xsWCAmJiBldmVudC5vZmZzZXRZID4gdGFyZ2V0LmNsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4gPSB0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKG5vZGUgPT4ge1xuICAgICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgICByZXR1cm4gaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICB9KTtcbiAgICBpZiAoaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgZmxvYXRpbmcpIHx8IGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGRvbVJlZmVyZW5jZSkgfHwgdGFyZ2V0SXNJbnNpZGVDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRyZWUgPyBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkgOiBbXTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHNob3VsZERpc21pc3MgPSB0cnVlO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHZhciBfY2hpbGQkY29udGV4dDI7XG4gICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQyID0gY2hpbGQuY29udGV4dCkgIT0gbnVsbCAmJiBfY2hpbGQkY29udGV4dDIub3BlbiAmJiAhY2hpbGQuY29udGV4dC5kYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzKSB7XG4gICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXNob3VsZERpc21pc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMuZW1pdCgnZGlzbWlzcycsIHtcbiAgICAgIHR5cGU6ICdvdXRzaWRlUHJlc3MnLFxuICAgICAgZGF0YToge1xuICAgICAgICByZXR1cm5Gb2N1czogbmVzdGVkID8ge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSA6IGlzVmlydHVhbENsaWNrKGV2ZW50KSB8fCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpXG4gICAgICB9XG4gICAgfSk7XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzID0gZXNjYXBlS2V5QnViYmxlcztcbiAgICBkYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzID0gb3V0c2lkZVByZXNzQnViYmxlcztcbiAgICBmdW5jdGlvbiBvblNjcm9sbChldmVudCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjbG9zZU9uRXNjYXBlS2V5RG93bik7XG4gICAgb3V0c2lkZVByZXNzICYmIGRvYy5hZGRFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjbG9zZU9uUHJlc3NPdXRzaWRlKTtcbiAgICBsZXQgYW5jZXN0b3JzID0gW107XG4gICAgaWYgKGFuY2VzdG9yU2Nyb2xsKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZG9tUmVmZXJlbmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQoZmxvYXRpbmcpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5jb25jYXQoZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFbGVtZW50KHJlZmVyZW5jZSkgJiYgcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElnbm9yZSB0aGUgdmlzdWFsIHZpZXdwb3J0IGZvciBzY3JvbGxpbmcgZGlzbWlzc2FsIChhbGxvdyBwaW5jaC16b29tKVxuICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5maWx0ZXIoYW5jZXN0b3IgPT4ge1xuICAgICAgdmFyIF9kb2MkZGVmYXVsdFZpZXc7XG4gICAgICByZXR1cm4gYW5jZXN0b3IgIT09ICgoX2RvYyRkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb2MkZGVmYXVsdFZpZXcudmlzdWFsVmlld3BvcnQpO1xuICAgIH0pO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlc2NhcGVLZXkgJiYgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjbG9zZU9uRXNjYXBlS2V5RG93bik7XG4gICAgICBvdXRzaWRlUHJlc3MgJiYgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNsb3NlT25QcmVzc091dHNpZGUpO1xuICAgICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgICBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbZGF0YVJlZiwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgcmVmZXJlbmNlLCBlc2NhcGVLZXksIG91dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnQsIG9wZW4sIG9uT3BlbkNoYW5nZSwgYW5jZXN0b3JTY3JvbGwsIGVuYWJsZWQsIGVzY2FwZUtleUJ1YmJsZXMsIG91dHNpZGVQcmVzc0J1YmJsZXMsIGNsb3NlT25Fc2NhcGVLZXlEb3duLCBjbG9zZU9uUHJlc3NPdXRzaWRlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgfSwgW291dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnRdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgICAgIFtidWJibGVIYW5kbGVyS2V5c1tyZWZlcmVuY2VQcmVzc0V2ZW50XV06IGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAocmVmZXJlbmNlUHJlc3MpIHtcbiAgICAgICAgICAgIGV2ZW50cy5lbWl0KCdkaXNtaXNzJywge1xuICAgICAgICAgICAgICB0eXBlOiAncmVmZXJlbmNlUHJlc3MnLFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuRm9jdXM6IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICAgICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICAgICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGV2ZW50cywgcmVmZXJlbmNlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50LCByZWZlcmVuY2VQcmVzc0V2ZW50LCBvbk9wZW5DaGFuZ2UsIGNsb3NlT25Fc2NhcGVLZXlEb3duXSk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQgYW5kIGNvbnRleHQgdG8gYWRkIGludGVyYWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdFxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50cztcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbiA9IGZhbHNlLFxuICAgIG9uT3BlbkNoYW5nZTogdW5zdGFibGVfb25PcGVuQ2hhbmdlLFxuICAgIG5vZGVJZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW19kb21SZWZlcmVuY2UsIHNldERvbVJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgZG9tUmVmZXJlbmNlID0gKChfb3B0aW9ucyRlbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9ucyRlbGVtZW50cy5yZWZlcmVuY2UpIHx8IF9kb21SZWZlcmVuY2U7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlRmxvYXRpbmckMShvcHRpb25zKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvbk9wZW5DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCgob3BlbiwgZXZlbnQpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IGV2ZW50O1xuICAgIH1cbiAgICB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHVuc3RhYmxlX29uT3BlbkNoYW5nZShvcGVuLCBldmVudCk7XG4gIH0pO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uUmVmZXJlbmNlID0gaXNFbGVtZW50KG5vZGUpID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShwb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIG5vZGVJZCxcbiAgICBmbG9hdGluZ0lkLFxuICAgIGV2ZW50cyxcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZVxuICB9KSwgW3Bvc2l0aW9uLCBub2RlSWQsIGZsb2F0aW5nSWQsIGV2ZW50cywgb3Blbiwgb25PcGVuQ2hhbmdlLCByZWZzLCBlbGVtZW50c10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50c1xuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgY29udGV4dF0pO1xufVxuXG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIHRoZSByZWZlcmVuY2UgZWxlbWVudCBoYXMgZm9jdXMsIGxpa2UgQ1NTXG4gKiBgOmZvY3VzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGb2N1c1xuICovXG5mdW5jdGlvbiB1c2VGb2N1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nLFxuICAgICAgZG9tUmVmZXJlbmNlXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGtleWJvYXJkT25seSA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZignJyk7XG4gIGNvbnN0IGJsb2NrRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSB3YXMgZm9jdXNlZCBhbmQgdGhlIHVzZXIgbGVmdCB0aGUgdGFiL3dpbmRvdywgYW5kIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgd2FzIG5vdCBvcGVuLCB0aGUgZm9jdXMgc2hvdWxkIGJlIGJsb2NrZWQgd2hlbiB0aGV5XG4gICAgLy8gcmV0dXJuIHRvIHRoZSB0YWIvd2luZG93LlxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmICghb3BlbiAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkgJiYgZG9tUmVmZXJlbmNlID09PSBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGRvbVJlZmVyZW5jZSkpKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIH07XG4gIH0sIFtmbG9hdGluZywgZG9tUmVmZXJlbmNlLCBvcGVuLCBlbmFibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRGlzbWlzcyhwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZC50eXBlID09PSAncmVmZXJlbmNlUHJlc3MnIHx8IHBheWxvYWQudHlwZSA9PT0gJ2VzY2FwZUtleScpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdkaXNtaXNzJywgb25EaXNtaXNzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignZGlzbWlzcycsIG9uRGlzbWlzcyk7XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duKF9yZWYpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gcG9pbnRlclR5cGU7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gISEocG9pbnRlclR5cGUgJiYga2V5Ym9hcmRPbmx5KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUxlYXZlKCkge1xuICAgICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkb3BlbjtcbiAgICAgICAgICBpZiAoYmxvY2tGb2N1c1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGlzbWlzcyB3aXRoIGNsaWNrIHNob3VsZCBpZ25vcmUgdGhlIHN1YnNlcXVlbnQgYGZvY3VzYCB0cmlnZ2VyLFxuICAgICAgICAgIC8vIGJ1dCBvbmx5IGlmIHRoZSBjbGljayBvcmlnaW5hdGVkIGluc2lkZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdmb2N1cycgJiYgKChfZGF0YVJlZiRjdXJyZW50JG9wZW4gPSBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRvcGVuLnR5cGUpID09PSAnbW91c2Vkb3duJyAmJiBpc0V2ZW50VGFyZ2V0V2l0aGluKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQsIGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgICAvLyBIaXQgdGhlIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50IHBvcnRhbCBndWFyZC4gRm9jdXMgd2lsbCBiZVxuICAgICAgICAgIC8vIG1vdmVkIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgICAgICAgY29uc3QgbW92ZWRUb0ZvY3VzR3VhcmQgPSBpc0VsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSAmJiByZWxhdGVkVGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJykgPT09ICdvdXRzaWRlJztcblxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3aW5kb3cgYmx1ciBsaXN0ZW5lciB0byBmaXJlLlxuICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2hlbiBmb2N1c2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKGUuZy4gcmVndWxhciBjbGljayksIHRoZW5cbiAgICAgICAgICAgIC8vIGNsaWNraW5nIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQsIHByZXZlbnQgaXQgZnJvbSBoaWRpbmcuXG4gICAgICAgICAgICAvLyBOb3RlOiBpdCBtdXN0IGJlIGZvY3VzYWJsZSwgZS5nLiBgdGFiaW5kZXg9XCItMVwiYC5cbiAgICAgICAgICAgIGlmIChjb250YWlucyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgbW92ZWRUb0ZvY3VzR3VhcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwga2V5Ym9hcmRPbmx5LCBkb21SZWZlcmVuY2UsIHJlZnMsIGRhdGFSZWYsIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBlbGVtZW50S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi4oZWxlbWVudEtleSA9PT0gJ2Zsb2F0aW5nJyAmJiB7XG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9KSxcbiAgICAuLi51c2VyUHJvcHMsXG4gICAgLi4ucHJvcHNMaXN0Lm1hcCh2YWx1ZSA9PiB2YWx1ZSA/IHZhbHVlW2VsZW1lbnRLZXldIDogbnVsbCkuY29uY2F0KHVzZXJQcm9wcykucmVkdWNlKChhY2MsIHByb3BzKSA9PiB7XG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBPYmplY3QuZW50cmllcyhwcm9wcykuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfbWFwJGdldC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGFjY1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoX21hcCRnZXQyID0gbWFwLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLm1hcChmbiA9PiBmbiguLi5hcmdzKSkuZmluZCh2YWwgPT4gdmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBpbnRlcmFjdGlvbiBob29rcycgcHJvcHMgaW50byBwcm9wIGdldHRlcnMsIGFsbG93aW5nXG4gKiBldmVudCBoYW5kbGVyIGZ1bmN0aW9ucyB0byBiZSBjb21wb3NlZCB0b2dldGhlciB3aXRob3V0IG92ZXJ3cml0aW5nIG9uZVxuICogYW5vdGhlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdCNpbnRlcmFjdGlvbi1ob29rc1xuICovXG5mdW5jdGlvbiB1c2VJbnRlcmFjdGlvbnMocHJvcHNMaXN0KSB7XG4gIGlmIChwcm9wc0xpc3QgPT09IHZvaWQgMCkge1xuICAgIHByb3BzTGlzdCA9IFtdO1xuICB9XG4gIC8vIFRoZSBkZXBlbmRlbmNpZXMgYXJlIGEgZHluYW1pYyBhcnJheSwgc28gd2UgY2FuJ3QgdXNlIHRoZSBsaW50ZXInc1xuICAvLyBzdWdnZXN0aW9uIHRvIGFkZCBpdCB0byB0aGUgZGVwcyBhcnJheS5cbiAgY29uc3QgZGVwcyA9IHByb3BzTGlzdDtcbiAgY29uc3QgZ2V0UmVmZXJlbmNlUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ3JlZmVyZW5jZScpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIGRlcHMpO1xuICBjb25zdCBnZXRGbG9hdGluZ1Byb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdmbG9hdGluZycpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIGRlcHMpO1xuICBjb25zdCBnZXRJdGVtUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2l0ZW0nKSxcbiAgLy8gR3JhbnVsYXJseSBjaGVjayBmb3IgYGl0ZW1gIGNoYW5nZXMsIGJlY2F1c2UgdGhlIGBnZXRJdGVtUHJvcHNgIGdldHRlclxuICAvLyBzaG91bGQgYmUgYXMgcmVmZXJlbnRpYWxseSBzdGFibGUgYXMgcG9zc2libGUgc2luY2UgaXQgbWF5IGJlIHBhc3NlZCBhc1xuICAvLyBhIHByb3AgdG8gbWFueSBjb21wb25lbnRzLiBBbGwgYGl0ZW1gIGtleSB2YWx1ZXMgbXVzdCB0aGVyZWZvcmUgYmVcbiAgLy8gbWVtb2l6ZWQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgcHJvcHNMaXN0Lm1hcChrZXkgPT4ga2V5ID09IG51bGwgPyB2b2lkIDAgOiBrZXkuaXRlbSkpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGdldFJlZmVyZW5jZVByb3BzLFxuICAgIGdldEZsb2F0aW5nUHJvcHMsXG4gICAgZ2V0SXRlbVByb3BzXG4gIH0pLCBbZ2V0UmVmZXJlbmNlUHJvcHMsIGdldEZsb2F0aW5nUHJvcHMsIGdldEl0ZW1Qcm9wc10pO1xufVxuXG5sZXQgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG5jb25zdCBBUlJPV19VUCA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV04gPSAnQXJyb3dEb3duJztcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuZnVuY3Rpb24gaXNEaWZmZXJlbnRSb3coaW5kZXgsIGNvbHMsIHByZXZSb3cpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyBjb2xzKSAhPT0gcHJldlJvdztcbn1cbmZ1bmN0aW9uIGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3RSZWYuY3VycmVudC5sZW5ndGg7XG59XG5mdW5jdGlvbiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHN0YXJ0aW5nSW5kZXggPSAtMSxcbiAgICBkZWNyZW1lbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYW1vdW50ID0gMVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IGxpc3QgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICB2YXIgX2xpc3QkaW5kZXgsIF9saXN0JGluZGV4MjtcbiAgICBpbmRleCA9IGluZGV4ICsgKGRlY3JlbWVudCA/IC1hbW91bnQgOiBhbW91bnQpO1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3QubGVuZ3RoIC0gMSAmJiAoZGlzYWJsZWRJbmRpY2VzID8gZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA6IGxpc3RbaW5kZXhdID09IG51bGwgfHwgKChfbGlzdCRpbmRleCA9IGxpc3RbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3QkaW5kZXguaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB8fCAoKF9saXN0JGluZGV4MiA9IGxpc3RbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3QkaW5kZXgyLmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpKSA9PT0gJ3RydWUnKSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT0gJyAnIHx8IGtleSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0gcnRsID8ga2V5ID09PSBBUlJPV19SSUdIVCA6IGtleSA9PT0gQVJST1dfTEVGVDtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfVVA7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgZGVjcmVtZW50OiB0cnVlLFxuICAgIHN0YXJ0aW5nSW5kZXg6IGxpc3RSZWYuY3VycmVudC5sZW5ndGgsXG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuLyoqXG4gKiBBZGRzIGFycm93IGtleS1iYXNlZCBuYXZpZ2F0aW9uIG9mIGEgbGlzdCBvZiBpdGVtcywgZWl0aGVyIHVzaW5nIHJlYWwgRE9NXG4gKiBmb2N1cyBvciB2aXJ0dWFsIGZvY3VzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUxpc3ROYXZpZ2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uKGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBsaXN0UmVmLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGU6IHVuc3RhYmxlX29uTmF2aWdhdGUgPSAoKSA9PiB7fSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbCxcbiAgICBhbGxvd0VzY2FwZSA9IGZhbHNlLFxuICAgIGxvb3AgPSBmYWxzZSxcbiAgICBuZXN0ZWQgPSBmYWxzZSxcbiAgICBydGwgPSBmYWxzZSxcbiAgICB2aXJ0dWFsID0gZmFsc2UsXG4gICAgZm9jdXNJdGVtT25PcGVuID0gJ2F1dG8nLFxuICAgIGZvY3VzSXRlbU9uSG92ZXIgPSB0cnVlLFxuICAgIG9wZW5PbkFycm93S2V5RG93biA9IHRydWUsXG4gICAgZGlzYWJsZWRJbmRpY2VzID0gdW5kZWZpbmVkLFxuICAgIG9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJyxcbiAgICBjb2xzID0gMSxcbiAgICBzY3JvbGxJdGVtSW50b1ZpZXcgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChhbGxvd0VzY2FwZSkge1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIGxvb3BpbmcgbXVzdCBiZSBlbmFibGVkIHRvIGFsbG93JywgJ2VzY2FwaW5nLiddLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IGB1c2VMaXN0TmF2aWdhdGlvbmAgbXVzdCBiZSB2aXJ0dWFsIHRvIGFsbG93JywgJ2VzY2FwaW5nLiddLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiBjb2xzID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IEluIGdyaWQgbGlzdCBuYXZpZ2F0aW9uIG1vZGUgKGBjb2xzYCA+IDEpLCB0aGUnLCAnYG9yaWVudGF0aW9uYCBzaG91bGQgYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwiYm90aFwiLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvbk5hdmlnYXRlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25OYXZpZ2F0ZSk7XG4gIGNvbnN0IGZvY3VzSXRlbU9uT3BlblJlZiA9IFJlYWN0LnVzZVJlZihmb2N1c0l0ZW1Pbk9wZW4pO1xuICBjb25zdCBpbmRleFJlZiA9IFJlYWN0LnVzZVJlZihzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogLTEpO1xuICBjb25zdCBrZXlSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlzUG9pbnRlck1vZGFsaXR5UmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwcmV2aW91c09uTmF2aWdhdGVSZWYgPSBSZWFjdC51c2VSZWYob25OYXZpZ2F0ZSk7XG4gIGNvbnN0IHByZXZpb3VzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZighIWZsb2F0aW5nKTtcbiAgY29uc3QgZm9yY2VTeW5jRm9jdXMgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBmb3JjZVNjcm9sbEludG9WaWV3UmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZGlzYWJsZWRJbmRpY2VzUmVmID0gdXNlTGF0ZXN0UmVmKGRpc2FibGVkSW5kaWNlcyk7XG4gIGNvbnN0IGxhdGVzdE9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHNjcm9sbEl0ZW1JbnRvVmlld1JlZiA9IHVzZUxhdGVzdFJlZihzY3JvbGxJdGVtSW50b1ZpZXcpO1xuICBjb25zdCBbYWN0aXZlSWQsIHNldEFjdGl2ZUlkXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IGZvY3VzSXRlbSA9IHVzZUVmZmVjdEV2ZW50KGZ1bmN0aW9uIChsaXN0UmVmLCBpbmRleFJlZiwgZm9yY2VTY3JvbGxJbnRvVmlldykge1xuICAgIGlmIChmb3JjZVNjcm9sbEludG9WaWV3ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGxpc3RSZWYuY3VycmVudFtpbmRleFJlZi5jdXJyZW50XTtcbiAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICBpZiAodmlydHVhbCkge1xuICAgICAgc2V0QWN0aXZlSWQoaXRlbS5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVucXVldWVGb2N1cyhpdGVtLCB7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXG4gICAgICAgIC8vIE1hYyBTYWZhcmkgZG9lcyBub3QgbW92ZSB0aGUgdmlydHVhbCBjdXJzb3IgdW5sZXNzIHRoZSBmb2N1cyBjYWxsXG4gICAgICAgIC8vIGlzIHN5bmMuIEhvd2V2ZXIsIGZvciB0aGUgdmVyeSBmaXJzdCBmb2N1cyBjYWxsLCB3ZSBuZWVkIHRvIHdhaXRcbiAgICAgICAgLy8gZm9yIHRoZSBwb3NpdGlvbiB0byBiZSByZWFkeSBpbiBvcmRlciB0byBwcmV2ZW50IHVud2FudGVkXG4gICAgICAgIC8vIHNjcm9sbGluZy4gVGhpcyBtZWFucyB0aGUgdmlydHVhbCBjdXJzb3Igd2lsbCBub3QgbW92ZSB0byB0aGUgZmlyc3RcbiAgICAgICAgLy8gaXRlbSB3aGVuIGZpcnN0IG9wZW5pbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQsIGJ1dCB3aWxsIG9uXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgY2FsbHMuIGBwcmV2ZW50U2Nyb2xsYCBpcyBzdXBwb3J0ZWQgaW4gbW9kZXJuIFNhZmFyaSxcbiAgICAgICAgLy8gc28gd2UgY2FuIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgICAgIC8vIGlPUyBTYWZhcmkgbXVzdCBiZSBhc3luYyBvciB0aGUgZmlyc3QgaXRlbSB3aWxsIG5vdCBiZSBmb2N1c2VkLlxuICAgICAgICBzeW5jOiBpc01hYygpICYmIGlzU2FmYXJpKCkgPyBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgfHwgZm9yY2VTeW5jRm9jdXMuY3VycmVudCA6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IHNjcm9sbEludG9WaWV3T3B0aW9ucyA9IHNjcm9sbEl0ZW1JbnRvVmlld1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlld09wdGlvbnMgJiYgaXRlbSAmJiAoZm9yY2VTY3JvbGxJbnRvVmlldyB8fCAhaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCk7XG4gICAgICBpZiAoc2hvdWxkU2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgLy8gSlNET00gZG9lc24ndCBzdXBwb3J0IGAuc2Nyb2xsSW50b1ZpZXcoKWAgYnV0IGl0J3Mgd2lkZWx5IHN1cHBvcnRlZFxuICAgICAgICAvLyBieSBhbGwgYnJvd3NlcnMuXG4gICAgICAgIGl0ZW0uc2Nyb2xsSW50b1ZpZXcgPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBvbk5hdmlnYXRlKHNlbGVjdGVkSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGBvbk5hdmlnYXRlYCBjb25kaXRpb25hbGx5XG4gICAgICAvLyAob25OYXZpZ2F0ZTogb3BlbiA/IHNldEFjdGl2ZUluZGV4IDogc2V0U2VsZWN0ZWRJbmRleCksXG4gICAgICAvLyB3ZSBzdG9yZSBhbmQgY2FsbCB0aGUgcHJldmlvdXMgZnVuY3Rpb24uXG4gICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudChudWxsKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZywgc2VsZWN0ZWRJbmRleCwgb25OYXZpZ2F0ZV0pO1xuXG4gIC8vIFN5bmMgYGFjdGl2ZUluZGV4YCB0byBiZSB0aGUgZm9jdXNlZCBpdGVtIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gIC8vIG9wZW4uXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PSBudWxsKSB7XG4gICAgICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdhcyBvcGVuIChlLmcuIHRoZSBsaXN0IGNoYW5nZWQpLlxuICAgICAgICBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWwgc3luYy5cbiAgICAgICAgaWYgKCFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCAmJiBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiAoa2V5UmVmLmN1cnJlbnQgIT0gbnVsbCB8fCBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9PT0gdHJ1ZSAmJiBrZXlSZWYuY3VycmVudCA9PSBudWxsKSkge1xuICAgICAgICAgIGxldCBydW5zID0gMDtcbiAgICAgICAgICBjb25zdCB3YWl0Rm9yTGlzdFBvcHVsYXRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChsaXN0UmVmLmN1cnJlbnRbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBsZXR0aW5nIHRoZSBicm93c2VyIHBhaW50IGlmIHBvc3NpYmxlIG9uIHRoZSBmaXJzdCB0cnksXG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgckFGLiBEb24ndCB0cnkgbW9yZSB0aGFuIHR3aWNlLCBzaW5jZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgLy8gaXMgd3Jvbmcgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICBpZiAocnVucyA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlZHVsZXIgPSBydW5zID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogcXVldWVNaWNyb3Rhc2s7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyKHdhaXRGb3JMaXN0UG9wdWxhdGVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBydW5zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0ga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCB8fCBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleVJlZi5jdXJyZW50LCBvcmllbnRhdGlvbiwgcnRsKSB8fCBuZXN0ZWQgPyBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCkgOiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHdhaXRGb3JMaXN0UG9wdWxhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBhY3RpdmVJbmRleCkpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGFjdGl2ZUluZGV4O1xuICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYsIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCk7XG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGZsb2F0aW5nLCBhY3RpdmVJbmRleCwgc2VsZWN0ZWRJbmRleCwgbmVzdGVkLCBsaXN0UmVmLCBvcmllbnRhdGlvbiwgcnRsLCBvbk5hdmlnYXRlLCBmb2N1c0l0ZW0sIGRpc2FibGVkSW5kaWNlc1JlZl0pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGFyZW50IGZsb2F0aW5nIGVsZW1lbnQgaGFzIGZvY3VzIHdoZW4gYSBuZXN0ZWQgY2hpbGQgY2xvc2VzXG4gIC8vIHRvIGFsbG93IGFycm93IGtleSBuYXZpZ2F0aW9uIHRvIHdvcmsgYWZ0ZXIgdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSBjaGlsZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWZsb2F0aW5nICYmIHRyZWUpIHtcbiAgICAgIHZhciBfbm9kZXMkZmluZCwgX25vZGVzJGZpbmQkY29udGV4dDtcbiAgICAgIGNvbnN0IG5vZGVzID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgcGFyZW50ID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfbm9kZXMkZmluZCRjb250ZXh0ID0gX25vZGVzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kJGNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyhub2RlLmNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKSk7XG4gICAgICBpZiAocGFyZW50ICYmICF0cmVlQ29udGFpbnNBY3RpdmVFbCkge1xuICAgICAgICBwYXJlbnQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmcsIHRyZWUsIHBhcmVudElkXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudCA9IG9uTmF2aWdhdGU7XG4gICAgcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgPSAhIWZsb2F0aW5nO1xuICB9KTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAga2V5UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaGFzQWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAhPSBudWxsO1xuICBjb25zdCBpdGVtID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCkge1xuICAgICAgaWYgKCFvcGVuKSByZXR1cm47XG4gICAgICBjb25zdCBpbmRleCA9IGxpc3RSZWYuY3VycmVudC5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBvbkZvY3VzKF9yZWYpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiBfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIFNhZmFyaVxuICAgICAgLi4uKGZvY3VzSXRlbU9uSG92ZXIgJiYge1xuICAgICAgICBvbk1vdXNlTW92ZShfcmVmMykge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJMZWF2ZShfcmVmNCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgICAgIH0gPSBfcmVmNDtcbiAgICAgICAgICBpZiAoIWlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgICAgb25OYXZpZ2F0ZShudWxsKTtcbiAgICAgICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHByb3BzO1xuICB9LCBbb3BlbiwgcmVmcywgZm9jdXNJdGVtLCBmb2N1c0l0ZW1PbkhvdmVyLCBsaXN0UmVmLCBvbk5hdmlnYXRlLCB2aXJ0dWFsXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZGlzYWJsZWRJbmRpY2VzID0gZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQ7XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgLy8gSWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgYW5pbWF0aW5nIG91dCwgaWdub3JlIG5hdmlnYXRpb24uIE90aGVyd2lzZSxcbiAgICAgIC8vIHRoZSBgYWN0aXZlSW5kZXhgIGdldHMgc2V0IHRvIDAgZGVzcGl0ZSBub3QgYmVpbmcgb3BlbiBzbyB0aGUgbmV4dCB0aW1lXG4gICAgICAvLyB0aGUgdXNlciBBcnJvd0Rvd25zLCB0aGUgZmlyc3QgaXRlbSB3b24ndCBiZSBmb2N1c2VkLlxuICAgICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gcmVmcy5mbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXN0ZWQgJiYgaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgIGRvbVJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgICBpZiAoY29scyA+IDEpIHtcbiAgICAgICAgY29uc3QgcHJldkluZGV4ID0gaW5kZXhSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfVVApIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWF4SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobG9vcCAmJiAocHJldkluZGV4IC0gY29scyA8IG1pbkluZGV4IHx8IGluZGV4UmVmLmN1cnJlbnQgPCAwKSkge1xuICAgICAgICAgICAgICBjb25zdCBjb2wgPSBwcmV2SW5kZXggJSBjb2xzO1xuICAgICAgICAgICAgICBjb25zdCBtYXhDb2wgPSBtYXhJbmRleCAlIGNvbHM7XG4gICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1heEluZGV4IC0gKG1heENvbCAtIGNvbCk7XG4gICAgICAgICAgICAgIGlmIChtYXhDb2wgPT09IGNvbCkge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtYXhJbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWF4Q29sID4gY29sID8gb2Zmc2V0IDogb2Zmc2V0IC0gY29scztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4UmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gcHJldkluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0RPV04pIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWluSW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxvb3AgJiYgcHJldkluZGV4ICsgY29scyA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICUgY29scyAtIGNvbHMsXG4gICAgICAgICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IHByZXZJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbWFpbnMgb24gdGhlIHNhbWUgcm93L2NvbHVtbi5cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICAgICBjb25zdCBwcmV2Um93ID0gTWF0aC5mbG9vcihwcmV2SW5kZXggLyBjb2xzKTtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19SSUdIVCkge1xuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSBjb2xzIC0gMSkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KGluZGV4UmVmLmN1cnJlbnQsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhpbmRleFJlZi5jdXJyZW50LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gcHJldkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19MRUZUKSB7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IDApIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRSb3coaW5kZXhSZWYuY3VycmVudCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaWZmZXJlbnRSb3coaW5kZXhSZWYuY3VycmVudCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IHByZXZJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGFzdFJvdyA9IE1hdGguZmxvb3IobWF4SW5kZXggLyBjb2xzKSA9PT0gcHJldlJvdztcbiAgICAgICAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4UmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAobG9vcCAmJiBsYXN0Um93KSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBldmVudC5rZXkgPT09IEFSUk9XX0xFRlQgPyBtYXhJbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gcHJldkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IGlmIG5vIGl0ZW0gaXMgZm9jdXNlZC5cbiAgICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxNb3VzZShldmVudCkge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbENsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIC8vIGBwb2ludGVyZG93bmAgZmlyZXMgZmlyc3QsIHJlc2V0IHRoZSBzdGF0ZSB0aGVuIHBlcmZvcm0gdGhlIGNoZWNrcy5cbiAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gZm9jdXNJdGVtT25PcGVuO1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AgPSB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IGFjdGl2ZUlkXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIC4uLmFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCxcbiAgICAgICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGlzQXJyb3dLZXkgPSBldmVudC5rZXkuaW5kZXhPZignQXJyb3cnKSA9PT0gMDtcbiAgICAgICAgICBpZiAodmlydHVhbCAmJiBvcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0aW5nIGVsZW1lbnQgc2hvdWxkIG5vdCBvcGVuIG9uIGFycm93IGtleSBkb3duLCBhdm9pZFxuICAgICAgICAgIC8vIHNldHRpbmcgYGFjdGl2ZUluZGV4YCB3aGlsZSBpdCdzIGNsb3NlZC5cbiAgICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTmF2aWdhdGlvbktleSA9IGlzQXJyb3dLZXkgfHwgZXZlbnQua2V5ID09PSAnRW50ZXInIHx8IGV2ZW50LmtleS50cmltKCkgPT09ICcnO1xuICAgICAgICAgIGNvbnN0IGlzTWFpbktleSA9IGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pO1xuICAgICAgICAgIGNvbnN0IGlzQ3Jvc3NLZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbktleSkge1xuICAgICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBuZXN0ZWQgJiYgaXNNYWluS2V5ID8gbnVsbCA6IGV2ZW50LmtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgICAgaWYgKGlzQ3Jvc3NLZXkpIHtcbiAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAoIW9wZW4gJiYgb3Blbk9uQXJyb3dLZXlEb3duKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbktleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXMoKSB7XG4gICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJEb3duOiBjaGVja1ZpcnR1YWxQb2ludGVyLFxuICAgICAgICBvbk1vdXNlRG93bjogY2hlY2tWaXJ0dWFsTW91c2UsXG4gICAgICAgIG9uQ2xpY2s6IGNoZWNrVmlydHVhbE1vdXNlXG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbiA9PT0gJ2JvdGgnID8gdW5kZWZpbmVkIDogb3JpZW50YXRpb24sXG4gICAgICAgIC4uLmFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCxcbiAgICAgICAgb25LZXlEb3duLFxuICAgICAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRlbVxuICAgIH07XG4gIH0sIFtkb21SZWZlcmVuY2UsIHJlZnMsIGFjdGl2ZUlkLCBkaXNhYmxlZEluZGljZXNSZWYsIGxhdGVzdE9wZW5SZWYsIGxpc3RSZWYsIGVuYWJsZWQsIG9yaWVudGF0aW9uLCBydGwsIHZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCBuZXN0ZWQsIHNlbGVjdGVkSW5kZXgsIG9wZW5PbkFycm93S2V5RG93biwgYWxsb3dFc2NhcGUsIGNvbHMsIGxvb3AsIGZvY3VzSXRlbU9uT3Blbiwgb25OYXZpZ2F0ZSwgb25PcGVuQ2hhbmdlLCBpdGVtXSk7XG59XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIHJlZnMgaW50byBhIHNpbmdsZSBtZW1vaXplZCBjYWxsYmFjayByZWYgb3IgYG51bGxgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZU1lcmdlUmVmc1xuICovXG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkocmVmID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZWYodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIHJlZnMpO1xufVxuXG4vKipcbiAqIEFkZHMgYmFzZSBzY3JlZW4gcmVhZGVyIHByb3BzIHRvIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nIGVsZW1lbnRzIGZvciBhXG4gKiBnaXZlbiBmbG9hdGluZyBlbGVtZW50IGByb2xlYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VSb2xlXG4gKi9cbmZ1bmN0aW9uIHVzZVJvbGUoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGZsb2F0aW5nSWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICByb2xlID0gJ2RpYWxvZydcbiAgfSA9IHByb3BzO1xuICBjb25zdCByZWZlcmVuY2VJZCA9IHVzZUlkKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IGZsb2F0aW5nSWQsXG4gICAgICByb2xlXG4gICAgfTtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKHJvbGUgPT09ICd0b29sdGlwJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBvcGVuID8gZmxvYXRpbmdJZCA6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZmxvYXRpbmdQcm9wc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IG9wZW4gPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHJvbGUgPT09ICdhbGVydGRpYWxvZycgPyAnZGlhbG9nJyA6IHJvbGUsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLihyb2xlID09PSAnbGlzdGJveCcgJiYge1xuICAgICAgICAgIHJvbGU6ICdjb21ib2JveCdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAgIGlkOiByZWZlcmVuY2VJZFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIC4uLmZsb2F0aW5nUHJvcHMsXG4gICAgICAgIC4uLihyb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiByZWZlcmVuY2VJZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByb2xlLCBvcGVuLCBmbG9hdGluZ0lkLCByZWZlcmVuY2VJZF0pO1xufVxuXG4vLyBDb252ZXJ0cyBhIEpTIHN0eWxlIGtleSBsaWtlIGBiYWNrZ3JvdW5kQ29sb3JgIHRvIGEgQ1NTIHRyYW5zaXRpb24tcHJvcGVydHlcbi8vIGxpa2UgYGJhY2tncm91bmQtY29sb3JgLlxuY29uc3QgY2FtZWxDYXNlVG9LZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmZ1bmN0aW9uIGV4ZWNXaXRoQXJnc09yUmV0dXJuKHZhbHVlT3JGbiwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlT3JGbihhcmdzKSA6IHZhbHVlT3JGbjtcbn1cbmZ1bmN0aW9uIHVzZURlbGF5VW5tb3VudChvcGVuLCBkdXJhdGlvbk1zKSB7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShvcGVuKTtcbiAgaWYgKG9wZW4gJiYgIWlzTW91bnRlZCkge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0SXNNb3VudGVkKGZhbHNlKSwgZHVyYXRpb25Ncyk7XG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgfSwgW29wZW4sIGR1cmF0aW9uTXNdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgYSBzdGF0dXMgc3RyaW5nIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsXG4gKiBjb3JyZWN0bHkgaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0YXR1c1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW2luaXRpYXRlZCwgc2V0SW5pdGlhdGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKCd1bm1vdW50ZWQnKTtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGNsb3NlRHVyYXRpb24pO1xuXG4gIC8vIGBpbml0aWF0ZWRgIGNoZWNrIHByZXZlbnRzIHRoaXMgYHNldFN0YXRlYCBjYWxsIGZyb20gYnJlYWtpbmdcbiAgLy8gPEZsb2F0aW5nUG9ydGFsIC8+LiBUaGlzIGNhbGwgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBzdWJzZXF1ZW50IG9wZW5zXG4gIC8vIGFmdGVyIHRoZSBpbml0aWFsIG9uZSBhbGxvd3MgdGhlIGNvcnJlY3Qgc2lkZSBhbmltYXRpb24gdG8gcGxheSB3aGVuIHRoZVxuICAvLyBwbGFjZW1lbnQgaGFzIGNoYW5nZWQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhdGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgIHNldFN0YXR1cygndW5tb3VudGVkJyk7XG4gICAgfVxuICB9LCBbaW5pdGlhdGVkLCBpc01vdW50ZWRdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZmxvYXRpbmcpIHJldHVybjtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0U3RhdHVzKCdpbml0aWFsJyk7XG4gICAgICBjb25zdCBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHNldFN0YXR1cygnb3BlbicpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbml0aWF0ZWQodHJ1ZSk7XG4gICAgICBzZXRTdGF0dXMoJ2Nsb3NlJyk7XG4gICAgfVxuICB9LCBbb3BlbiwgZmxvYXRpbmddKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHN0eWxlcyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LCBjb3JyZWN0bHlcbiAqIGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy4gV3JhcHBlciBhcm91bmQgYHVzZVRyYW5zaXRpb25TdGF0dXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0eWxlc1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3R5bGVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5pdGlhbDogdW5zdGFibGVfaW5pdGlhbCA9IHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgIG9wZW46IHVuc3RhYmxlX29wZW4sXG4gICAgY2xvc2U6IHVuc3RhYmxlX2Nsb3NlLFxuICAgIGNvbW1vbjogdW5zdGFibGVfY29tbW9uLFxuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGxhY2VtZW50ID0gY29udGV4dC5wbGFjZW1lbnQ7XG4gIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgZm5BcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHNpZGUsXG4gICAgcGxhY2VtZW50XG4gIH0pLCBbc2lkZSwgcGxhY2VtZW50XSk7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBvcGVuRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24ub3BlbikgfHwgMDtcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0eWxlcywgc2V0U3R5bGVzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfY29tbW9uLCBmbkFyZ3MpLFxuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2luaXRpYWwsIGZuQXJncylcbiAgfSkpO1xuICBjb25zdCB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9ID0gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCB7XG4gICAgZHVyYXRpb25cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfaW5pdGlhbCk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfb3Blbik7XG4gIGNvbnN0IGNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2Nsb3NlKTtcbiAgY29uc3QgY29tbW9uUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2NvbW1vbik7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oaW5pdGlhbFJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNsb3NlU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY2xvc2VSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjb21tb25TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjb21tb25SZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBvcGVuU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4ob3BlblJlZi5jdXJyZW50LCBmbkFyZ3MpIHx8IE9iamVjdC5rZXlzKGluaXRpYWxTdHlsZXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGFjY1trZXldID0gJyc7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZiAoc3RhdHVzID09PSAnaW5pdGlhbCcpIHtcbiAgICAgIHNldFN0eWxlcyhzdHlsZXMgPT4gKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBzdHlsZXMudHJhbnNpdGlvblByb3BlcnR5LFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLmluaXRpYWxTdHlsZXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gJ29wZW4nKSB7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKG9wZW5TdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IG9wZW5EdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5vcGVuU3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2Nsb3NlJykge1xuICAgICAgY29uc3Qgc3R5bGVzID0gY2xvc2VTdHlsZXMgfHwgaW5pdGlhbFN0eWxlcztcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMoc3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBjbG9zZUR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLnN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY2xvc2VEdXJhdGlvbiwgY2xvc2VSZWYsIGluaXRpYWxSZWYsIG9wZW5SZWYsIGNvbW1vblJlZiwgb3BlbkR1cmF0aW9uLCBzdGF0dXMsIGZuQXJnc10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdHlsZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIG1hdGNoaW5nIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gZm9jdXMgYW4gaXRlbSBhcyB0aGUgdXNlclxuICogdHlwZXMsIG9mdGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uKClgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVR5cGVhaGVhZFxuICovXG5mdW5jdGlvbiB1c2VUeXBlYWhlYWQoY29udGV4dCwgcHJvcHMpIHtcbiAgdmFyIF9yZWY7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGRhdGFSZWZcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBsaXN0UmVmLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTWF0Y2g6IHVuc3RhYmxlX29uTWF0Y2gsXG4gICAgb25UeXBpbmdDaGFuZ2U6IHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlLFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGZpbmRNYXRjaCA9IG51bGwsXG4gICAgcmVzZXRNcyA9IDc1MCxcbiAgICBpZ25vcmVLZXlzID0gW10sXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0aW1lb3V0SWRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qgc3RyaW5nUmVmID0gUmVhY3QudXNlUmVmKCcnKTtcbiAgY29uc3QgcHJldkluZGV4UmVmID0gUmVhY3QudXNlUmVmKChfcmVmID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZiA6IC0xKTtcbiAgY29uc3QgbWF0Y2hJbmRleFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb25NYXRjaCA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTWF0Y2gpO1xuICBjb25zdCBvblR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlKTtcbiAgY29uc3QgZmluZE1hdGNoUmVmID0gdXNlTGF0ZXN0UmVmKGZpbmRNYXRjaCk7XG4gIGNvbnN0IGlnbm9yZUtleXNSZWYgPSB1c2VMYXRlc3RSZWYoaWdub3JlS2V5cyk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIC8vIFN5bmMgYXJyb3cga2V5IG5hdmlnYXRpb24gYnV0IG5vdCB0eXBlYWhlYWQgbmF2aWdhdGlvbi5cbiAgICBpZiAob3BlbiAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gJycpIHtcbiAgICAgIHZhciBfcmVmMjtcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gKF9yZWYyID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZjIgOiAtMTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZWxlY3RlZEluZGV4LCBhY3RpdmVJbmRleF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFR5cGluZ0NoYW5nZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghZGF0YVJlZi5jdXJyZW50LnR5cGluZykge1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSB2YWx1ZTtcbiAgICAgICAgICBvblR5cGluZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRNYXRjaGluZ0luZGV4KGxpc3QsIG9yZGVyZWRMaXN0LCBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHN0ciA9IGZpbmRNYXRjaFJlZi5jdXJyZW50ID8gZmluZE1hdGNoUmVmLmN1cnJlbnQob3JkZXJlZExpc3QsIHN0cmluZykgOiBvcmRlcmVkTGlzdC5maW5kKHRleHQgPT4gKHRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZy50b0xvY2FsZUxvd2VyQ2FzZSgpKSkgPT09IDApO1xuICAgICAgcmV0dXJuIHN0ciA/IGxpc3QuaW5kZXhPZihzdHIpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgY29uc3QgbGlzdENvbnRlbnQgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoc3RyaW5nUmVmLmN1cnJlbnQubGVuZ3RoID4gMCAmJiBzdHJpbmdSZWYuY3VycmVudFswXSAhPT0gJyAnKSB7XG4gICAgICAgIGlmIChnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBsaXN0Q29udGVudCwgc3RyaW5nUmVmLmN1cnJlbnQpID09PSAtMSkge1xuICAgICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlzdENvbnRlbnQgPT0gbnVsbCB8fCBpZ25vcmVLZXlzUmVmLmN1cnJlbnQuaW5jbHVkZXMoZXZlbnQua2V5KSB8fFxuICAgICAgLy8gQ2hhcmFjdGVyIGtleS5cbiAgICAgIGV2ZW50LmtleS5sZW5ndGggIT09IDEgfHxcbiAgICAgIC8vIE1vZGlmaWVyIGtleS5cbiAgICAgIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZW4gJiYgZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBCYWlsIG91dCBpZiB0aGUgbGlzdCBjb250YWlucyBhIHdvcmQgbGlrZSBcImxsYW1hXCIgb3IgXCJhYXJvblwiLiBUT0RPOlxuICAgICAgLy8gYWxsb3cgaXQgaW4gdGhpcyBjYXNlLCB0b28uXG4gICAgICBjb25zdCBhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIgPSBsaXN0Q29udGVudC5ldmVyeSh0ZXh0ID0+IHtcbiAgICAgICAgdmFyIF90ZXh0JCwgX3RleHQkMjtcbiAgICAgICAgcmV0dXJuIHRleHQgPyAoKF90ZXh0JCA9IHRleHRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dCQudG9Mb2NhbGVMb3dlckNhc2UoKSkgIT09ICgoX3RleHQkMiA9IHRleHRbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dCQyLnRvTG9jYWxlTG93ZXJDYXNlKCkpIDogdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbGxvd3MgdGhlIHVzZXIgdG8gY3ljbGUgdGhyb3VnaCBpdGVtcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHNhbWUgbGV0dGVyXG4gICAgICAvLyBpbiByYXBpZCBzdWNjZXNzaW9uLlxuICAgICAgaWYgKGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gZXZlbnQua2V5KSB7XG4gICAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgfVxuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgKz0gZXZlbnQua2V5O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgfSwgcmVzZXRNcyk7XG4gICAgICBjb25zdCBwcmV2SW5kZXggPSBwcmV2SW5kZXhSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TWF0Y2hpbmdJbmRleChsaXN0Q29udGVudCwgWy4uLmxpc3RDb250ZW50LnNsaWNlKChwcmV2SW5kZXggfHwgMCkgKyAxKSwgLi4ubGlzdENvbnRlbnQuc2xpY2UoMCwgKHByZXZJbmRleCB8fCAwKSArIDEpXSwgc3RyaW5nUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvbk1hdGNoKGluZGV4KTtcbiAgICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gaW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSAhPT0gJyAnKSB7XG4gICAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25LZXlEb3duXG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duLFxuICAgICAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBkYXRhUmVmLCBsaXN0UmVmLCByZXNldE1zLCBpZ25vcmVLZXlzUmVmLCBmaW5kTWF0Y2hSZWYsIG9uTWF0Y2gsIG9uVHlwaW5nQ2hhbmdlXSk7XG59XG5cbmZ1bmN0aW9uIGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoc3RhdGUsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHJlY3RzOiB7XG4gICAgICAuLi5zdGF0ZS5yZWN0cyxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIC4uLnN0YXRlLnJlY3RzLmZsb2F0aW5nLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCBzdWNoIHRoYXQgYW4gaW5uZXIgZWxlbWVudCBpbnNpZGVcbiAqIG9mIGl0IGlzIGFuY2hvcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbm5lclxuICovXG5jb25zdCBpbm5lciA9IHByb3BzID0+ICh7XG4gIG5hbWU6ICdpbm5lcicsXG4gIG9wdGlvbnM6IHByb3BzLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1pbkl0ZW1zVmlzaWJsZSA9IDQsXG4gICAgICByZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCA9IDAsXG4gICAgICBzY3JvbGxSZWYsXG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdHMsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4XTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXN0YXRlLnBsYWNlbWVudC5zdGFydHNXaXRoKCdib3R0b20nKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHBsYWNlbWVudGAgc2lkZSBtdXN0IGJlIFwiYm90dG9tXCIgd2hlbiB1c2luZyB0aGUnLCAnYGlubmVyYCBtaWRkbGV3YXJlLiddLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBuZXh0QXJncyA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4uKGF3YWl0IG9mZnNldCgtaXRlbS5vZmZzZXRUb3AgLSBmbG9hdGluZy5jbGllbnRUb3AgLSByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGl0ZW0ub2Zmc2V0SGVpZ2h0IC8gMiAtIGlubmVyT2Zmc2V0KS5mbihzdGF0ZSkpXG4gICAgfTtcbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBmbG9hdGluZztcbiAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQobmV4dEFyZ3MsIGVsLnNjcm9sbEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgY29uc3QgcmVmT3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhuZXh0QXJncywge1xuICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgfSk7XG4gICAgY29uc3QgZGlmZlkgPSBNYXRoLm1heCgwLCBvdmVyZmxvdy50b3ApO1xuICAgIGNvbnN0IG5leHRZID0gbmV4dEFyZ3MueSArIGRpZmZZO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KDAsIGVsLnNjcm9sbEhlaWdodCAtIGRpZmZZIC0gTWF0aC5tYXgoMCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgZWwuc3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xuICAgIGVsLnNjcm9sbFRvcCA9IGRpZmZZO1xuXG4gICAgLy8gVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSwgZmFsbGJhY2sgdG8gc3RhbmRhcmQgYW5jaG9yZWQgcG9zaXRpb25pbmdcbiAgICBpZiAob25GYWxsYmFja0NoYW5nZSkge1xuICAgICAgaWYgKGVsLm9mZnNldEhlaWdodCA8IGl0ZW0ub2Zmc2V0SGVpZ2h0ICogTWF0aC5taW4obWluSXRlbXNWaXNpYmxlLCBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoIC0gMSkgLSAxIHx8IHJlZk92ZXJmbG93LnRvcCA+PSAtcmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQgfHwgcmVmT3ZlcmZsb3cuYm90dG9tID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCkge1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4gb25GYWxsYmFja0NoYW5nZSh0cnVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4gb25GYWxsYmFja0NoYW5nZShmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcmZsb3dSZWYpIHtcbiAgICAgIG92ZXJmbG93UmVmLmN1cnJlbnQgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KHtcbiAgICAgICAgLi4ubmV4dEFyZ3MsXG4gICAgICAgIHk6IG5leHRZXG4gICAgICB9LCBlbC5vZmZzZXRIZWlnaHQpLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeTogbmV4dFlcbiAgICB9O1xuICB9XG59KTtcbi8qKlxuICogQ2hhbmdlcyB0aGUgYGlubmVyYCBtaWRkbGV3YXJlJ3MgYG9mZnNldGAgdXBvbiBhIGB3aGVlbGAgZXZlbnQgdG9cbiAqIGV4cGFuZCB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGhlaWdodCwgcmV2ZWFsaW5nIG1vcmUgbGlzdCBpdGVtcy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbm5lclxuICovXG5mdW5jdGlvbiB1c2VJbm5lck9mZnNldChjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIG92ZXJmbG93UmVmLFxuICAgIHNjcm9sbFJlZixcbiAgICBvbkNoYW5nZTogdW5zdGFibGVfb25DaGFuZ2VcbiAgfSA9IHByb3BzO1xuICBjb25zdCBvbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uQ2hhbmdlKTtcbiAgY29uc3QgY29udHJvbGxlZFNjcm9sbGluZ1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHByZXZTY3JvbGxUb3BSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluaXRpYWxPdmVyZmxvd1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8ICFlbCB8fCBvdmVyZmxvd1JlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZFkgPSBlLmRlbHRhWTtcbiAgICAgIGNvbnN0IGlzQXRUb3AgPSBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA+PSAtMC41O1xuICAgICAgY29uc3QgaXNBdEJvdHRvbSA9IG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tID49IC0wLjU7XG4gICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBzaWduID0gZFkgPCAwID8gLTEgOiAxO1xuICAgICAgY29uc3QgbWV0aG9kID0gZFkgPCAwID8gJ21heCcgOiAnbWluJztcbiAgICAgIGlmIChlbC5zY3JvbGxIZWlnaHQgPD0gZWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBdFRvcCAmJiBkWSA+IDAgfHwgIWlzQXRCb3R0b20gJiYgZFkgPCAwKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBvbkNoYW5nZShkID0+IGQgKyBNYXRoW21ldGhvZF0oZFksIHJlbWFpbmluZ1Njcm9sbCAqIHNpZ24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKC9maXJlZm94L2kudGVzdChnZXRVc2VyQWdlbnQoKSkpIHtcbiAgICAgICAgLy8gTmVlZGVkIHRvIHByb3BhZ2F0ZSBzY3JvbGxpbmcgZHVyaW5nIG1vbWVudHVtIHNjcm9sbGluZyBwaGFzZSBvbmNlXG4gICAgICAgIC8vIGl0IGdldHMgbGltaXRlZCBieSB0aGUgYm91bmRhcnkuIFVYIGltcHJvdmVtZW50LCBub3QgY3JpdGljYWwuXG4gICAgICAgIGVsLnNjcm9sbFRvcCArPSBkWTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgaWYgKG9wZW4gJiYgZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwb3NpdGlvbiB0byBiZSByZWFkeS5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgLi4ub3ZlcmZsb3dSZWYuY3VycmVudFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgb3ZlcmZsb3dSZWYsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duKCkge1xuICAgICAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uV2hlZWwoKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlck1vdmUoKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgICAgIGlmICghb3ZlcmZsb3dSZWYuY3VycmVudCB8fCAhZWwgfHwgIWNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxEaWZmID0gZWwuc2Nyb2xsVG9wIC0gcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tIDwgLTAuNSAmJiBzY3JvbGxEaWZmIDwgLTEgfHwgb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPCAtMC41ICYmIHNjcm9sbERpZmYgPiAxKSB7XG4gICAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkNoYW5nZShkID0+IGQgKyBzY3JvbGxEaWZmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gW0ZpcmVmb3hdIFdhaXQgZm9yIHRoZSBoZWlnaHQgY2hhbmdlIHRvIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgb3ZlcmZsb3dSZWYsIGVsZW1lbnRzLmZsb2F0aW5nLCBzY3JvbGxSZWYsIG9uQ2hhbmdlXSk7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgY29uc3QgW3gsIHldID0gcG9pbnQ7XG4gIGxldCBpc0luc2lkZSA9IGZhbHNlO1xuICBjb25zdCBsZW5ndGggPSBwb2x5Z29uLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgY29uc3QgW3hpLCB5aV0gPSBwb2x5Z29uW2ldIHx8IFswLCAwXTtcbiAgICBjb25zdCBbeGosIHlqXSA9IHBvbHlnb25bal0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHlpID49IHkgIT09IHlqID49IHkgJiYgeCA8PSAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpO1xuICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNJbnNpZGU7XG59XG5mdW5jdGlvbiBpc0luc2lkZShwb2ludCwgcmVjdCkge1xuICByZXR1cm4gcG9pbnRbMF0gPj0gcmVjdC54ICYmIHBvaW50WzBdIDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgcG9pbnRbMV0gPj0gcmVjdC55ICYmIHBvaW50WzFdIDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzYWZlIHBvbHlnb24gYXJlYSB0aGF0IHRoZSB1c2VyIGNhbiB0cmF2ZXJzZSB3aXRob3V0IGNsb3NpbmcgdGhlXG4gKiBmbG9hdGluZyBlbGVtZW50IG9uY2UgbGVhdmluZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXIjc2FmZVBvbHlnb25cbiAqL1xuZnVuY3Rpb24gc2FmZVBvbHlnb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBidWZmZXIgPSAwLjUsXG4gICAgYmxvY2tQb2ludGVyRXZlbnRzID0gZmFsc2UsXG4gICAgcmVxdWlyZUludGVudCA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGxldCBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RYID0gbnVsbDtcbiAgbGV0IGxhc3RZID0gbnVsbDtcbiAgbGV0IGxhc3RDdXJzb3JUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGZ1bmN0aW9uIGdldEN1cnNvclNwZWVkKHgsIHkpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSBsYXN0Q3Vyc29yVGltZTtcbiAgICBpZiAobGFzdFggPT09IG51bGwgfHwgbGFzdFkgPT09IG51bGwgfHwgZWxhcHNlZFRpbWUgPT09IDApIHtcbiAgICAgIGxhc3RYID0geDtcbiAgICAgIGxhc3RZID0geTtcbiAgICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geCAtIGxhc3RYO1xuICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBsYXN0WTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICAgIGNvbnN0IHNwZWVkID0gZGlzdGFuY2UgLyBlbGFwc2VkVGltZTsgLy8gcHggLyBtc1xuXG4gICAgbGFzdFggPSB4O1xuICAgIGxhc3RZID0geTtcbiAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHJldHVybiBzcGVlZDtcbiAgfVxuICBjb25zdCBmbiA9IF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb25DbG9zZSxcbiAgICAgIG5vZGVJZCxcbiAgICAgIHRyZWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgb25DbG9zZSgpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBpZiAoIWVsZW1lbnRzLmRvbVJlZmVyZW5jZSB8fCAhZWxlbWVudHMuZmxvYXRpbmcgfHwgcGxhY2VtZW50ID09IG51bGwgfHwgeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGNsaWVudFBvaW50ID0gW2NsaWVudFgsIGNsaWVudFldO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGNvbnN0IGlzTGVhdmUgPSBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZSc7XG4gICAgICBjb25zdCBpc092ZXJGbG9hdGluZ0VsID0gY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIHRhcmdldCk7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlZlJlY3QgPSBlbGVtZW50cy5kb21SZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudHMuZmxvYXRpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21SaWdodCA9IHggPiByZWN0LnJpZ2h0IC0gcmVjdC53aWR0aCAvIDI7XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPSB5ID4gcmVjdC5ib3R0b20gLSByZWN0LmhlaWdodCAvIDI7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VSZWN0ID0gaXNJbnNpZGUoY2xpZW50UG9pbnQsIHJlZlJlY3QpO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1dpZGVyID0gcmVjdC53aWR0aCA+IHJlZlJlY3Qud2lkdGg7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nVGFsbGVyID0gcmVjdC5oZWlnaHQgPiByZWZSZWN0LmhlaWdodDtcbiAgICAgIGNvbnN0IGxlZnQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLmxlZnQ7XG4gICAgICBjb25zdCByaWdodCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkucmlnaHQ7XG4gICAgICBjb25zdCB0b3AgPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS50b3A7XG4gICAgICBjb25zdCBib3R0b20gPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS5ib3R0b207XG4gICAgICBpZiAoaXNPdmVyRmxvYXRpbmdFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCAmJiAhaXNMZWF2ZSkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgb3ZlcmxhcHBpbmcgZmxvYXRpbmcgZWxlbWVudCBmcm9tIGJlaW5nIHN0dWNrIGluIGFuIG9wZW4tY2xvc2VcbiAgICAgIC8vIGxvb3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTkxMFxuICAgICAgaWYgKGlzTGVhdmUgJiYgaXNFbGVtZW50KGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmIGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCBldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSBuZXN0ZWQgY2hpbGQgaXMgb3BlbiwgYWJvcnQuXG4gICAgICBpZiAodHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0Lm9wZW47XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwb2ludGVyIGlzIGxlYXZpbmcgZnJvbSB0aGUgb3Bwb3NpdGUgc2lkZSwgdGhlIFwiYnVmZmVyXCIgbG9naWNcbiAgICAgIC8vIGNyZWF0ZXMgYSBwb2ludCB3aGVyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW1haW5zIG9wZW4sIGJ1dCBzaG91bGQgYmVcbiAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAvLyBBIGNvbnN0YW50IG9mIDEgaGFuZGxlcyBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMuXG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgJiYgeSA+PSByZWZSZWN0LmJvdHRvbSAtIDEgfHwgc2lkZSA9PT0gJ2JvdHRvbScgJiYgeSA8PSByZWZSZWN0LnRvcCArIDEgfHwgc2lkZSA9PT0gJ2xlZnQnICYmIHggPj0gcmVmUmVjdC5yaWdodCAtIDEgfHwgc2lkZSA9PT0gJ3JpZ2h0JyAmJiB4IDw9IHJlZlJlY3QubGVmdCArIDEpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElnbm9yZSB3aGVuIHRoZSBjdXJzb3IgaXMgd2l0aGluIHRoZSByZWN0YW5ndWxhciB0cm91Z2ggYmV0d2VlbiB0aGVcbiAgICAgIC8vIHR3byBlbGVtZW50cy4gU2luY2UgdGhlIHRyaWFuZ2xlIGlzIGNyZWF0ZWQgZnJvbSB0aGUgY3Vyc29yIHBvaW50LFxuICAgICAgLy8gd2hpY2ggY2FuIHN0YXJ0IGJleW9uZCB0aGUgcmVmIGVsZW1lbnQncyBlZGdlLCB0cmF2ZXJzaW5nIGJhY2sgYW5kXG4gICAgICAvLyBmb3J0aCBmcm9tIHRoZSByZWYgdG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGNhdXNlIGl0IHRvIGNsb3NlLiBUaGlzXG4gICAgICAvLyBlbnN1cmVzIGl0IGFsd2F5cyByZW1haW5zIG9wZW4gaW4gdGhhdCBjYXNlLlxuICAgICAgbGV0IHJlY3RQb2x5ID0gW107XG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVmUmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVmUmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWZSZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFBvbHlnb24oX3JlZjMpIHtcbiAgICAgICAgbGV0IFt4LCB5XSA9IF9yZWYzO1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3BdLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wIDogcmVjdC5ib3R0b20gLSBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QudG9wICsgYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbV0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b20gOiByZWN0LnRvcCArIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbLi4uY29tbW9uUG9pbnRzLCBjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd29dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCA6IHJlY3QubGVmdCArIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5Z29uKFtjbGllbnRYLCBjbGllbnRZXSwgcmVjdFBvbHkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTGFuZGVkICYmICFpc092ZXJSZWZlcmVuY2VSZWN0KSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xlYXZlICYmIHJlcXVpcmVJbnRlbnQpIHtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWQgPSBnZXRDdXJzb3JTcGVlZChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWRUaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIGlmIChjdXJzb3JTcGVlZCAhPT0gbnVsbCAmJiBjdXJzb3JTcGVlZCA8IGN1cnNvclNwZWVkVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIGdldFBvbHlnb24oW3gsIHldKSkpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWhhc0xhbmRlZCAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGNsb3NlLCA0MCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZm4uX19vcHRpb25zID0ge1xuICAgIGJsb2NrUG9pbnRlckV2ZW50c1xuICB9O1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IEZsb2F0aW5nQXJyb3csIEZsb2F0aW5nRGVsYXlHcm91cCwgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgRmxvYXRpbmdOb2RlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCBGbG9hdGluZ1RyZWUsIGlubmVyLCBzYWZlUG9seWdvbiwgdXNlQ2xpY2ssIHVzZUNsaWVudFBvaW50LCB1c2VEZWxheUdyb3VwLCB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRGlzbWlzcywgdXNlRmxvYXRpbmcsIHVzZUZsb2F0aW5nTm9kZUlkLCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCwgdXNlRmxvYXRpbmdQb3J0YWxOb2RlLCB1c2VGbG9hdGluZ1RyZWUsIHVzZUZvY3VzLCB1c2VIb3ZlciwgdXNlSWQsIHVzZUlubmVyT2Zmc2V0LCB1c2VJbnRlcmFjdGlvbnMsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJwbGF0Zm9ybSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwidXNlRmxvYXRpbmciLCJ1c2VGbG9hdGluZyQxIiwib2Zmc2V0IiwiZGV0ZWN0T3ZlcmZsb3ciLCJhcnJvdyIsImF1dG9QbGFjZW1lbnQiLCJhdXRvVXBkYXRlIiwiY29tcHV0ZVBvc2l0aW9uIiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwic2hpZnQiLCJzaXplIiwiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJzdXBwb3J0c0luZXJ0IiwiaGlkZU90aGVycyIsInN1cHByZXNzT3RoZXJzIiwidGFiYmFibGUiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJpbmRleCIsImRvY3VtZW50Iiwic2VydmVySGFuZG9mZkNvbXBsZXRlIiwiY291bnQiLCJnZW5JZCIsInVzZUZsb2F0aW5nSWQiLCJpZCIsInNldElkIiwidXNlU3RhdGUiLCJ1bmRlZmluZWQiLCJ1c2VSZWFjdElkIiwidG9TdHJpbmciLCJ1c2VJZCIsIkZsb2F0aW5nQXJyb3ciLCJmb3J3YXJkUmVmIiwiX3JlZiIsInJlZiIsImNvbnRleHQiLCJwbGFjZW1lbnQiLCJlbGVtZW50cyIsImZsb2F0aW5nIiwibWlkZGxld2FyZURhdGEiLCJ3aWR0aCIsImhlaWdodCIsInRpcFJhZGl1cyIsInN0cm9rZVdpZHRoIiwic3RhdGljT2Zmc2V0Iiwic3Ryb2tlIiwiZCIsInN0eWxlIiwidHJhbnNmb3JtIiwicmVzdFN0eWxlIiwicmVzdCIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsImNsaXBQYXRoSWQiLCJoYWxmU3Ryb2tlV2lkdGgiLCJzdmdYIiwic3ZnWSIsInNpZGUiLCJhbGlnbm1lbnQiLCJzcGxpdCIsImlzUlRMIiwiaXNDdXN0b21TaGFwZSIsImlzVmVydGljYWxTaWRlIiwieU9mZnNldFByb3AiLCJ4T2Zmc2V0UHJvcCIsImFycm93WCIsIngiLCJhcnJvd1kiLCJ5IiwiZFZhbHVlIiwicm90YXRpb24iLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJjcmVhdGVFbGVtZW50Iiwidmlld0JveCIsInBvc2l0aW9uIiwicG9pbnRlckV2ZW50cyIsImNsaXBQYXRoIiwiZmlsbCIsImNyZWF0ZVB1YlN1YiIsIm1hcCIsIk1hcCIsImVtaXQiLCJldmVudCIsImRhdGEiLCJfbWFwJGdldCIsImdldCIsImZvckVhY2giLCJoYW5kbGVyIiwib24iLCJsaXN0ZW5lciIsInNldCIsIm9mZiIsIl9tYXAkZ2V0MiIsImZpbHRlciIsImwiLCJGbG9hdGluZ05vZGVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkZsb2F0aW5nVHJlZUNvbnRleHQiLCJ1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCIsIl9SZWFjdCR1c2VDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUZsb2F0aW5nVHJlZSIsInVzZUZsb2F0aW5nTm9kZUlkIiwiY3VzdG9tUGFyZW50SWQiLCJ0cmVlIiwicmVhY3RQYXJlbnRJZCIsInBhcmVudElkIiwibm9kZSIsImFkZE5vZGUiLCJyZW1vdmVOb2RlIiwiRmxvYXRpbmdOb2RlIiwiY2hpbGRyZW4iLCJQcm92aWRlciIsInZhbHVlIiwidXNlTWVtbyIsIkZsb2F0aW5nVHJlZSIsIl9yZWYyIiwibm9kZXNSZWYiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJuIiwiZXZlbnRzIiwiZ2V0RG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiZ2V0UGxhdGZvcm0iLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiZ2V0VXNlckFnZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiYnJhbmRzIiwiYnJhbmQiLCJ2ZXJzaW9uIiwiam9pbiIsInVzZXJBZ2VudCIsImdldFdpbmRvdyIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJPd25FbGVtZW50IiwiaXNWaXJ0dWFsQ2xpY2siLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsImFuZHJvaWRSZSIsInRlc3QiLCJwb2ludGVyVHlwZSIsInR5cGUiLCJidXR0b25zIiwiZGV0YWlsIiwiaXNWaXJ0dWFsUG9pbnRlckV2ZW50IiwicHJlc3N1cmUiLCJpc1NhZmFyaSIsInZlbmRvciIsImlzTWFjIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwibWF4VG91Y2hQb2ludHMiLCJpc01vdXNlTGlrZVBvaW50ZXJUeXBlIiwic3RyaWN0IiwidmFsdWVzIiwicHVzaCIsImluY2x1ZGVzIiwiaXNSZWFjdEV2ZW50IiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJuZXh0IiwicGFyZW50Tm9kZSIsImhvc3QiLCJjcmVhdGVBdHRyaWJ1dGUiLCJuYW1lIiwidXNlTGF0ZXN0UmVmIiwic2FmZVBvbHlnb25JZGVudGlmaWVyIiwiZ2V0RGVsYXkiLCJwcm9wIiwidXNlSG92ZXIiLCJwcm9wcyIsIm9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJkYXRhUmVmIiwiZG9tUmVmZXJlbmNlIiwicmVmcyIsImVuYWJsZWQiLCJkZWxheSIsImhhbmRsZUNsb3NlIiwibW91c2VPbmx5IiwicmVzdE1zIiwibW92ZSIsImhhbmRsZUNsb3NlUmVmIiwiZGVsYXlSZWYiLCJwb2ludGVyVHlwZVJlZiIsInRpbWVvdXRSZWYiLCJoYW5kbGVyUmVmIiwicmVzdFRpbWVvdXRSZWYiLCJibG9ja01vdXNlTW92ZVJlZiIsInBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiIsInVuYmluZE1vdXNlTW92ZVJlZiIsImlzSG92ZXJPcGVuIiwiX2RhdGFSZWYkY3VycmVudCRvcGVuIiwib3BlbkV2ZW50Iiwib25EaXNtaXNzIiwiY2xlYXJUaW1lb3V0Iiwib25MZWF2ZSIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlV2l0aERlbGF5IiwicnVuRWxzZUJyYW5jaCIsImNsb3NlRGVsYXkiLCJzZXRUaW1lb3V0IiwiY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIiLCJjbGVhclBvaW50ZXJFdmVudHMiLCJib2R5IiwicmVtb3ZlQXR0cmlidXRlIiwiaXNDbGlja0xpa2VPcGVuRXZlbnQiLCJvbk1vdXNlRW50ZXIiLCJvcGVuRGVsYXkiLCJvbk1vdXNlTGVhdmUiLCJkb2MiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9uQ2xvc2UiLCJzaG91bGRDbG9zZSIsInJlbGF0ZWRUYXJnZXQiLCJvblNjcm9sbE1vdXNlTGVhdmUiLCJvbmNlIiwiX2hhbmRsZUNsb3NlUmVmJGN1cnJlIiwiX19vcHRpb25zIiwiYmxvY2tQb2ludGVyRXZlbnRzIiwic2V0QXR0cmlidXRlIiwiX3RyZWUkbm9kZXNSZWYkY3VycmVuIiwiX3RyZWUkbm9kZXNSZWYkY3VycmVuMiIsInBhcmVudEZsb2F0aW5nIiwiZmluZCIsInNldFBvaW50ZXJSZWYiLCJyZWZlcmVuY2UiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyRW50ZXIiLCJvbk1vdXNlTW92ZSIsIm5hdGl2ZUV2ZW50IiwicmV0dXJuRm9jdXMiLCJGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaW5pdGlhbERlbGF5IiwidGltZW91dE1zIiwiY3VycmVudElkIiwic2V0Q3VycmVudElkIiwic2V0U3RhdGUiLCJpc0luc3RhbnRQaGFzZSIsInVzZURlbGF5R3JvdXBDb250ZXh0IiwiRmxvYXRpbmdEZWxheUdyb3VwIiwic3RhdGUiLCJ1c2VSZWR1Y2VyIiwicHJldiIsImluaXRpYWxDdXJyZW50SWRSZWYiLCJ1c2VEZWxheUdyb3VwIiwiX3JlZjMiLCJjbG9zZSIsInVuc2V0IiwidGltZW91dCIsImFjdGl2ZUVsZW1lbnQiLCJfYWN0aXZlRWxlbWVudCIsIl9hY3RpdmVFbGVtZW50JHNoYWRvdyIsInNoYWRvd1Jvb3QiLCJyYWZJZCIsImVucXVldWVGb2N1cyIsImVsIiwib3B0aW9ucyIsInByZXZlbnRTY3JvbGwiLCJjYW5jZWxQcmV2aW91cyIsInN5bmMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImV4ZWMiLCJmb2N1cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldEFuY2VzdG9ycyIsIm5vZGVzIiwiX25vZGVzJGZpbmQiLCJhbGxBbmNlc3RvcnMiLCJjdXJyZW50UGFyZW50SWQiLCJjdXJyZW50Tm9kZSIsImNvbmNhdCIsImdldENoaWxkcmVuIiwiYWxsQ2hpbGRyZW4iLCJfbm9kZSRjb250ZXh0IiwiY3VycmVudENoaWxkcmVuIiwiX2N1cnJlbnRDaGlsZHJlbiIsInNvbWUiLCJfbm9kZSRjb250ZXh0MiIsImdldFRhcmdldCIsImNvbXBvc2VkUGF0aCIsIlRZUEVBQkxFX1NFTEVDVE9SIiwiaXNUeXBlYWJsZUVsZW1lbnQiLCJlbGVtZW50IiwibWF0Y2hlcyIsInN0b3BFdmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiZ2V0VGFiYmFibGVPcHRpb25zIiwiZ2V0U2hhZG93Um9vdCIsImRpc3BsYXlDaGVjayIsIlJlc2l6ZU9ic2VydmVyIiwiZ2V0VGFiYmFibGVJbiIsImNvbnRhaW5lciIsImRpcmVjdGlvbiIsImFsbFRhYmJhYmxlIiwicmV2ZXJzZSIsImFjdGl2ZUluZGV4IiwiaW5kZXhPZiIsIm5leHRUYWJiYWJsZUVsZW1lbnRzIiwic2xpY2UiLCJnZXROZXh0VGFiYmFibGUiLCJnZXRQcmV2aW91c1RhYmJhYmxlIiwiaXNPdXRzaWRlRXZlbnQiLCJjb250YWluZXJFbGVtZW50IiwiY3VycmVudFRhcmdldCIsImRpc2FibGVGb2N1c0luc2lkZSIsInRhYmJhYmxlRWxlbWVudHMiLCJkYXRhc2V0IiwidGFiaW5kZXgiLCJnZXRBdHRyaWJ1dGUiLCJlbmFibGVGb2N1c0luc2lkZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJISURERU5fU1RZTEVTIiwiYm9yZGVyIiwiY2xpcCIsIm1hcmdpbiIsIm92ZXJmbG93IiwicGFkZGluZyIsIndoaXRlU3BhY2UiLCJ0aW1lb3V0SWQiLCJzZXRBY3RpdmVFbGVtZW50T25UYWIiLCJGb2N1c0d1YXJkIiwicm9sZSIsInNldFJvbGUiLCJyZXN0UHJvcHMiLCJ0YWJJbmRleCIsIlBvcnRhbENvbnRleHQiLCJ1c2VGbG9hdGluZ1BvcnRhbE5vZGUiLCJfdGVtcCIsInJvb3QiLCJwb3J0YWxOb2RlIiwic2V0UG9ydGFsTm9kZSIsInVuaXF1ZUlkIiwicG9ydGFsQ29udGV4dCIsInVzZVBvcnRhbENvbnRleHQiLCJyZW1vdmUiLCJleGlzdGluZ0lkUm9vdCIsImdldEVsZW1lbnRCeUlkIiwiYXR0ciIsInN1YlJvb3QiLCJhcHBlbmRDaGlsZCIsImlkV3JhcHBlciIsIkZsb2F0aW5nUG9ydGFsIiwicHJlc2VydmVUYWJPcmRlciIsImZvY3VzTWFuYWdlclN0YXRlIiwic2V0Rm9jdXNNYW5hZ2VyU3RhdGUiLCJiZWZvcmVPdXRzaWRlUmVmIiwiYWZ0ZXJPdXRzaWRlUmVmIiwiYmVmb3JlSW5zaWRlUmVmIiwiYWZ0ZXJJbnNpZGVSZWYiLCJzaG91bGRSZW5kZXJHdWFyZHMiLCJtb2RhbCIsIm9uRm9jdXMiLCJmb2N1c2luZyIsIm1hbmFnZUZvY3VzIiwiX2JlZm9yZUluc2lkZVJlZiRjdXJyIiwicHJldlRhYmJhYmxlIiwiX2FmdGVySW5zaWRlUmVmJGN1cnJlIiwibmV4dFRhYmJhYmxlIiwiY2xvc2VPbkZvY3VzT3V0IiwiVmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiRmxvYXRpbmdGb2N1c01hbmFnZXIiLCJkaXNhYmxlZCIsIm9yZGVyIiwiZ3VhcmRzIiwiX2d1YXJkcyIsImluaXRpYWxGb2N1cyIsInZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsIm5vZGVJZCIsIm9yZGVyUmVmIiwiaW5pdGlhbEZvY3VzUmVmIiwicmV0dXJuRm9jdXNSZWYiLCJpZ25vcmVJbml0aWFsRm9jdXMiLCJzdGFydERpc21pc3NCdXR0b25SZWYiLCJlbmREaXNtaXNzQnV0dG9uUmVmIiwicHJldmVudFJldHVybkZvY3VzUmVmIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50UmVmIiwiaXNQb2ludGVyRG93blJlZiIsImlzSW5zaWRlUG9ydGFsIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiZ2V0VGFiYmFibGVDb250ZW50IiwiZ2V0VGFiYmFibGVFbGVtZW50cyIsImNvbnRlbnQiLCJCb29sZWFuIiwiZmxhdCIsIm9uS2V5RG93biIsImVscyIsInNoaWZ0S2V5IiwiaGFuZGxlUG9pbnRlckRvd24iLCJoYW5kbGVGb2N1c091dHNpZGUiLCJxdWV1ZU1pY3JvdGFzayIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiaGFzQXR0cmlidXRlIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsIl9wb3J0YWxDb250ZXh0JHBvcnRhbCIsInBvcnRhbE5vZGVzIiwiZnJvbSIsImluc2lkZU5vZGVzIiwic3VwcHJlc3NvckZuIiwiY2xlYW51cCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiaW5pdGlhbEZvY3VzVmFsdWUiLCJlbFRvRm9jdXMiLCJmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsIiwicHJldmVudFJldHVybkZvY3VzU2Nyb2xsIiwiY29udGV4dERhdGEiLCJwYXlsb2FkIiwiYWN0aXZlRWwiLCJzaG91bGRGb2N1c1JlZmVyZW5jZSIsIl9ub2RlJGNvbnRleHQ1IiwiTXV0YXRpb25PYnNlcnZlciIsImhhbmRsZU11dGF0aW9uIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImF0dHJpYnV0ZXMiLCJkaXNjb25uZWN0IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIkZyYWdtZW50IiwiX3BvcnRhbENvbnRleHQkYmVmb3JlIiwiX3BvcnRhbENvbnRleHQkYWZ0ZXJPIiwic29ydEJ5RG9jdW1lbnRQb3NpdGlvbiIsImEiLCJiIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMiLCJhcmVNYXBzRXF1YWwiLCJtYXAxIiwibWFwMiIsImVudHJpZXMiLCJGbG9hdGluZ0xpc3RDb250ZXh0IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwiZWxlbWVudHNSZWYiLCJGbG9hdGluZ0xpc3QiLCJsYWJlbHNSZWYiLCJzZXRNYXAiLCJwcmV2TWFwIiwiZGVsZXRlIiwibmV3TWFwIiwia2V5cyIsInNvcnQiLCJ1c2VMaXN0SXRlbSIsImxhYmVsIiwiaW5kZXgkMSIsInNldEluZGV4IiwiY29tcG9uZW50UmVmIiwiX25vZGUkdGV4dENvbnRlbnQiLCJpc0xhYmVsRGVmaW5lZCIsInRleHRDb250ZW50IiwiaWRlbnRpZmllciIsIkZsb2F0aW5nT3ZlcmxheSIsImxvY2tTY3JvbGwiLCJfd2luZG93JHZpc3VhbFZpZXdwb3IiLCJfd2luZG93JHZpc3VhbFZpZXdwb3IyIiwiYWxyZWFkeUxvY2tlZCIsInNjcm9sbGJhclgiLCJNYXRoIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY3JvbGxMZWZ0IiwicGFkZGluZ1Byb3AiLCJzY3JvbGxiYXJXaWR0aCIsImlubmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsIm9mZnNldExlZnQiLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldFRvcCIsInNjcm9sbFgiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsImZsb29yIiwic2Nyb2xsVG8iLCJpc0J1dHRvblRhcmdldCIsInRhZ05hbWUiLCJpc1NwYWNlSWdub3JlZCIsInVzZUNsaWNrIiwiZXZlbnRPcHRpb24iLCJ0b2dnbGUiLCJpZ25vcmVNb3VzZSIsImtleWJvYXJkSGFuZGxlcnMiLCJkaWRLZXlEb3duUmVmIiwib25Nb3VzZURvd24iLCJidXR0b24iLCJkZWZhdWx0UHJldmVudGVkIiwib25LZXlVcCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZVNhZmVJbnNlcnRpb25FZmZlY3QiLCJmbiIsInVzZUVmZmVjdEV2ZW50IiwiY2FsbGJhY2siLCJFcnJvciIsIl9sZW4iLCJhcmdzIiwiX2tleSIsImNyZWF0ZVZpcnR1YWxFbGVtZW50IiwiZG9tUmVmIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJpc0F1dG9VcGRhdGVFdmVudCIsImNvbnRleHRFbGVtZW50IiwiX2RvbVJlZiRjdXJyZW50IiwiX2RhdGEkZGF0YVJlZiRjdXJyZW50IiwiZG9tUmVjdCIsImlzWEF4aXMiLCJheGlzIiwiaXNZQXhpcyIsImNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlIiwiaXNNb3VzZUJhc2VkRXZlbnQiLCJ1c2VDbGllbnRQb2ludCIsImluaXRpYWxSZWYiLCJjbGVhbnVwTGlzdGVuZXJSZWYiLCJzZXRQb2ludGVyVHlwZSIsInJlYWN0aXZlIiwic2V0UmVhY3RpdmUiLCJzZXRSZWZlcmVuY2UiLCJzZXRQb3NpdGlvblJlZmVyZW5jZSIsImhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlIiwib3BlbkNoZWNrIiwiYWRkTGlzdGVuZXIiLCJ3aW4iLCJoYW5kbGVNb3VzZU1vdmUiLCJzZXRQb2ludGVyVHlwZVJlZiIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJlIiwiYnViYmxlSGFuZGxlcktleXMiLCJwb2ludGVyZG93biIsIm1vdXNlZG93biIsImNsaWNrIiwiY2FwdHVyZUhhbmRsZXJLZXlzIiwibm9ybWFsaXplQnViYmxlc1Byb3AiLCJidWJibGVzIiwiX2J1YmJsZXMkZXNjYXBlS2V5IiwiX2J1YmJsZXMkb3V0c2lkZVByZXNzIiwiZXNjYXBlS2V5QnViYmxlcyIsImVzY2FwZUtleSIsIm91dHNpZGVQcmVzc0J1YmJsZXMiLCJvdXRzaWRlUHJlc3MiLCJ1c2VEaXNtaXNzIiwidW5zdGFibGVfb3V0c2lkZVByZXNzIiwib3V0c2lkZVByZXNzRXZlbnQiLCJyZWZlcmVuY2VQcmVzcyIsInJlZmVyZW5jZVByZXNzRXZlbnQiLCJhbmNlc3RvclNjcm9sbCIsIm5lc3RlZCIsIm91dHNpZGVQcmVzc0ZuIiwiaW5zaWRlUmVhY3RUcmVlUmVmIiwiY2xvc2VPbkVzY2FwZUtleURvd24iLCJzaG91bGREaXNtaXNzIiwiX2NoaWxkJGNvbnRleHQiLCJfX2VzY2FwZUtleUJ1YmJsZXMiLCJjbG9zZU9uUHJlc3NPdXRzaWRlIiwiaW5zaWRlUmVhY3RUcmVlIiwiY2FuU2Nyb2xsWCIsInNjcm9sbFdpZHRoIiwiY2FuU2Nyb2xsWSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsInhDb25kIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9mZnNldFdpZHRoIiwidGFyZ2V0SXNJbnNpZGVDaGlsZHJlbiIsIl9jaGlsZCRjb250ZXh0MiIsIl9fb3V0c2lkZVByZXNzQnViYmxlcyIsIm9uU2Nyb2xsIiwiYW5jZXN0b3JzIiwiYW5jZXN0b3IiLCJfZG9jJGRlZmF1bHRWaWV3IiwicGFzc2l2ZSIsIl9vcHRpb25zJGVsZW1lbnRzIiwidW5zdGFibGVfb25PcGVuQ2hhbmdlIiwiX2RvbVJlZmVyZW5jZSIsInNldERvbVJlZmVyZW5jZSIsImRvbVJlZmVyZW5jZVJlZiIsImZsb2F0aW5nSWQiLCJwb3NpdGlvblJlZmVyZW5jZSIsInVzZUZvY3VzIiwia2V5Ym9hcmRPbmx5IiwiYmxvY2tGb2N1c1JlZiIsIm9uQmx1ciIsIm1vdmVkVG9Gb2N1c0d1YXJkIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJyZWR1Y2UiLCJhY2MiLCJoYXMiLCJ2YWwiLCJ1c2VJbnRlcmFjdGlvbnMiLCJkZXBzIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwiZ2V0SXRlbVByb3BzIiwiaXRlbSIsImlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCIsIkFSUk9XX1VQIiwiQVJST1dfRE9XTiIsIkFSUk9XX0xFRlQiLCJBUlJPV19SSUdIVCIsImlzRGlmZmVyZW50Um93IiwiY29scyIsInByZXZSb3ciLCJpc0luZGV4T3V0T2ZCb3VuZHMiLCJsaXN0UmVmIiwiZmluZE5vbkRpc2FibGVkSW5kZXgiLCJzdGFydGluZ0luZGV4IiwiZGVjcmVtZW50IiwiZGlzYWJsZWRJbmRpY2VzIiwiYW1vdW50IiwibGlzdCIsIl9saXN0JGluZGV4IiwiX2xpc3QkaW5kZXgyIiwiZG9Td2l0Y2giLCJvcmllbnRhdGlvbiIsInZlcnRpY2FsIiwiaG9yaXpvbnRhbCIsImlzTWFpbk9yaWVudGF0aW9uS2V5IiwiaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleSIsInJ0bCIsImlzQ3Jvc3NPcmllbnRhdGlvbk9wZW5LZXkiLCJpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleSIsImdldE1pbkluZGV4IiwiZ2V0TWF4SW5kZXgiLCJ1c2VMaXN0TmF2aWdhdGlvbiIsIm9uTmF2aWdhdGUiLCJ1bnN0YWJsZV9vbk5hdmlnYXRlIiwic2VsZWN0ZWRJbmRleCIsImFsbG93RXNjYXBlIiwibG9vcCIsInZpcnR1YWwiLCJmb2N1c0l0ZW1Pbk9wZW4iLCJmb2N1c0l0ZW1PbkhvdmVyIiwib3Blbk9uQXJyb3dLZXlEb3duIiwic2Nyb2xsSXRlbUludG9WaWV3IiwiZm9jdXNJdGVtT25PcGVuUmVmIiwiaW5kZXhSZWYiLCJrZXlSZWYiLCJpc1BvaW50ZXJNb2RhbGl0eVJlZiIsInByZXZpb3VzT25OYXZpZ2F0ZVJlZiIsInByZXZpb3VzTW91bnRlZFJlZiIsImZvcmNlU3luY0ZvY3VzIiwiZm9yY2VTY3JvbGxJbnRvVmlld1JlZiIsImRpc2FibGVkSW5kaWNlc1JlZiIsImxhdGVzdE9wZW5SZWYiLCJzY3JvbGxJdGVtSW50b1ZpZXdSZWYiLCJhY3RpdmVJZCIsInNldEFjdGl2ZUlkIiwiZm9jdXNJdGVtIiwiZm9yY2VTY3JvbGxJbnRvVmlldyIsInNjcm9sbEludG9WaWV3T3B0aW9ucyIsInNob3VsZFNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsInJ1bnMiLCJ3YWl0Rm9yTGlzdFBvcHVsYXRlZCIsInNjaGVkdWxlciIsIl9ub2RlcyRmaW5kJGNvbnRleHQiLCJ0cmVlQ29udGFpbnNBY3RpdmVFbCIsImhhc0FjdGl2ZUluZGV4Iiwic3luY0N1cnJlbnRUYXJnZXQiLCJvblBvaW50ZXJMZWF2ZSIsIl9yZWY0IiwiY3VycmVudEluZGV4IiwibWluSW5kZXgiLCJtYXhJbmRleCIsInByZXZJbmRleCIsImNvbCIsIm1heENvbCIsImxhc3RSb3ciLCJtaW4iLCJtYXgiLCJjaGVja1ZpcnR1YWxNb3VzZSIsImNoZWNrVmlydHVhbFBvaW50ZXIiLCJhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AiLCJpc0Fycm93S2V5IiwiaXNOYXZpZ2F0aW9uS2V5IiwidHJpbSIsImlzTWFpbktleSIsImlzQ3Jvc3NLZXkiLCJvblBvaW50ZXJNb3ZlIiwidXNlTWVyZ2VSZWZzIiwiZXZlcnkiLCJ1c2VSb2xlIiwicmVmZXJlbmNlSWQiLCJmbG9hdGluZ1Byb3BzIiwiY2FtZWxDYXNlVG9LZWJhYkNhc2UiLCJzdHIiLCJyZXBsYWNlIiwiJCIsIm9mcyIsImV4ZWNXaXRoQXJnc09yUmV0dXJuIiwidmFsdWVPckZuIiwidXNlRGVsYXlVbm1vdW50IiwiZHVyYXRpb25NcyIsImlzTW91bnRlZCIsInNldElzTW91bnRlZCIsInVzZVRyYW5zaXRpb25TdGF0dXMiLCJkdXJhdGlvbiIsImlzTnVtYmVyRHVyYXRpb24iLCJjbG9zZUR1cmF0aW9uIiwiaW5pdGlhdGVkIiwic2V0SW5pdGlhdGVkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZnJhbWUiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiaW5pdGlhbCIsInVuc3RhYmxlX2luaXRpYWwiLCJvcGFjaXR5IiwidW5zdGFibGVfb3BlbiIsInVuc3RhYmxlX2Nsb3NlIiwiY29tbW9uIiwidW5zdGFibGVfY29tbW9uIiwiZm5BcmdzIiwib3BlbkR1cmF0aW9uIiwic3R5bGVzIiwic2V0U3R5bGVzIiwib3BlblJlZiIsImNsb3NlUmVmIiwiY29tbW9uUmVmIiwiaW5pdGlhbFN0eWxlcyIsImNsb3NlU3R5bGVzIiwiY29tbW9uU3R5bGVzIiwib3BlblN0eWxlcyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwib25UeXBpbmdDaGFuZ2UiLCJ1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSIsImZpbmRNYXRjaCIsInJlc2V0TXMiLCJpZ25vcmVLZXlzIiwidGltZW91dElkUmVmIiwic3RyaW5nUmVmIiwicHJldkluZGV4UmVmIiwibWF0Y2hJbmRleFJlZiIsImZpbmRNYXRjaFJlZiIsImlnbm9yZUtleXNSZWYiLCJzZXRUeXBpbmdDaGFuZ2UiLCJ0eXBpbmciLCJnZXRNYXRjaGluZ0luZGV4Iiwib3JkZXJlZExpc3QiLCJzdHJpbmciLCJ0ZXh0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwiX3RleHQkIiwiX3RleHQkMiIsImdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQiLCJyZWN0cyIsImlubmVyIiwib3ZlcmZsb3dSZWYiLCJvbkZhbGxiYWNrQ2hhbmdlIiwiaW5uZXJPZmZzZXQiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsInNjcm9sbFJlZiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsIm5leHRBcmdzIiwiY2xpZW50VG9wIiwib2Zmc2V0SGVpZ2h0IiwicmVmT3ZlcmZsb3ciLCJlbGVtZW50Q29udGV4dCIsImRpZmZZIiwibmV4dFkiLCJtYXhIZWlnaHQiLCJzY3JvbGxUb3AiLCJ1c2VJbm5lck9mZnNldCIsIm9uQ2hhbmdlIiwidW5zdGFibGVfb25DaGFuZ2UiLCJjb250cm9sbGVkU2Nyb2xsaW5nUmVmIiwicHJldlNjcm9sbFRvcFJlZiIsImluaXRpYWxPdmVyZmxvd1JlZiIsIm9uV2hlZWwiLCJkWSIsImRlbHRhWSIsImlzQXRUb3AiLCJpc0F0Qm90dG9tIiwicmVtYWluaW5nU2Nyb2xsIiwic2lnbiIsIm1ldGhvZCIsInNjcm9sbERpZmYiLCJpc1BvaW50SW5Qb2x5Z29uIiwicG9pbnQiLCJwb2x5Z29uIiwiaXNJbnNpZGUiLCJqIiwieGkiLCJ5aSIsInhqIiwieWoiLCJpbnRlcnNlY3QiLCJyZWN0Iiwic2FmZVBvbHlnb24iLCJidWZmZXIiLCJyZXF1aXJlSW50ZW50IiwiaGFzTGFuZGVkIiwibGFzdFgiLCJsYXN0WSIsImxhc3RDdXJzb3JUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJnZXRDdXJzb3JTcGVlZCIsImN1cnJlbnRUaW1lIiwiZWxhcHNlZFRpbWUiLCJkZWx0YVgiLCJkaXN0YW5jZSIsInNxcnQiLCJzcGVlZCIsImNsaWVudFBvaW50IiwiaXNMZWF2ZSIsImlzT3ZlckZsb2F0aW5nRWwiLCJpc092ZXJSZWZlcmVuY2VFbCIsInJlZlJlY3QiLCJjdXJzb3JMZWF2ZUZyb21SaWdodCIsImN1cnNvckxlYXZlRnJvbUJvdHRvbSIsImlzT3ZlclJlZmVyZW5jZVJlY3QiLCJpc0Zsb2F0aW5nV2lkZXIiLCJpc0Zsb2F0aW5nVGFsbGVyIiwicmVjdFBvbHkiLCJnZXRQb2x5Z29uIiwiY3Vyc29yUG9pbnRPbmUiLCJjdXJzb3JQb2ludFR3byIsImNvbW1vblBvaW50cyIsImN1cnNvclNwZWVkIiwiY3Vyc29yU3BlZWRUaHJlc2hvbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n            continue;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        ...rects.floating,\n        x,\n        y\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$map$so;\n                                const placement = (_overflowsData$map$so = overflowsData.map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        alignmentAxis: null,\n        ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            const { x, y } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: diffCoords\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const overflowAvailableHeight = height - overflow[heightSide];\n            const overflowAvailableWidth = width - overflow[widthSide];\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if (isYAxis) {\n                const maximumClippingWidth = width - overflow.left - overflow.right;\n                availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n            } else {\n                const maximumClippingHeight = height - overflow.top - overflow.bottom;\n                availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtBQUs7WUFDSEksU0FBUztnQkFDUE4sR0FBR1IsVUFBVVEsQ0FBQyxHQUFHUCxTQUFTUSxLQUFLO2dCQUMvQkUsR0FBR0Q7WUFDTDtZQUNBO1FBQ0Y7WUFDRUksU0FBUztnQkFDUE4sR0FBR1IsVUFBVVEsQ0FBQztnQkFDZEcsR0FBR1gsVUFBVVcsQ0FBQztZQUNoQjtJQUNKO0lBQ0EsT0FBUTlCLGdFQUFZQSxDQUFDaUI7UUFDbkIsS0FBSztZQUNIZ0IsTUFBTSxDQUFDWCxjQUFjLElBQUlVLGNBQWVkLENBQUFBLE9BQU9PLGFBQWEsQ0FBQyxJQUFJO1lBQ2pFO1FBQ0YsS0FBSztZQUNIUSxNQUFNLENBQUNYLGNBQWMsSUFBSVUsY0FBZWQsQ0FBQUEsT0FBT08sYUFBYSxDQUFDLElBQUk7WUFDakU7SUFDSjtJQUNBLE9BQU9RO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNQyxrQkFBa0IsT0FBT2YsV0FBV0MsVUFBVWU7SUFDbEQsTUFBTSxFQUNKbEIsWUFBWSxRQUFRLEVBQ3BCbUIsV0FBVyxVQUFVLEVBQ3JCQyxhQUFhLEVBQUUsRUFDZkMsUUFBUSxFQUNULEdBQUdIO0lBQ0osTUFBTUksa0JBQWtCRixXQUFXRyxNQUFNLENBQUNDO0lBQzFDLE1BQU12QixNQUFNLE1BQU9vQixDQUFBQSxTQUFTSSxLQUFLLElBQUksT0FBTyxLQUFLLElBQUlKLFNBQVNJLEtBQUssQ0FBQ3RCLFNBQVE7SUFDNUUsSUFBSXVCLFFBQVEsTUFBTUwsU0FBU00sZUFBZSxDQUFDO1FBQ3pDekI7UUFDQUM7UUFDQWdCO0lBQ0Y7SUFDQSxJQUFJLEVBQ0ZULENBQUMsRUFDREcsQ0FBQyxFQUNGLEdBQUdmLDJCQUEyQjRCLE9BQU8xQixXQUFXQztJQUNqRCxJQUFJMkIsb0JBQW9CNUI7SUFDeEIsSUFBSTZCLGlCQUFpQixDQUFDO0lBQ3RCLElBQUlDLGFBQWE7SUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlULGdCQUFnQlUsTUFBTSxFQUFFRCxJQUFLO1FBQy9DLE1BQU0sRUFDSkUsSUFBSSxFQUNKQyxFQUFFLEVBQ0gsR0FBR1osZUFBZSxDQUFDUyxFQUFFO1FBQ3RCLE1BQU0sRUFDSnJCLEdBQUd5QixLQUFLLEVBQ1J0QixHQUFHdUIsS0FBSyxFQUNSQyxJQUFJLEVBQ0pDLEtBQUssRUFDTixHQUFHLE1BQU1KLEdBQUc7WUFDWHhCO1lBQ0FHO1lBQ0EwQixrQkFBa0J2QztZQUNsQkEsV0FBVzRCO1lBQ1hUO1lBQ0FVO1lBQ0FIO1lBQ0FMO1lBQ0FtQixVQUFVO2dCQUNSdEM7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBTyxJQUFJeUIsU0FBUyxPQUFPQSxRQUFRekI7UUFDNUJHLElBQUl1QixTQUFTLE9BQU9BLFFBQVF2QjtRQUM1QmdCLGlCQUFpQjtZQUNmLEdBQUdBLGNBQWM7WUFDakIsQ0FBQ0ksS0FBSyxFQUFFO2dCQUNOLEdBQUdKLGNBQWMsQ0FBQ0ksS0FBSztnQkFDdkIsR0FBR0ksSUFBSTtZQUNUO1FBQ0Y7UUFDQSxJQUFJQyxTQUFTUixjQUFjLElBQUk7WUFDN0JBO1lBQ0EsSUFBSSxPQUFPUSxVQUFVLFVBQVU7Z0JBQzdCLElBQUlBLE1BQU10QyxTQUFTLEVBQUU7b0JBQ25CNEIsb0JBQW9CVSxNQUFNdEMsU0FBUztnQkFDckM7Z0JBQ0EsSUFBSXNDLE1BQU1aLEtBQUssRUFBRTtvQkFDZkEsUUFBUVksTUFBTVosS0FBSyxLQUFLLE9BQU8sTUFBTUwsU0FBU00sZUFBZSxDQUFDO3dCQUM1RHpCO3dCQUNBQzt3QkFDQWdCO29CQUNGLEtBQUttQixNQUFNWixLQUFLO2dCQUNsQjtnQkFDQyxHQUNDaEIsQ0FBQyxFQUNERyxDQUFDLEVBQ0YsR0FBR2YsMkJBQTJCNEIsT0FBT0UsbUJBQW1CM0IsSUFBRztZQUM5RDtZQUNBOEIsSUFBSSxDQUFDO1lBQ0w7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMckI7UUFDQUc7UUFDQWIsV0FBVzRCO1FBQ1hUO1FBQ0FVO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxlQUFlWSxlQUFlQyxLQUFLLEVBQUVDLE9BQU87SUFDMUMsSUFBSUM7SUFDSixJQUFJRCxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxNQUFNLEVBQ0pqQyxDQUFDLEVBQ0RHLENBQUMsRUFDRFEsUUFBUSxFQUNSSyxLQUFLLEVBQ0xjLFFBQVEsRUFDUnJCLFFBQVEsRUFDVCxHQUFHdUI7SUFDSixNQUFNLEVBQ0pHLFdBQVcsbUJBQW1CLEVBQzlCQyxlQUFlLFVBQVUsRUFDekJDLGlCQUFpQixVQUFVLEVBQzNCQyxjQUFjLEtBQUssRUFDbkJDLFVBQVUsQ0FBQyxFQUNaLEdBQUdqRSw0REFBUUEsQ0FBQzJELFNBQVNEO0lBQ3RCLE1BQU1RLGdCQUFnQmpFLG9FQUFnQkEsQ0FBQ2dFO0lBQ3ZDLE1BQU1FLGFBQWFKLG1CQUFtQixhQUFhLGNBQWM7SUFDakUsTUFBTUssVUFBVVosUUFBUSxDQUFDUSxjQUFjRyxhQUFhSixlQUFlO0lBQ25FLE1BQU1NLHFCQUFxQm5FLG9FQUFnQkEsQ0FBQyxNQUFNbUMsU0FBU2lDLGVBQWUsQ0FBQztRQUN6RUYsU0FBUyxDQUFDLENBQUNSLHdCQUF3QixNQUFPdkIsQ0FBQUEsU0FBU2tDLFNBQVMsSUFBSSxPQUFPLEtBQUssSUFBSWxDLFNBQVNrQyxTQUFTLENBQUNILFFBQU8sQ0FBQyxLQUFNLE9BQU9SLHdCQUF3QixJQUFHLElBQUtRLFVBQVVBLFFBQVFJLGNBQWMsSUFBSyxNQUFPbkMsQ0FBQUEsU0FBU29DLGtCQUFrQixJQUFJLE9BQU8sS0FBSyxJQUFJcEMsU0FBU29DLGtCQUFrQixDQUFDakIsU0FBU3JDLFFBQVE7UUFDaFMwQztRQUNBQztRQUNBM0I7SUFDRjtJQUNBLE1BQU11QyxPQUFPWCxtQkFBbUIsYUFBYTtRQUMzQyxHQUFHckIsTUFBTXZCLFFBQVE7UUFDakJPO1FBQ0FHO0lBQ0YsSUFBSWEsTUFBTXhCLFNBQVM7SUFDbkIsTUFBTXlELGVBQWUsTUFBT3RDLENBQUFBLFNBQVN1QyxlQUFlLElBQUksT0FBTyxLQUFLLElBQUl2QyxTQUFTdUMsZUFBZSxDQUFDcEIsU0FBU3JDLFFBQVE7SUFDbEgsTUFBTTBELGNBQWMsTUFBUXhDLENBQUFBLFNBQVNrQyxTQUFTLElBQUksT0FBTyxLQUFLLElBQUlsQyxTQUFTa0MsU0FBUyxDQUFDSSxhQUFZLElBQU0sTUFBUXRDLENBQUFBLFNBQVN5QyxRQUFRLElBQUksT0FBTyxLQUFLLElBQUl6QyxTQUFTeUMsUUFBUSxDQUFDSCxhQUFZLEtBQU87UUFDdkxqRCxHQUFHO1FBQ0hHLEdBQUc7SUFDTCxJQUFJO1FBQ0ZILEdBQUc7UUFDSEcsR0FBRztJQUNMO0lBQ0EsTUFBTWtELG9CQUFvQjdFLG9FQUFnQkEsQ0FBQ21DLFNBQVMyQyxxREFBcUQsR0FBRyxNQUFNM0MsU0FBUzJDLHFEQUFxRCxDQUFDO1FBQy9LTjtRQUNBQztRQUNBeEM7SUFDRixLQUFLdUM7SUFDTCxPQUFPO1FBQ0xPLEtBQUssQ0FBQ1osbUJBQW1CWSxHQUFHLEdBQUdGLGtCQUFrQkUsR0FBRyxHQUFHZixjQUFjZSxHQUFHLElBQUlKLFlBQVloRCxDQUFDO1FBQ3pGcUQsUUFBUSxDQUFDSCxrQkFBa0JHLE1BQU0sR0FBR2IsbUJBQW1CYSxNQUFNLEdBQUdoQixjQUFjZ0IsTUFBTSxJQUFJTCxZQUFZaEQsQ0FBQztRQUNyR3NELE1BQU0sQ0FBQ2QsbUJBQW1CYyxJQUFJLEdBQUdKLGtCQUFrQkksSUFBSSxHQUFHakIsY0FBY2lCLElBQUksSUFBSU4sWUFBWW5ELENBQUM7UUFDN0YwRCxPQUFPLENBQUNMLGtCQUFrQkssS0FBSyxHQUFHZixtQkFBbUJlLEtBQUssR0FBR2xCLGNBQWNrQixLQUFLLElBQUlQLFlBQVluRCxDQUFDO0lBQ25HO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTTJELFFBQVExQixDQUFBQSxVQUFZO1FBQ3hCVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLE1BQU0sRUFDSmhDLENBQUMsRUFDREcsQ0FBQyxFQUNEYixTQUFTLEVBQ1QwQixLQUFLLEVBQ0xMLFFBQVEsRUFDUm1CLFFBQVEsRUFDUlgsY0FBYyxFQUNmLEdBQUdhO1lBQ0osNERBQTREO1lBQzVELE1BQU0sRUFDSlUsT0FBTyxFQUNQSCxVQUFVLENBQUMsRUFDWixHQUFHakUsNERBQVFBLENBQUMyRCxTQUFTRCxVQUFVLENBQUM7WUFDakMsSUFBSVUsV0FBVyxNQUFNO2dCQUNuQixPQUFPLENBQUM7WUFDVjtZQUNBLE1BQU1GLGdCQUFnQmpFLG9FQUFnQkEsQ0FBQ2dFO1lBQ3ZDLE1BQU1qQyxTQUFTO2dCQUNiTjtnQkFDQUc7WUFDRjtZQUNBLE1BQU15RCxPQUFPMUYsb0VBQWdCQSxDQUFDb0I7WUFDOUIsTUFBTWdDLFNBQVNuRCxpRUFBYUEsQ0FBQ3lGO1lBQzdCLE1BQU1DLGtCQUFrQixNQUFNbEQsU0FBU21ELGFBQWEsQ0FBQ3BCO1lBQ3JELE1BQU1xQixVQUFVSCxTQUFTO1lBQ3pCLE1BQU1JLFVBQVVELFVBQVUsUUFBUTtZQUNsQyxNQUFNRSxVQUFVRixVQUFVLFdBQVc7WUFDckMsTUFBTUcsYUFBYUgsVUFBVSxpQkFBaUI7WUFDOUMsTUFBTUksVUFBVW5ELE1BQU14QixTQUFTLENBQUM4QixPQUFPLEdBQUdOLE1BQU14QixTQUFTLENBQUNvRSxLQUFLLEdBQUd0RCxNQUFNLENBQUNzRCxLQUFLLEdBQUc1QyxNQUFNdkIsUUFBUSxDQUFDNkIsT0FBTztZQUN2RyxNQUFNOEMsWUFBWTlELE1BQU0sQ0FBQ3NELEtBQUssR0FBRzVDLE1BQU14QixTQUFTLENBQUNvRSxLQUFLO1lBQ3RELE1BQU1TLG9CQUFvQixNQUFPMUQsQ0FBQUEsU0FBU3VDLGVBQWUsSUFBSSxPQUFPLEtBQUssSUFBSXZDLFNBQVN1QyxlQUFlLENBQUNSLFFBQU87WUFDN0csSUFBSTRCLGFBQWFELG9CQUFvQkEsaUJBQWlCLENBQUNILFdBQVcsR0FBRztZQUVyRSwwREFBMEQ7WUFDMUQsSUFBSSxDQUFDSSxjQUFjLENBQUUsTUFBTzNELENBQUFBLFNBQVNrQyxTQUFTLElBQUksT0FBTyxLQUFLLElBQUlsQyxTQUFTa0MsU0FBUyxDQUFDd0Isa0JBQWlCLEdBQUs7Z0JBQ3pHQyxhQUFheEMsU0FBU3JDLFFBQVEsQ0FBQ3lFLFdBQVcsSUFBSWxELE1BQU12QixRQUFRLENBQUM2QixPQUFPO1lBQ3RFO1lBQ0EsTUFBTWlELG9CQUFvQkosVUFBVSxJQUFJQyxZQUFZO1lBRXBELDBFQUEwRTtZQUMxRSx1REFBdUQ7WUFDdkQsTUFBTUkseUJBQXlCRixhQUFhLElBQUlULGVBQWUsQ0FBQ3ZDLE9BQU8sR0FBRyxJQUFJO1lBQzlFLE1BQU1tRCxhQUFhaEcsdURBQUdBLENBQUMrRCxhQUFhLENBQUN3QixRQUFRLEVBQUVRO1lBQy9DLE1BQU1FLGFBQWFqRyx1REFBR0EsQ0FBQytELGFBQWEsQ0FBQ3lCLFFBQVEsRUFBRU87WUFFL0MsMEVBQTBFO1lBQzFFLGtEQUFrRDtZQUNsRCxNQUFNRyxRQUFRRjtZQUNkLE1BQU12RixNQUFNb0YsYUFBYVQsZUFBZSxDQUFDdkMsT0FBTyxHQUFHb0Q7WUFDbkQsTUFBTUUsU0FBU04sYUFBYSxJQUFJVCxlQUFlLENBQUN2QyxPQUFPLEdBQUcsSUFBSWlEO1lBQzlELE1BQU1NLFNBQVNuRyx5REFBS0EsQ0FBQ2lHLE9BQU9DLFFBQVExRjtZQUVwQyx5RUFBeUU7WUFDekUseUVBQXlFO1lBQ3pFLHlFQUF5RTtZQUN6RSxpREFBaUQ7WUFDakQsTUFBTTRGLGtCQUFrQixDQUFDM0QsZUFBZXdDLEtBQUssSUFBSXRGLGdFQUFZQSxDQUFDaUIsY0FBYyxRQUFRc0YsVUFBVUMsVUFBVTdELE1BQU14QixTQUFTLENBQUM4QixPQUFPLEdBQUcsSUFBS3NELENBQUFBLFNBQVNELFFBQVFGLGFBQWFDLFVBQVMsSUFBS2IsZUFBZSxDQUFDdkMsT0FBTyxHQUFHLElBQUk7WUFDak4sTUFBTXlELGtCQUFrQkQsa0JBQWtCRixTQUFTRCxRQUFRQyxTQUFTRCxRQUFRQyxTQUFTMUYsTUFBTTtZQUMzRixPQUFPO2dCQUNMLENBQUMwRSxLQUFLLEVBQUV0RCxNQUFNLENBQUNzRCxLQUFLLEdBQUdtQjtnQkFDdkJwRCxNQUFNO29CQUNKLENBQUNpQyxLQUFLLEVBQUVpQjtvQkFDUkcsY0FBY0osU0FBU0MsU0FBU0U7b0JBQ2hDLEdBQUlELG1CQUFtQjt3QkFDckJDO29CQUNGLENBQUM7Z0JBQ0g7Z0JBQ0FuRCxPQUFPa0Q7WUFDVDtRQUNGO0lBQ0Y7QUFFQSxTQUFTRyxpQkFBaUJDLFNBQVMsRUFBRUMsYUFBYSxFQUFFQyxpQkFBaUI7SUFDbkUsTUFBTUMscUNBQXFDSCxZQUFZO1dBQUlFLGtCQUFrQnZFLE1BQU0sQ0FBQ3ZCLENBQUFBLFlBQWFqQixnRUFBWUEsQ0FBQ2lCLGVBQWU0RjtXQUFlRSxrQkFBa0J2RSxNQUFNLENBQUN2QixDQUFBQSxZQUFhakIsZ0VBQVlBLENBQUNpQixlQUFlNEY7S0FBVyxHQUFHRSxrQkFBa0J2RSxNQUFNLENBQUN2QixDQUFBQSxZQUFhbEIsMkRBQU9BLENBQUNrQixlQUFlQTtJQUN6UixPQUFPK0YsbUNBQW1DeEUsTUFBTSxDQUFDdkIsQ0FBQUE7UUFDL0MsSUFBSTRGLFdBQVc7WUFDYixPQUFPN0csZ0VBQVlBLENBQUNpQixlQUFlNEYsYUFBY0MsQ0FBQUEsZ0JBQWdCdEcsaUZBQTZCQSxDQUFDUyxlQUFlQSxZQUFZLEtBQUk7UUFDaEk7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBOzs7OztDQUtDLEdBQ0QsTUFBTWdHLGdCQUFnQixTQUFVckQsT0FBTztJQUNyQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0xWLE1BQU07UUFDTlU7UUFDQSxNQUFNVCxJQUFHUSxLQUFLO1lBQ1osSUFBSXVELHVCQUF1QkMsd0JBQXdCQztZQUNuRCxNQUFNLEVBQ0p6RSxLQUFLLEVBQ0xHLGNBQWMsRUFDZDdCLFNBQVMsRUFDVHFCLFFBQVEsRUFDUm1CLFFBQVEsRUFDVCxHQUFHRTtZQUNKLE1BQU0sRUFDSjBELFlBQVksS0FBSyxFQUNqQlIsU0FBUyxFQUNURSxvQkFBb0J6RywwREFBVSxFQUM5QndHLGdCQUFnQixJQUFJLEVBQ3BCLEdBQUdRLHVCQUNKLEdBQUdySCw0REFBUUEsQ0FBQzJELFNBQVNEO1lBQ3RCLE1BQU00RCxlQUFlVixjQUFjVyxhQUFhVCxzQkFBc0J6RywwREFBVUEsR0FBR3NHLGlCQUFpQkMsYUFBYSxNQUFNQyxlQUFlQyxxQkFBcUJBO1lBQzNKLE1BQU1VLFdBQVcsTUFBTS9ELGVBQWVDLE9BQU8yRDtZQUM3QyxNQUFNSSxlQUFlLENBQUMsQ0FBQ1Isd0JBQXdCcEUsZUFBZW1FLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSUMsc0JBQXNCUyxLQUFLLEtBQUs7WUFDaEksTUFBTUMsbUJBQW1CTCxZQUFZLENBQUNHLGFBQWE7WUFDbkQsSUFBSUUsb0JBQW9CLE1BQU07Z0JBQzVCLE9BQU8sQ0FBQztZQUNWO1lBQ0EsTUFBTUMsaUJBQWlCdEgscUVBQWlCQSxDQUFDcUgsa0JBQWtCakYsT0FBTyxNQUFPTCxDQUFBQSxTQUFTSSxLQUFLLElBQUksT0FBTyxLQUFLLElBQUlKLFNBQVNJLEtBQUssQ0FBQ2UsU0FBU3JDLFFBQVE7WUFFM0ksbURBQW1EO1lBQ25ELElBQUlILGNBQWMyRyxrQkFBa0I7Z0JBQ2xDLE9BQU87b0JBQ0xyRSxPQUFPO3dCQUNMdEMsV0FBV3NHLFlBQVksQ0FBQyxFQUFFO29CQUM1QjtnQkFDRjtZQUNGO1lBQ0EsTUFBTU8sbUJBQW1CO2dCQUFDTCxRQUFRLENBQUMxSCwyREFBT0EsQ0FBQzZILGtCQUFrQjtnQkFBRUgsUUFBUSxDQUFDSSxjQUFjLENBQUMsRUFBRSxDQUFDO2dCQUFFSixRQUFRLENBQUNJLGNBQWMsQ0FBQyxFQUFFLENBQUM7YUFBQztZQUN4SCxNQUFNRSxlQUFlO21CQUFLLENBQUMsQ0FBQ1oseUJBQXlCckUsZUFBZW1FLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSUUsdUJBQXVCYSxTQUFTLEtBQUssRUFBRTtnQkFBRztvQkFDOUkvRyxXQUFXMkc7b0JBQ1hJLFdBQVdGO2dCQUNiO2FBQUU7WUFDRixNQUFNRyxnQkFBZ0JWLFlBQVksQ0FBQ0csZUFBZSxFQUFFO1lBRXBELHNDQUFzQztZQUN0QyxJQUFJTyxlQUFlO2dCQUNqQixPQUFPO29CQUNMM0UsTUFBTTt3QkFDSnFFLE9BQU9ELGVBQWU7d0JBQ3RCTSxXQUFXRDtvQkFDYjtvQkFDQXhFLE9BQU87d0JBQ0x0QyxXQUFXZ0g7b0JBQ2I7Z0JBQ0Y7WUFDRjtZQUNBLE1BQU1DLDhCQUE4QkgsYUFBYUksR0FBRyxDQUFDQyxDQUFBQTtnQkFDbkQsTUFBTXZCLFlBQVk3RyxnRUFBWUEsQ0FBQ29JLEVBQUVuSCxTQUFTO2dCQUMxQyxPQUFPO29CQUFDbUgsRUFBRW5ILFNBQVM7b0JBQUU0RixhQUFhUSxZQUNsQyxvREFBb0Q7b0JBQ3BEZSxFQUFFSixTQUFTLENBQUNLLEtBQUssQ0FBQyxHQUFHLEdBQUdDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxJQUFNRCxNQUFNQyxHQUFHLEtBQ3BELDJCQUEyQjtvQkFDM0JKLEVBQUVKLFNBQVMsQ0FBQyxFQUFFO29CQUFFSSxFQUFFSixTQUFTO2lCQUFDO1lBQzlCLEdBQUdTLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRTtZQUM3QixNQUFNQyw4QkFBOEJWLDRCQUE0QjFGLE1BQU0sQ0FBQzRGLENBQUFBLElBQUtBLENBQUMsQ0FBQyxFQUFFLENBQUNDLEtBQUssQ0FBQyxHQUN2RiwrREFBK0Q7Z0JBQy9ELFFBQVE7Z0JBQ1JySSxnRUFBWUEsQ0FBQ29JLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSSxHQUFHUyxLQUFLLENBQUNMLENBQUFBLElBQUtBLEtBQUs7WUFDNUMsTUFBTU0saUJBQWlCLENBQUMsQ0FBQzFCLHdCQUF3QndCLDJCQUEyQixDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSXhCLHFCQUFxQixDQUFDLEVBQUUsS0FBS2MsMkJBQTJCLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDbEssSUFBSVksbUJBQW1CN0gsV0FBVztnQkFDaEMsT0FBTztvQkFDTHFDLE1BQU07d0JBQ0pxRSxPQUFPRCxlQUFlO3dCQUN0Qk0sV0FBV0Q7b0JBQ2I7b0JBQ0F4RSxPQUFPO3dCQUNMdEMsV0FBVzZIO29CQUNiO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLE9BQU8sU0FBVW5GLE9BQU87SUFDNUIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLElBQUlxRix1QkFBdUJDO1lBQzNCLE1BQU0sRUFDSmhJLFNBQVMsRUFDVDZCLGNBQWMsRUFDZEgsS0FBSyxFQUNMYSxnQkFBZ0IsRUFDaEJsQixRQUFRLEVBQ1JtQixRQUFRLEVBQ1QsR0FBR0U7WUFDSixNQUFNLEVBQ0p1RixVQUFVQyxnQkFBZ0IsSUFBSSxFQUM5QjlCLFdBQVcrQixpQkFBaUIsSUFBSSxFQUNoQ0Msb0JBQW9CQywyQkFBMkIsRUFDL0NDLG1CQUFtQixTQUFTLEVBQzVCQyw0QkFBNEIsTUFBTSxFQUNsQ0MsZ0JBQWdCLElBQUksRUFDcEIsR0FBR25DLHVCQUNKLEdBQUdySCw0REFBUUEsQ0FBQzJELFNBQVNEO1lBRXRCLHNFQUFzRTtZQUN0RSwwRUFBMEU7WUFDMUUsUUFBUTtZQUNSLGlGQUFpRjtZQUNqRixJQUFJLENBQUNxRix3QkFBd0JsRyxlQUFld0MsS0FBSyxLQUFLLFFBQVEwRCxzQkFBc0J0QyxlQUFlLEVBQUU7Z0JBQ25HLE9BQU8sQ0FBQztZQUNWO1lBQ0EsTUFBTWxGLE9BQU96QiwyREFBT0EsQ0FBQ2tCO1lBQ3JCLE1BQU15SSxrQkFBa0IzSiwyREFBT0EsQ0FBQ3lELHNCQUFzQkE7WUFDdEQsTUFBTXRDLE1BQU0sTUFBT29CLENBQUFBLFNBQVNJLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSUosU0FBU0ksS0FBSyxDQUFDZSxTQUFTckMsUUFBUTtZQUNyRixNQUFNaUkscUJBQXFCQywrQkFBZ0NJLENBQUFBLG1CQUFtQixDQUFDRCxnQkFBZ0I7Z0JBQUNoSix3RUFBb0JBLENBQUMrQzthQUFrQixHQUFHOUMseUVBQXFCQSxDQUFDOEMsaUJBQWdCO1lBQ2hMLElBQUksQ0FBQzhGLCtCQUErQkUsOEJBQThCLFFBQVE7Z0JBQ3hFSCxtQkFBbUJNLElBQUksSUFBSWhKLDZFQUF5QkEsQ0FBQzZDLGtCQUFrQmlHLGVBQWVELDJCQUEyQnRJO1lBQ25IO1lBQ0EsTUFBTVosYUFBYTtnQkFBQ2tEO21CQUFxQjZGO2FBQW1CO1lBQzVELE1BQU01QixXQUFXLE1BQU0vRCxlQUFlQyxPQUFPMkQ7WUFDN0MsTUFBTVUsWUFBWSxFQUFFO1lBQ3BCLElBQUk0QixnQkFBZ0IsQ0FBQyxDQUFDWCx1QkFBdUJuRyxlQUFlaUcsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJRSxxQkFBcUJqQixTQUFTLEtBQUssRUFBRTtZQUMxSCxJQUFJbUIsZUFBZTtnQkFDakJuQixVQUFVMkIsSUFBSSxDQUFDbEMsUUFBUSxDQUFDakcsS0FBSztZQUMvQjtZQUNBLElBQUk0SCxnQkFBZ0I7Z0JBQ2xCLE1BQU14SSxRQUFRTCxxRUFBaUJBLENBQUNVLFdBQVcwQixPQUFPekI7Z0JBQ2xEOEcsVUFBVTJCLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQzdHLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTZHLFFBQVEsQ0FBQzdHLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDdkQ7WUFDQWdKLGdCQUFnQjttQkFBSUE7Z0JBQWU7b0JBQ2pDM0k7b0JBQ0ErRztnQkFDRjthQUFFO1lBRUYsb0NBQW9DO1lBQ3BDLElBQUksQ0FBQ0EsVUFBVWEsS0FBSyxDQUFDckgsQ0FBQUEsT0FBUUEsUUFBUSxJQUFJO2dCQUN2QyxJQUFJcUksdUJBQXVCQztnQkFDM0IsTUFBTUMsWUFBWSxDQUFDLENBQUMsQ0FBQ0Ysd0JBQXdCL0csZUFBZWlHLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSWMsc0JBQXNCbEMsS0FBSyxLQUFLLEtBQUs7Z0JBQzFILE1BQU1NLGdCQUFnQjNILFVBQVUsQ0FBQ3lKLFVBQVU7Z0JBQzNDLElBQUk5QixlQUFlO29CQUNqQiwrQ0FBK0M7b0JBQy9DLE9BQU87d0JBQ0wzRSxNQUFNOzRCQUNKcUUsT0FBT29DOzRCQUNQL0IsV0FBVzRCO3dCQUNiO3dCQUNBckcsT0FBTzs0QkFDTHRDLFdBQVdnSDt3QkFDYjtvQkFDRjtnQkFDRjtnQkFFQSx3RUFBd0U7Z0JBQ3hFLHlFQUF5RTtnQkFDekUsSUFBSWEsaUJBQWlCLENBQUNnQix3QkFBd0JGLGNBQWNwSCxNQUFNLENBQUM0RixDQUFBQSxJQUFLQSxFQUFFSixTQUFTLENBQUMsRUFBRSxJQUFJLEdBQUdTLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFVixTQUFTLENBQUMsRUFBRSxHQUFHVyxFQUFFWCxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJOEIsc0JBQXNCN0ksU0FBUztnQkFFbk0sc0JBQXNCO2dCQUN0QixJQUFJLENBQUM2SCxnQkFBZ0I7b0JBQ25CLE9BQVFTO3dCQUNOLEtBQUs7NEJBQ0g7Z0NBQ0UsSUFBSVM7Z0NBQ0osTUFBTS9JLFlBQVksQ0FBQytJLHdCQUF3QkosY0FBY3pCLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSzt3Q0FBQ0EsRUFBRW5ILFNBQVM7d0NBQUVtSCxFQUFFSixTQUFTLENBQUN4RixNQUFNLENBQUNpRixDQUFBQSxXQUFZQSxXQUFXLEdBQUdhLE1BQU0sQ0FBQyxDQUFDQyxLQUFLZCxXQUFhYyxNQUFNZCxVQUFVO3FDQUFHLEVBQUVnQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSXFCLHFCQUFxQixDQUFDLEVBQUU7Z0NBQ3ZQLElBQUkvSSxXQUFXO29DQUNiNkgsaUJBQWlCN0g7Z0NBQ25CO2dDQUNBOzRCQUNGO3dCQUNGLEtBQUs7NEJBQ0g2SCxpQkFBaUJ0Rjs0QkFDakI7b0JBQ0o7Z0JBQ0Y7Z0JBQ0EsSUFBSXZDLGNBQWM2SCxnQkFBZ0I7b0JBQ2hDLE9BQU87d0JBQ0x2RixPQUFPOzRCQUNMdEMsV0FBVzZIO3dCQUNiO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxTQUFTbUIsZUFBZXhDLFFBQVEsRUFBRTlDLElBQUk7SUFDcEMsT0FBTztRQUNMTyxLQUFLdUMsU0FBU3ZDLEdBQUcsR0FBR1AsS0FBSzVDLE1BQU07UUFDL0JzRCxPQUFPb0MsU0FBU3BDLEtBQUssR0FBR1YsS0FBSy9DLEtBQUs7UUFDbEN1RCxRQUFRc0MsU0FBU3RDLE1BQU0sR0FBR1IsS0FBSzVDLE1BQU07UUFDckNxRCxNQUFNcUMsU0FBU3JDLElBQUksR0FBR1QsS0FBSy9DLEtBQUs7SUFDbEM7QUFDRjtBQUNBLFNBQVNzSSxzQkFBc0J6QyxRQUFRO0lBQ3JDLE9BQU83RyxxREFBS0EsQ0FBQ3VKLElBQUksQ0FBQzNJLENBQUFBLE9BQVFpRyxRQUFRLENBQUNqRyxLQUFLLElBQUk7QUFDOUM7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTTRJLE9BQU8sU0FBVXhHLE9BQU87SUFDNUIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLE1BQU0sRUFDSmhCLEtBQUssRUFDTixHQUFHZ0I7WUFDSixNQUFNLEVBQ0p2QixXQUFXLGlCQUFpQixFQUM1QixHQUFHa0YsdUJBQ0osR0FBR3JILDREQUFRQSxDQUFDMkQsU0FBU0Q7WUFDdEIsT0FBUXZCO2dCQUNOLEtBQUs7b0JBQ0g7d0JBQ0UsTUFBTXFGLFdBQVcsTUFBTS9ELGVBQWVDLE9BQU87NEJBQzNDLEdBQUcyRCxxQkFBcUI7NEJBQ3hCdEQsZ0JBQWdCO3dCQUNsQjt3QkFDQSxNQUFNcUcsVUFBVUosZUFBZXhDLFVBQVU5RSxNQUFNeEIsU0FBUzt3QkFDeEQsT0FBTzs0QkFDTG1DLE1BQU07Z0NBQ0pnSCx3QkFBd0JEO2dDQUN4QkUsaUJBQWlCTCxzQkFBc0JHOzRCQUN6Qzt3QkFDRjtvQkFDRjtnQkFDRixLQUFLO29CQUNIO3dCQUNFLE1BQU01QyxXQUFXLE1BQU0vRCxlQUFlQyxPQUFPOzRCQUMzQyxHQUFHMkQscUJBQXFCOzRCQUN4QnJELGFBQWE7d0JBQ2Y7d0JBQ0EsTUFBTW9HLFVBQVVKLGVBQWV4QyxVQUFVOUUsTUFBTXZCLFFBQVE7d0JBQ3ZELE9BQU87NEJBQ0xrQyxNQUFNO2dDQUNKa0gsZ0JBQWdCSDtnQ0FDaEJJLFNBQVNQLHNCQUFzQkc7NEJBQ2pDO3dCQUNGO29CQUNGO2dCQUNGO29CQUNFO3dCQUNFLE9BQU8sQ0FBQztvQkFDVjtZQUNKO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBU0ssZ0JBQWdCL0gsS0FBSztJQUM1QixNQUFNZ0ksT0FBT3ZLLHVEQUFHQSxJQUFJdUMsTUFBTXdGLEdBQUcsQ0FBQ3hELENBQUFBLE9BQVFBLEtBQUtTLElBQUk7SUFDL0MsTUFBTXdGLE9BQU94Syx1REFBR0EsSUFBSXVDLE1BQU13RixHQUFHLENBQUN4RCxDQUFBQSxPQUFRQSxLQUFLTyxHQUFHO0lBQzlDLE1BQU0yRixPQUFPaEssdURBQUdBLElBQUk4QixNQUFNd0YsR0FBRyxDQUFDeEQsQ0FBQUEsT0FBUUEsS0FBS1UsS0FBSztJQUNoRCxNQUFNeUYsT0FBT2pLLHVEQUFHQSxJQUFJOEIsTUFBTXdGLEdBQUcsQ0FBQ3hELENBQUFBLE9BQVFBLEtBQUtRLE1BQU07SUFDakQsT0FBTztRQUNMeEQsR0FBR2dKO1FBQ0g3SSxHQUFHOEk7UUFDSGhKLE9BQU9pSixPQUFPRjtRQUNkNUksUUFBUStJLE9BQU9GO0lBQ2pCO0FBQ0Y7QUFDQSxTQUFTRyxlQUFlcEksS0FBSztJQUMzQixNQUFNcUksY0FBY3JJLE1BQU0wRixLQUFLLEdBQUdJLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFNUcsQ0FBQyxHQUFHNkcsRUFBRTdHLENBQUM7SUFDMUQsTUFBTW1KLFNBQVMsRUFBRTtJQUNqQixJQUFJQyxXQUFXO0lBQ2YsSUFBSyxJQUFJbEksSUFBSSxHQUFHQSxJQUFJZ0ksWUFBWS9ILE1BQU0sRUFBRUQsSUFBSztRQUMzQyxNQUFNMkIsT0FBT3FHLFdBQVcsQ0FBQ2hJLEVBQUU7UUFDM0IsSUFBSSxDQUFDa0ksWUFBWXZHLEtBQUs3QyxDQUFDLEdBQUdvSixTQUFTcEosQ0FBQyxHQUFHb0osU0FBU25KLE1BQU0sR0FBRyxHQUFHO1lBQzFEa0osT0FBT3RCLElBQUksQ0FBQztnQkFBQ2hGO2FBQUs7UUFDcEIsT0FBTztZQUNMc0csTUFBTSxDQUFDQSxPQUFPaEksTUFBTSxHQUFHLEVBQUUsQ0FBQzBHLElBQUksQ0FBQ2hGO1FBQ2pDO1FBQ0F1RyxXQUFXdkc7SUFDYjtJQUNBLE9BQU9zRyxPQUFPOUMsR0FBRyxDQUFDeEQsQ0FBQUEsT0FBUXhFLG9FQUFnQkEsQ0FBQ3VLLGdCQUFnQi9GO0FBQzdEO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU13RyxTQUFTLFNBQVV2SCxPQUFPO0lBQzlCLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLE9BQU87UUFDTFYsTUFBTTtRQUNOVTtRQUNBLE1BQU1ULElBQUdRLEtBQUs7WUFDWixNQUFNLEVBQ0oxQyxTQUFTLEVBQ1R3QyxRQUFRLEVBQ1JkLEtBQUssRUFDTEwsUUFBUSxFQUNSRixRQUFRLEVBQ1QsR0FBR3VCO1lBQ0osZ0VBQWdFO1lBQ2hFLHFFQUFxRTtZQUNyRSwyQ0FBMkM7WUFDM0MsTUFBTSxFQUNKTyxVQUFVLENBQUMsRUFDWHZDLENBQUMsRUFDREcsQ0FBQyxFQUNGLEdBQUc3Qiw0REFBUUEsQ0FBQzJELFNBQVNEO1lBQ3RCLE1BQU15SCxvQkFBb0JDLE1BQU1DLElBQUksQ0FBQyxNQUFRaEosQ0FBQUEsU0FBU2lKLGNBQWMsSUFBSSxPQUFPLEtBQUssSUFBSWpKLFNBQVNpSixjQUFjLENBQUM5SCxTQUFTdEMsU0FBUyxNQUFPLEVBQUU7WUFDM0ksTUFBTXFLLGNBQWNULGVBQWVLO1lBQ25DLE1BQU1LLFdBQVd0TCxvRUFBZ0JBLENBQUN1SyxnQkFBZ0JVO1lBQ2xELE1BQU1qSCxnQkFBZ0JqRSxvRUFBZ0JBLENBQUNnRTtZQUN2QyxTQUFTd0g7Z0JBQ1AsOENBQThDO2dCQUM5QyxJQUFJRixZQUFZdkksTUFBTSxLQUFLLEtBQUt1SSxXQUFXLENBQUMsRUFBRSxDQUFDcEcsSUFBSSxHQUFHb0csV0FBVyxDQUFDLEVBQUUsQ0FBQ25HLEtBQUssSUFBSTFELEtBQUssUUFBUUcsS0FBSyxNQUFNO29CQUNwRywwREFBMEQ7b0JBQzFELE9BQU8wSixZQUFZRyxJQUFJLENBQUNoSCxDQUFBQSxPQUFRaEQsSUFBSWdELEtBQUtTLElBQUksR0FBR2pCLGNBQWNpQixJQUFJLElBQUl6RCxJQUFJZ0QsS0FBS1UsS0FBSyxHQUFHbEIsY0FBY2tCLEtBQUssSUFBSXZELElBQUk2QyxLQUFLTyxHQUFHLEdBQUdmLGNBQWNlLEdBQUcsSUFBSXBELElBQUk2QyxLQUFLUSxNQUFNLEdBQUdoQixjQUFjZ0IsTUFBTSxLQUFLc0c7Z0JBQy9MO2dCQUVBLHVDQUF1QztnQkFDdkMsSUFBSUQsWUFBWXZJLE1BQU0sSUFBSSxHQUFHO29CQUMzQixJQUFJckQsK0RBQVdBLENBQUNxQixlQUFlLEtBQUs7d0JBQ2xDLE1BQU0ySyxZQUFZSixXQUFXLENBQUMsRUFBRTt3QkFDaEMsTUFBTUssV0FBV0wsV0FBVyxDQUFDQSxZQUFZdkksTUFBTSxHQUFHLEVBQUU7d0JBQ3BELE1BQU02SSxRQUFRL0wsMkRBQU9BLENBQUNrQixlQUFlO3dCQUNyQyxNQUFNaUUsTUFBTTBHLFVBQVUxRyxHQUFHO3dCQUN6QixNQUFNQyxTQUFTMEcsU0FBUzFHLE1BQU07d0JBQzlCLE1BQU1DLE9BQU8wRyxRQUFRRixVQUFVeEcsSUFBSSxHQUFHeUcsU0FBU3pHLElBQUk7d0JBQ25ELE1BQU1DLFFBQVF5RyxRQUFRRixVQUFVdkcsS0FBSyxHQUFHd0csU0FBU3hHLEtBQUs7d0JBQ3RELE1BQU16RCxRQUFReUQsUUFBUUQ7d0JBQ3RCLE1BQU1yRCxTQUFTb0QsU0FBU0Q7d0JBQ3hCLE9BQU87NEJBQ0xBOzRCQUNBQzs0QkFDQUM7NEJBQ0FDOzRCQUNBekQ7NEJBQ0FHOzRCQUNBSixHQUFHeUQ7NEJBQ0h0RCxHQUFHb0Q7d0JBQ0w7b0JBQ0Y7b0JBQ0EsTUFBTTZHLGFBQWFoTSwyREFBT0EsQ0FBQ2tCLGVBQWU7b0JBQzFDLE1BQU0rSyxXQUFXbkwsdURBQUdBLElBQUkySyxZQUFZckQsR0FBRyxDQUFDeEQsQ0FBQUEsT0FBUUEsS0FBS1UsS0FBSztvQkFDMUQsTUFBTTRHLFVBQVU3TCx1REFBR0EsSUFBSW9MLFlBQVlyRCxHQUFHLENBQUN4RCxDQUFBQSxPQUFRQSxLQUFLUyxJQUFJO29CQUN4RCxNQUFNOEcsZUFBZVYsWUFBWWhKLE1BQU0sQ0FBQ21DLENBQUFBLE9BQVFvSCxhQUFhcEgsS0FBS1MsSUFBSSxLQUFLNkcsVUFBVXRILEtBQUtVLEtBQUssS0FBSzJHO29CQUNwRyxNQUFNOUcsTUFBTWdILFlBQVksQ0FBQyxFQUFFLENBQUNoSCxHQUFHO29CQUMvQixNQUFNQyxTQUFTK0csWUFBWSxDQUFDQSxhQUFhakosTUFBTSxHQUFHLEVBQUUsQ0FBQ2tDLE1BQU07b0JBQzNELE1BQU1DLE9BQU82RztvQkFDYixNQUFNNUcsUUFBUTJHO29CQUNkLE1BQU1wSyxRQUFReUQsUUFBUUQ7b0JBQ3RCLE1BQU1yRCxTQUFTb0QsU0FBU0Q7b0JBQ3hCLE9BQU87d0JBQ0xBO3dCQUNBQzt3QkFDQUM7d0JBQ0FDO3dCQUNBekQ7d0JBQ0FHO3dCQUNBSixHQUFHeUQ7d0JBQ0h0RCxHQUFHb0Q7b0JBQ0w7Z0JBQ0Y7Z0JBQ0EsT0FBT3VHO1lBQ1Q7WUFDQSxNQUFNVSxhQUFhLE1BQU03SixTQUFTTSxlQUFlLENBQUM7Z0JBQ2hEekIsV0FBVztvQkFDVHVLO2dCQUNGO2dCQUNBdEssVUFBVXFDLFNBQVNyQyxRQUFRO2dCQUMzQmdCO1lBQ0Y7WUFDQSxJQUFJTyxNQUFNeEIsU0FBUyxDQUFDUSxDQUFDLEtBQUt3SyxXQUFXaEwsU0FBUyxDQUFDUSxDQUFDLElBQUlnQixNQUFNeEIsU0FBUyxDQUFDVyxDQUFDLEtBQUtxSyxXQUFXaEwsU0FBUyxDQUFDVyxDQUFDLElBQUlhLE1BQU14QixTQUFTLENBQUNTLEtBQUssS0FBS3VLLFdBQVdoTCxTQUFTLENBQUNTLEtBQUssSUFBSWUsTUFBTXhCLFNBQVMsQ0FBQ1ksTUFBTSxLQUFLb0ssV0FBV2hMLFNBQVMsQ0FBQ1ksTUFBTSxFQUFFO2dCQUNsTixPQUFPO29CQUNMd0IsT0FBTzt3QkFDTFosT0FBT3dKO29CQUNUO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxzRUFBc0U7QUFDdEUsYUFBYTtBQUNiLGVBQWVDLHFCQUFxQnpJLEtBQUssRUFBRUMsT0FBTztJQUNoRCxNQUFNLEVBQ0ozQyxTQUFTLEVBQ1RxQixRQUFRLEVBQ1JtQixRQUFRLEVBQ1QsR0FBR0U7SUFDSixNQUFNekMsTUFBTSxNQUFPb0IsQ0FBQUEsU0FBU0ksS0FBSyxJQUFJLE9BQU8sS0FBSyxJQUFJSixTQUFTSSxLQUFLLENBQUNlLFNBQVNyQyxRQUFRO0lBQ3JGLE1BQU1JLE9BQU96QiwyREFBT0EsQ0FBQ2tCO0lBQ3JCLE1BQU00RixZQUFZN0csZ0VBQVlBLENBQUNpQjtJQUMvQixNQUFNUSxhQUFhN0IsK0RBQVdBLENBQUNxQixlQUFlO0lBQzlDLE1BQU1vTCxnQkFBZ0I7UUFBQztRQUFRO0tBQU0sQ0FBQ0MsUUFBUSxDQUFDOUssUUFBUSxDQUFDLElBQUk7SUFDNUQsTUFBTStLLGlCQUFpQnJMLE9BQU9PLGFBQWEsQ0FBQyxJQUFJO0lBQ2hELE1BQU0rSyxXQUFXdk0sNERBQVFBLENBQUMyRCxTQUFTRDtJQUVuQyx3Q0FBd0M7SUFDeEMsSUFBSSxFQUNGdUYsUUFBUSxFQUNSN0IsU0FBUyxFQUNUL0YsYUFBYSxFQUNkLEdBQUcsT0FBT2tMLGFBQWEsV0FBVztRQUNqQ3RELFVBQVVzRDtRQUNWbkYsV0FBVztRQUNYL0YsZUFBZTtJQUNqQixJQUFJO1FBQ0Y0SCxVQUFVO1FBQ1Y3QixXQUFXO1FBQ1gvRixlQUFlO1FBQ2YsR0FBR2tMLFFBQVE7SUFDYjtJQUNBLElBQUkzRixhQUFhLE9BQU92RixrQkFBa0IsVUFBVTtRQUNsRCtGLFlBQVlSLGNBQWMsUUFBUXZGLGdCQUFnQixDQUFDLElBQUlBO0lBQ3pEO0lBQ0EsT0FBT0csYUFBYTtRQUNsQkUsR0FBRzBGLFlBQVlrRjtRQUNmekssR0FBR29ILFdBQVdtRDtJQUNoQixJQUFJO1FBQ0YxSyxHQUFHdUgsV0FBV21EO1FBQ2R2SyxHQUFHdUYsWUFBWWtGO0lBQ2pCO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNL0YsU0FBUyxTQUFVNUMsT0FBTztJQUM5QixJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVTtJQUNaO0lBQ0EsT0FBTztRQUNMVixNQUFNO1FBQ05VO1FBQ0EsTUFBTVQsSUFBR1EsS0FBSztZQUNaLE1BQU0sRUFDSmhDLENBQUMsRUFDREcsQ0FBQyxFQUNGLEdBQUc2QjtZQUNKLE1BQU04SSxhQUFhLE1BQU1MLHFCQUFxQnpJLE9BQU9DO1lBQ3JELE9BQU87Z0JBQ0xqQyxHQUFHQSxJQUFJOEssV0FBVzlLLENBQUM7Z0JBQ25CRyxHQUFHQSxJQUFJMkssV0FBVzNLLENBQUM7Z0JBQ25Cd0IsTUFBTW1KO1lBQ1I7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsUUFBUSxTQUFVOUksT0FBTztJQUM3QixJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0xWLE1BQU07UUFDTlU7UUFDQSxNQUFNVCxJQUFHUSxLQUFLO1lBQ1osTUFBTSxFQUNKaEMsQ0FBQyxFQUNERyxDQUFDLEVBQ0RiLFNBQVMsRUFDVixHQUFHMEM7WUFDSixNQUFNLEVBQ0p1RixVQUFVQyxnQkFBZ0IsSUFBSSxFQUM5QjlCLFdBQVcrQixpQkFBaUIsS0FBSyxFQUNqQ3VELFVBQVU7Z0JBQ1J4SixJQUFJbkMsQ0FBQUE7b0JBQ0YsSUFBSSxFQUNGVyxDQUFDLEVBQ0RHLENBQUMsRUFDRixHQUFHZDtvQkFDSixPQUFPO3dCQUNMVzt3QkFDQUc7b0JBQ0Y7Z0JBQ0Y7WUFDRixDQUFDLEVBQ0QsR0FBR3dGLHVCQUNKLEdBQUdySCw0REFBUUEsQ0FBQzJELFNBQVNEO1lBQ3RCLE1BQU0xQixTQUFTO2dCQUNiTjtnQkFDQUc7WUFDRjtZQUNBLE1BQU0yRixXQUFXLE1BQU0vRCxlQUFlQyxPQUFPMkQ7WUFDN0MsTUFBTUQsWUFBWXpILCtEQUFXQSxDQUFDRywyREFBT0EsQ0FBQ2tCO1lBQ3RDLE1BQU1pSSxXQUFXcEksbUVBQWVBLENBQUN1RztZQUNqQyxJQUFJdUYsZ0JBQWdCM0ssTUFBTSxDQUFDaUgsU0FBUztZQUNwQyxJQUFJMkQsaUJBQWlCNUssTUFBTSxDQUFDb0YsVUFBVTtZQUN0QyxJQUFJOEIsZUFBZTtnQkFDakIsTUFBTTJELFVBQVU1RCxhQUFhLE1BQU0sUUFBUTtnQkFDM0MsTUFBTTZELFVBQVU3RCxhQUFhLE1BQU0sV0FBVztnQkFDOUMsTUFBTTlJLE1BQU13TSxnQkFBZ0JuRixRQUFRLENBQUNxRixRQUFRO2dCQUM3QyxNQUFNak0sTUFBTStMLGdCQUFnQm5GLFFBQVEsQ0FBQ3NGLFFBQVE7Z0JBQzdDSCxnQkFBZ0J2TSx5REFBS0EsQ0FBQ0QsS0FBS3dNLGVBQWUvTDtZQUM1QztZQUNBLElBQUl1SSxnQkFBZ0I7Z0JBQ2xCLE1BQU0wRCxVQUFVekYsY0FBYyxNQUFNLFFBQVE7Z0JBQzVDLE1BQU0wRixVQUFVMUYsY0FBYyxNQUFNLFdBQVc7Z0JBQy9DLE1BQU1qSCxNQUFNeU0saUJBQWlCcEYsUUFBUSxDQUFDcUYsUUFBUTtnQkFDOUMsTUFBTWpNLE1BQU1nTSxpQkFBaUJwRixRQUFRLENBQUNzRixRQUFRO2dCQUM5Q0YsaUJBQWlCeE0seURBQUtBLENBQUNELEtBQUt5TSxnQkFBZ0JoTTtZQUM5QztZQUNBLE1BQU1tTSxnQkFBZ0JMLFFBQVF4SixFQUFFLENBQUM7Z0JBQy9CLEdBQUdRLEtBQUs7Z0JBQ1IsQ0FBQ3VGLFNBQVMsRUFBRTBEO2dCQUNaLENBQUN2RixVQUFVLEVBQUV3RjtZQUNmO1lBQ0EsT0FBTztnQkFDTCxHQUFHRyxhQUFhO2dCQUNoQjFKLE1BQU07b0JBQ0ozQixHQUFHcUwsY0FBY3JMLENBQUMsR0FBR0E7b0JBQ3JCRyxHQUFHa0wsY0FBY2xMLENBQUMsR0FBR0E7Z0JBQ3ZCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQTs7Q0FFQyxHQUNELE1BQU1tTCxhQUFhLFNBQVVySixPQUFPO0lBQ2xDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLE9BQU87UUFDTEE7UUFDQVQsSUFBR1EsS0FBSztZQUNOLE1BQU0sRUFDSmhDLENBQUMsRUFDREcsQ0FBQyxFQUNEYixTQUFTLEVBQ1QwQixLQUFLLEVBQ0xHLGNBQWMsRUFDZixHQUFHYTtZQUNKLE1BQU0sRUFDSjZDLFNBQVMsQ0FBQyxFQUNWMEMsVUFBVUMsZ0JBQWdCLElBQUksRUFDOUI5QixXQUFXK0IsaUJBQWlCLElBQUksRUFDakMsR0FBR25KLDREQUFRQSxDQUFDMkQsU0FBU0Q7WUFDdEIsTUFBTTFCLFNBQVM7Z0JBQ2JOO2dCQUNBRztZQUNGO1lBQ0EsTUFBTXVGLFlBQVl6SCwrREFBV0EsQ0FBQ3FCO1lBQzlCLE1BQU1pSSxXQUFXcEksbUVBQWVBLENBQUN1RztZQUNqQyxJQUFJdUYsZ0JBQWdCM0ssTUFBTSxDQUFDaUgsU0FBUztZQUNwQyxJQUFJMkQsaUJBQWlCNUssTUFBTSxDQUFDb0YsVUFBVTtZQUN0QyxNQUFNNkYsWUFBWWpOLDREQUFRQSxDQUFDdUcsUUFBUTdDO1lBQ25DLE1BQU13SixpQkFBaUIsT0FBT0QsY0FBYyxXQUFXO2dCQUNyRGhFLFVBQVVnRTtnQkFDVjdGLFdBQVc7WUFDYixJQUFJO2dCQUNGNkIsVUFBVTtnQkFDVjdCLFdBQVc7Z0JBQ1gsR0FBRzZGLFNBQVM7WUFDZDtZQUNBLElBQUkvRCxlQUFlO2dCQUNqQixNQUFNaUUsTUFBTWxFLGFBQWEsTUFBTSxXQUFXO2dCQUMxQyxNQUFNbUUsV0FBVzFLLE1BQU14QixTQUFTLENBQUMrSCxTQUFTLEdBQUd2RyxNQUFNdkIsUUFBUSxDQUFDZ00sSUFBSSxHQUFHRCxlQUFlakUsUUFBUTtnQkFDMUYsTUFBTW9FLFdBQVczSyxNQUFNeEIsU0FBUyxDQUFDK0gsU0FBUyxHQUFHdkcsTUFBTXhCLFNBQVMsQ0FBQ2lNLElBQUksR0FBR0QsZUFBZWpFLFFBQVE7Z0JBQzNGLElBQUkwRCxnQkFBZ0JTLFVBQVU7b0JBQzVCVCxnQkFBZ0JTO2dCQUNsQixPQUFPLElBQUlULGdCQUFnQlUsVUFBVTtvQkFDbkNWLGdCQUFnQlU7Z0JBQ2xCO1lBQ0Y7WUFDQSxJQUFJbEUsZ0JBQWdCO2dCQUNsQixJQUFJbUUsdUJBQXVCQztnQkFDM0IsTUFBTUosTUFBTWxFLGFBQWEsTUFBTSxVQUFVO2dCQUN6QyxNQUFNdUUsZUFBZTtvQkFBQztvQkFBTztpQkFBTyxDQUFDbkIsUUFBUSxDQUFDdk0sMkRBQU9BLENBQUNrQjtnQkFDdEQsTUFBTW9NLFdBQVcxSyxNQUFNeEIsU0FBUyxDQUFDa0csVUFBVSxHQUFHMUUsTUFBTXZCLFFBQVEsQ0FBQ2dNLElBQUksR0FBSUssQ0FBQUEsZUFBZSxDQUFDLENBQUNGLHdCQUF3QnpLLGVBQWUwRCxNQUFNLEtBQUssT0FBTyxLQUFLLElBQUkrRyxxQkFBcUIsQ0FBQ2xHLFVBQVUsS0FBSyxJQUFJLEtBQU1vRyxDQUFBQSxlQUFlLElBQUlOLGVBQWU5RixTQUFTO2dCQUNsUCxNQUFNaUcsV0FBVzNLLE1BQU14QixTQUFTLENBQUNrRyxVQUFVLEdBQUcxRSxNQUFNeEIsU0FBUyxDQUFDaU0sSUFBSSxHQUFJSyxDQUFBQSxlQUFlLElBQUksQ0FBQyxDQUFDRCx5QkFBeUIxSyxlQUFlMEQsTUFBTSxLQUFLLE9BQU8sS0FBSyxJQUFJZ0gsc0JBQXNCLENBQUNuRyxVQUFVLEtBQUssS0FBTW9HLENBQUFBLGVBQWVOLGVBQWU5RixTQUFTLEdBQUc7Z0JBQ3BQLElBQUl3RixpQkFBaUJRLFVBQVU7b0JBQzdCUixpQkFBaUJRO2dCQUNuQixPQUFPLElBQUlSLGlCQUFpQlMsVUFBVTtvQkFDcENULGlCQUFpQlM7Z0JBQ25CO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMLENBQUNwRSxTQUFTLEVBQUUwRDtnQkFDWixDQUFDdkYsVUFBVSxFQUFFd0Y7WUFDZjtRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTWEsT0FBTyxTQUFVOUosT0FBTztJQUM1QixJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0xWLE1BQU07UUFDTlU7UUFDQSxNQUFNVCxJQUFHUSxLQUFLO1lBQ1osTUFBTSxFQUNKMUMsU0FBUyxFQUNUMEIsS0FBSyxFQUNMTCxRQUFRLEVBQ1JtQixRQUFRLEVBQ1QsR0FBR0U7WUFDSixNQUFNLEVBQ0pnSyxRQUFRLEtBQU8sQ0FBQyxFQUNoQixHQUFHckcsdUJBQ0osR0FBR3JILDREQUFRQSxDQUFDMkQsU0FBU0Q7WUFDdEIsTUFBTThELFdBQVcsTUFBTS9ELGVBQWVDLE9BQU8yRDtZQUM3QyxNQUFNOUYsT0FBT3pCLDJEQUFPQSxDQUFDa0I7WUFDckIsTUFBTTRGLFlBQVk3RyxnRUFBWUEsQ0FBQ2lCO1lBQy9CLE1BQU15RSxVQUFVOUYsK0RBQVdBLENBQUNxQixlQUFlO1lBQzNDLE1BQU0sRUFDSlcsS0FBSyxFQUNMRyxNQUFNLEVBQ1AsR0FBR1ksTUFBTXZCLFFBQVE7WUFDbEIsSUFBSXdNO1lBQ0osSUFBSUM7WUFDSixJQUFJck0sU0FBUyxTQUFTQSxTQUFTLFVBQVU7Z0JBQ3ZDb00sYUFBYXBNO2dCQUNicU0sWUFBWWhILGNBQWUsT0FBUXZFLENBQUFBLFNBQVNJLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSUosU0FBU0ksS0FBSyxDQUFDZSxTQUFTckMsUUFBUSxLQUFNLFVBQVUsS0FBSSxJQUFLLFNBQVM7WUFDekksT0FBTztnQkFDTHlNLFlBQVlyTTtnQkFDWm9NLGFBQWEvRyxjQUFjLFFBQVEsUUFBUTtZQUM3QztZQUNBLE1BQU1pSCwwQkFBMEIvTCxTQUFTMEYsUUFBUSxDQUFDbUcsV0FBVztZQUM3RCxNQUFNRyx5QkFBeUJuTSxRQUFRNkYsUUFBUSxDQUFDb0csVUFBVTtZQUMxRCxNQUFNRyxVQUFVLENBQUNySyxNQUFNYixjQUFjLENBQUM0SixLQUFLO1lBQzNDLElBQUl1QixrQkFBa0JIO1lBQ3RCLElBQUlJLGlCQUFpQkg7WUFDckIsSUFBSXJJLFNBQVM7Z0JBQ1gsTUFBTXlJLHVCQUF1QnZNLFFBQVE2RixTQUFTckMsSUFBSSxHQUFHcUMsU0FBU3BDLEtBQUs7Z0JBQ25FNkksaUJBQWlCckgsYUFBYW1ILFVBQVU1Tix1REFBR0EsQ0FBQzJOLHdCQUF3Qkksd0JBQXdCQTtZQUM5RixPQUFPO2dCQUNMLE1BQU1DLHdCQUF3QnJNLFNBQVMwRixTQUFTdkMsR0FBRyxHQUFHdUMsU0FBU3RDLE1BQU07Z0JBQ3JFOEksa0JBQWtCcEgsYUFBYW1ILFVBQVU1Tix1REFBR0EsQ0FBQzBOLHlCQUF5Qk0seUJBQXlCQTtZQUNqRztZQUNBLElBQUlKLFdBQVcsQ0FBQ25ILFdBQVc7Z0JBQ3pCLE1BQU13SCxPQUFPeE4sdURBQUdBLENBQUM0RyxTQUFTckMsSUFBSSxFQUFFO2dCQUNoQyxNQUFNa0osT0FBT3pOLHVEQUFHQSxDQUFDNEcsU0FBU3BDLEtBQUssRUFBRTtnQkFDakMsTUFBTWtKLE9BQU8xTix1REFBR0EsQ0FBQzRHLFNBQVN2QyxHQUFHLEVBQUU7Z0JBQy9CLE1BQU1zSixPQUFPM04sdURBQUdBLENBQUM0RyxTQUFTdEMsTUFBTSxFQUFFO2dCQUNsQyxJQUFJTyxTQUFTO29CQUNYd0ksaUJBQWlCdE0sUUFBUSxJQUFLeU0sQ0FBQUEsU0FBUyxLQUFLQyxTQUFTLElBQUlELE9BQU9DLE9BQU96Tix1REFBR0EsQ0FBQzRHLFNBQVNyQyxJQUFJLEVBQUVxQyxTQUFTcEMsS0FBSztnQkFDMUcsT0FBTztvQkFDTDRJLGtCQUFrQmxNLFNBQVMsSUFBS3dNLENBQUFBLFNBQVMsS0FBS0MsU0FBUyxJQUFJRCxPQUFPQyxPQUFPM04sdURBQUdBLENBQUM0RyxTQUFTdkMsR0FBRyxFQUFFdUMsU0FBU3RDLE1BQU07Z0JBQzVHO1lBQ0Y7WUFDQSxNQUFNd0ksTUFBTTtnQkFDVixHQUFHaEssS0FBSztnQkFDUnVLO2dCQUNBRDtZQUNGO1lBQ0EsTUFBTVEsaUJBQWlCLE1BQU1uTSxTQUFTbUQsYUFBYSxDQUFDaEMsU0FBU3JDLFFBQVE7WUFDckUsSUFBSVEsVUFBVTZNLGVBQWU3TSxLQUFLLElBQUlHLFdBQVcwTSxlQUFlMU0sTUFBTSxFQUFFO2dCQUN0RSxPQUFPO29CQUNMd0IsT0FBTzt3QkFDTFosT0FBTztvQkFDVDtnQkFDRjtZQUNGO1lBQ0EsT0FBTyxDQUFDO1FBQ1Y7SUFDRjtBQUNGO0FBRXNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b2JhbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcz81NmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIHBvc2l0aW9uaW5nIHN0cmF0ZWd5LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYXRmb3JtLFxuICAgIHJlY3RzLFxuICAgIGVsZW1lbnRzLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8ge1xuICAgIC4uLnJlY3RzLmZsb2F0aW5nLFxuICAgIHgsXG4gICAgeVxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJykge1xuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHMucHVzaCguLi5nZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24sIHJ0bCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IFtpbml0aWFsUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93cyA9IFtdO1xuICAgICAgbGV0IG92ZXJmbG93c0RhdGEgPSAoKF9taWRkbGV3YXJlRGF0YSRmbGlwID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwLm92ZXJmbG93cykgfHwgW107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpO1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlc1swXV0sIG92ZXJmbG93W3NpZGVzWzFdXSk7XG4gICAgICB9XG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dO1xuXG4gICAgICAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZy5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAyLCBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXI7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgIG92ZXJmbG93czogb3ZlcmZsb3dzRGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2FuZGlkYXRlcyB0aGF0IGZpdCBvbiB0aGUgbWFpbkF4aXMgc2lkZSBvZiBvdmVyZmxvdyxcbiAgICAgICAgLy8gdGhlbiBmaW5kIHRoZSBwbGFjZW1lbnQgdGhhdCBmaXRzIHRoZSBiZXN0IG9uIHRoZSBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiBkLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIXJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdiZXN0Rml0JzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRtYXAkc287XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJG1hcCRzbyA9IG92ZXJmbG93c0RhdGEubWFwKGQgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJG1hcCRzb1swXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogMCxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbCxcbiAgICAuLi5yYXdWYWx1ZVxuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiBkaWZmQ29vcmRzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5ID0gKCkgPT4ge30sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc1lBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gcmVjdHMuZmxvYXRpbmc7XG4gICAgICBsZXQgaGVpZ2h0U2lkZTtcbiAgICAgIGxldCB3aWR0aFNpZGU7XG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IHNpZGU7XG4gICAgICAgIHdpZHRoU2lkZSA9IGFsaWdubWVudCA9PT0gKChhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpID8gJ3N0YXJ0JyA6ICdlbmQnKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFNpZGUgPSBzaWRlO1xuICAgICAgICBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3dbd2lkdGhTaWRlXTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBhbGlnbm1lbnQgfHwgbm9TaGlmdCA/IG1pbihvdmVyZmxvd0F2YWlsYWJsZVdpZHRoLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCkgOiBtYXhpbXVtQ2xpcHBpbmdXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gYWxpZ25tZW50IHx8IG5vU2hpZnQgPyBtaW4ob3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQsIG1heGltdW1DbGlwcGluZ0hlaWdodCkgOiBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsiZ2V0U2lkZUF4aXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QXhpc0xlbmd0aCIsImdldFNpZGUiLCJnZXRBbGlnbm1lbnQiLCJldmFsdWF0ZSIsImdldFBhZGRpbmdPYmplY3QiLCJyZWN0VG9DbGllbnRSZWN0IiwibWluIiwiY2xhbXAiLCJwbGFjZW1lbnRzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsInNpZGVzIiwibWF4IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQiLCJfcmVmIiwicGxhY2VtZW50IiwicnRsIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJzaWRlQXhpcyIsImFsaWdubWVudEF4aXMiLCJhbGlnbkxlbmd0aCIsInNpZGUiLCJpc1ZlcnRpY2FsIiwiY29tbW9uWCIsIngiLCJ3aWR0aCIsImNvbW1vblkiLCJ5IiwiaGVpZ2h0IiwiY29tbW9uQWxpZ24iLCJjb29yZHMiLCJjb21wdXRlUG9zaXRpb24iLCJjb25maWciLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJwbGF0Zm9ybSIsInZhbGlkTWlkZGxld2FyZSIsImZpbHRlciIsIkJvb2xlYW4iLCJpc1JUTCIsInJlY3RzIiwiZ2V0RWxlbWVudFJlY3RzIiwic3RhdGVmdWxQbGFjZW1lbnQiLCJtaWRkbGV3YXJlRGF0YSIsInJlc2V0Q291bnQiLCJpIiwibGVuZ3RoIiwibmFtZSIsImZuIiwibmV4dFgiLCJuZXh0WSIsImRhdGEiLCJyZXNldCIsImluaXRpYWxQbGFjZW1lbnQiLCJlbGVtZW50cyIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJvcHRpb25zIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwicGFkZGluZyIsInBhZGRpbmdPYmplY3QiLCJhbHRDb250ZXh0IiwiZWxlbWVudCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImdldENsaXBwaW5nUmVjdCIsImlzRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwicmVjdCIsIm9mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFNjYWxlIiwiZ2V0U2NhbGUiLCJlbGVtZW50Q2xpZW50UmVjdCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiYXJyb3ciLCJheGlzIiwiYXJyb3dEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsImlzWUF4aXMiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImNsaWVudFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJsYXJnZXN0UG9zc2libGVQYWRkaW5nIiwibWluUGFkZGluZyIsIm1heFBhZGRpbmciLCJtaW4kMSIsImNlbnRlciIsIm9mZnNldCIsInNob3VsZEFkZE9mZnNldCIsImFsaWdubWVudE9mZnNldCIsImNlbnRlck9mZnNldCIsImdldFBsYWNlbWVudExpc3QiLCJhbGlnbm1lbnQiLCJhdXRvQWxpZ25tZW50IiwiYWxsb3dlZFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50IiwiYXV0b1BsYWNlbWVudCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDIiLCJfcGxhY2VtZW50c1RoYXRGaXRPbkUiLCJjcm9zc0F4aXMiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJwbGFjZW1lbnRzJDEiLCJ1bmRlZmluZWQiLCJvdmVyZmxvdyIsImN1cnJlbnRJbmRleCIsImluZGV4IiwiY3VycmVudFBsYWNlbWVudCIsImFsaWdubWVudFNpZGVzIiwiY3VycmVudE92ZXJmbG93cyIsImFsbE92ZXJmbG93cyIsIm92ZXJmbG93cyIsIm5leHRQbGFjZW1lbnQiLCJwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UiLCJtYXAiLCJkIiwic2xpY2UiLCJyZWR1Y2UiLCJhY2MiLCJ2Iiwic29ydCIsImEiLCJiIiwicGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlIiwiZXZlcnkiLCJyZXNldFBsYWNlbWVudCIsImZsaXAiLCJfbWlkZGxld2FyZURhdGEkYXJyb3ciLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsIm1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsImNoZWNrQ3Jvc3NBeGlzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tTdHJhdGVneSIsImZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJmbGlwQWxpZ25tZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicHVzaCIsIm92ZXJmbG93c0RhdGEiLCJfbWlkZGxld2FyZURhdGEkZmxpcDIiLCJfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIiLCJuZXh0SW5kZXgiLCJfb3ZlcmZsb3dzRGF0YSRtYXAkc28iLCJnZXRTaWRlT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJoaWRlIiwib2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbk9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW4iLCJlc2NhcGVkT2Zmc2V0cyIsImVzY2FwZWQiLCJnZXRCb3VuZGluZ1JlY3QiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiZ2V0UmVjdHNCeUxpbmUiLCJzb3J0ZWRSZWN0cyIsImdyb3VwcyIsInByZXZSZWN0IiwiaW5saW5lIiwibmF0aXZlQ2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXRDbGllbnRSZWN0cyIsImNsaWVudFJlY3RzIiwiZmFsbGJhY2siLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJmaW5kIiwiZmlyc3RSZWN0IiwibGFzdFJlY3QiLCJpc1RvcCIsImlzTGVmdFNpZGUiLCJtYXhSaWdodCIsIm1pbkxlZnQiLCJtZWFzdXJlUmVjdHMiLCJyZXNldFJlY3RzIiwiY29udmVydFZhbHVlVG9Db29yZHMiLCJtYWluQXhpc011bHRpIiwiaW5jbHVkZXMiLCJjcm9zc0F4aXNNdWx0aSIsInJhd1ZhbHVlIiwiZGlmZkNvb3JkcyIsInNoaWZ0IiwibGltaXRlciIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwibGltaXRlZENvb3JkcyIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsImFwcGx5IiwiaGVpZ2h0U2lkZSIsIndpZHRoU2lkZSIsIm92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBdmFpbGFibGVXaWR0aCIsIm5vU2hpZnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsIm1heGltdW1DbGlwcGluZ1dpZHRoIiwibWF4aW11bUNsaXBwaW5nSGVpZ2h0IiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsIm5leHREaW1lbnNpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;\n        let currentIFrame = win.frameElement;\n        while(currentIFrame && offsetParent && offsetWin !== win){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame).frameElement;\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { rect, offsetParent, strategy } = _ref;\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    if (offsetParent === documentElement) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            ...clippingAncestor,\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    return getCssDimensions(element);\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    return element.offsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n        return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"html\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"body\" && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\" && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {\n        return window;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;\n}\nconst getElementRects = async function(_ref) {\n    let { reference, floating, strategy } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            ...await getDimensionsFn(floating)\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,\n    isRTL\n};\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    function cleanup() {\n        clearTimeout(timeoutId);\n        io && io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const { left, top, width, height } = element.getBoundingClientRect();\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 100);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    resizeObserver && resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo && cleanupIo();\n        resizeObserver && resizeObserver.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDbUM7QUFDcEQ7QUFDcU47QUFDak87QUFFOUQsU0FBU2lDLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNQyxNQUFNakIsd0VBQWdCQSxDQUFDZ0I7SUFDN0IseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxJQUFJRSxRQUFRQyxXQUFXRixJQUFJQyxLQUFLLEtBQUs7SUFDckMsSUFBSUUsU0FBU0QsV0FBV0YsSUFBSUcsTUFBTSxLQUFLO0lBQ3ZDLE1BQU1DLFlBQVlwQixxRUFBYUEsQ0FBQ2U7SUFDaEMsTUFBTU0sY0FBY0QsWUFBWUwsUUFBUU0sV0FBVyxHQUFHSjtJQUN0RCxNQUFNSyxlQUFlRixZQUFZTCxRQUFRTyxZQUFZLEdBQUdIO0lBQ3hELE1BQU1JLGlCQUFpQjdCLHlEQUFLQSxDQUFDdUIsV0FBV0ksZUFBZTNCLHlEQUFLQSxDQUFDeUIsWUFBWUc7SUFDekUsSUFBSUMsZ0JBQWdCO1FBQ2xCTixRQUFRSTtRQUNSRixTQUFTRztJQUNYO0lBQ0EsT0FBTztRQUNMTDtRQUNBRTtRQUNBSyxHQUFHRDtJQUNMO0FBQ0Y7QUFFQSxTQUFTRSxjQUFjVixPQUFPO0lBQzVCLE9BQU8sQ0FBQ2QsaUVBQVNBLENBQUNjLFdBQVdBLFFBQVFXLGNBQWMsR0FBR1g7QUFDeEQ7QUFFQSxTQUFTWSxTQUFTWixPQUFPO0lBQ3ZCLE1BQU1hLGFBQWFILGNBQWNWO0lBQ2pDLElBQUksQ0FBQ2YscUVBQWFBLENBQUM0QixhQUFhO1FBQzlCLE9BQU9qQyxnRUFBWUEsQ0FBQztJQUN0QjtJQUNBLE1BQU1rQyxPQUFPRCxXQUFXRSxxQkFBcUI7SUFDN0MsTUFBTSxFQUNKYixLQUFLLEVBQ0xFLE1BQU0sRUFDTkssQ0FBQyxFQUNGLEdBQUdWLGlCQUFpQmM7SUFDckIsSUFBSUcsSUFBSSxDQUFDUCxJ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M0Usd0VBQXdFO0lBQ3hFLDZFQUE2RTtJQUM3RSxNQUFNekQsUUFBUSxJQUFJNkY7SUFDbEIsTUFBTUMsZ0JBQWdCO1FBQ3BCdEQ7UUFDQSxHQUFHaUIsT0FBTztJQUNaO0lBQ0EsTUFBTXNDLG9CQUFvQjtRQUN4QixHQUFHRCxjQUFjdEQsUUFBUTtRQUN6QnJCLElBQUluQjtJQUNOO0lBQ0EsT0FBTy9HLGtFQUFpQkEsQ0FBQ2tKLFdBQVdDLFVBQVU7UUFDNUMsR0FBRzBELGFBQWE7UUFDaEJ0RCxVQUFVdUQ7SUFDWjtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b2JhbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanM/M2ZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldERvY3VtZW50RWxlbWVudCwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSB3aW4uZnJhbWVFbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IHdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSkuZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSAnZml4ZWQnKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIC4uLmNsaXBwaW5nQW5jZXN0b3IsXG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIC4uLihhd2FpdCBnZXREaW1lbnNpb25zRm4oZmxvYXRpbmcpKVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIGlvICYmIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGEgYGRvY3VtZW50YCBhcyB0aGUgcm9vdCBhbmQgd2lsbCB0aHJvdyBhblxuICAgIC8vIGVycm9yLlxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKHJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgY29uc3QgY2xlYW51cElvID0gcmVmZXJlbmNlRWwgJiYgbGF5b3V0U2hpZnQgPyBvYnNlcnZlTW92ZShyZWZlcmVuY2VFbCwgdXBkYXRlKSA6IG51bGw7XG4gIGxldCByZW9ic2VydmVGcmFtZSA9IC0xO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9yZWYgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGUgbG9vcHMgd2hlbiB1c2luZyB0aGUgYHNpemVgIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTc0MFxuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSk7XG4gICAgICAgIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICByZXNpemVPYnNlcnZlciAmJiByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvICYmIGNsZWFudXBJbygpO1xuICAgIHJlc2l6ZU9ic2VydmVyICYmIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIHJlZmVyZW5jZSBlbGVtZW50IHdoZW4gaXQgaXMgZ2l2ZW4gYSBjZXJ0YWluIENTUyBwb3NpdGlvbmluZ1xuICogc3RyYXRlZ3kuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBwbGF0Zm9ybSB9O1xuIl0sIm5hbWVzIjpbInJlY3RUb0NsaWVudFJlY3QiLCJjb21wdXRlUG9zaXRpb24iLCJjb21wdXRlUG9zaXRpb24kMSIsImFycm93IiwiYXV0b1BsYWNlbWVudCIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0Iiwic2hpZnQiLCJzaXplIiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZ2V0Tm9kZVNjcm9sbCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImlzQ29udGFpbmluZ0Jsb2NrIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJnZXRDc3NEaW1lbnNpb25zIiwiZWxlbWVudCIsImNzcyIsIndpZHRoIiwicGFyc2VGbG9hdCIsImhlaWdodCIsImhhc09mZnNldCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2hvdWxkRmFsbGJhY2siLCIkIiwidW53cmFwRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0U2NhbGUiLCJkb21FbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJub09mZnNldHMiLCJnZXRWaXN1YWxPZmZzZXRzIiwid2luIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwic2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyIsImlzRml4ZWQiLCJmbG9hdGluZ09mZnNldFBhcmVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsIm9mZnNldFBhcmVudCIsImNsaWVudFJlY3QiLCJzY2FsZSIsInZpc3VhbE9mZnNldHMiLCJsZWZ0IiwidG9wIiwib2Zmc2V0V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJzdHJhdGVneSIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9mZnNldHMiLCJvZmZzZXRSZWN0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0RG9jdW1lbnRSZWN0IiwiaHRtbCIsImJvZHkiLCJvd25lckRvY3VtZW50Iiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImRpcmVjdGlvbiIsImdldFZpZXdwb3J0UmVjdCIsInZpc3VhbFZpZXdwb3J0QmFzZWQiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvciIsImNsaXBwaW5nQW5jZXN0b3IiLCJoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IiLCJzdG9wTm9kZSIsInBhcmVudE5vZGUiLCJwb3NpdGlvbiIsImdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyIsImNhY2hlIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwicmVzdWx0IiwiZmlsdGVyIiwiZWwiLCJjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSIsImVsZW1lbnRJc0ZpeGVkIiwiY3VycmVudE5vZGUiLCJjb21wdXRlZFN0eWxlIiwiY3VycmVudE5vZGVJc0NvbnRhaW5pbmciLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJpbmNsdWRlcyIsImFuY2VzdG9yIiwic2V0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMiLCJfYyIsImNvbmNhdCIsImNsaXBwaW5nQW5jZXN0b3JzIiwiZmlyc3RDbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdSZWN0IiwicmVkdWNlIiwiYWNjUmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0RGltZW5zaW9ucyIsImdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsInBvbHlmaWxsIiwiZ2V0T2Zmc2V0UGFyZW50Iiwid2luZG93IiwiZ2V0RWxlbWVudFJlY3RzIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRPZmZzZXRQYXJlbnRGbiIsImdldERpbWVuc2lvbnNGbiIsImlzUlRMIiwicGxhdGZvcm0iLCJvYnNlcnZlTW92ZSIsIm9uTW92ZSIsImlvIiwidGltZW91dElkIiwicm9vdCIsImNsZWFudXAiLCJjbGVhclRpbWVvdXQiLCJkaXNjb25uZWN0IiwicmVmcmVzaCIsInNraXAiLCJ0aHJlc2hvbGQiLCJpbnNldFRvcCIsImluc2V0UmlnaHQiLCJpbnNldEJvdHRvbSIsImluc2V0TGVmdCIsInJvb3RNYXJnaW4iLCJvcHRpb25zIiwiaXNGaXJzdFVwZGF0ZSIsImhhbmRsZU9ic2VydmUiLCJlbnRyaWVzIiwicmF0aW8iLCJpbnRlcnNlY3Rpb25SYXRpbyIsInNldFRpbWVvdXQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImUiLCJvYnNlcnZlIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsImFuY2VzdG9yU2Nyb2xsIiwiYW5jZXN0b3JSZXNpemUiLCJlbGVtZW50UmVzaXplIiwiUmVzaXplT2JzZXJ2ZXIiLCJsYXlvdXRTaGlmdCIsImFuaW1hdGlvbkZyYW1lIiwicmVmZXJlbmNlRWwiLCJhbmNlc3RvcnMiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjbGVhbnVwSW8iLCJyZW9ic2VydmVGcmFtZSIsInJlc2l6ZU9ic2VydmVyIiwiZmlyc3RFbnRyeSIsInRhcmdldCIsInVub2JzZXJ2ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZnJhbWVJZCIsInByZXZSZWZSZWN0IiwiZnJhbWVMb29wIiwibmV4dFJlZlJlY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTWFwIiwibWVyZ2VkT3B0aW9ucyIsInBsYXRmb3JtV2l0aENhY2hlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>{\n    function isRef(value) {\n        return ({}).hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (state) {\n            const { element, padding } = typeof options === \"function\" ? options(state) : options;\n            if (element && isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(state);\n                }\n                return {};\n            } else if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(state);\n            }\n            return {};\n        }\n    };\n};\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length, i, keys;\n    if (a && b && typeof a == \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!({}).hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction getDPR(element) {\n    if (true) {\n        return 1;\n    }\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_3__.useState({\n        x: 0,\n        y: 0,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_3__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node != referenceRef.current) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, [\n        _setReference\n    ]);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node !== floatingRef.current) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, [\n        _setFloating\n    ]);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(data);\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const update = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                isPositioned: true\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    index(()=>{\n        if (referenceEl) referenceRef.current = referenceEl;\n        if (floatingEl) floatingRef.current = floatingEl;\n        if (referenceEl && floatingEl) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n            } else {\n                update();\n            }\n        }\n    }, [\n        referenceEl,\n        floatingEl,\n        update,\n        whileElementsMountedRef\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceEl,\n            floating: floatingEl\n        }), [\n        referenceEl,\n        floatingEl\n    ]);\n    const floatingStyles = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n        const initialStyles = {\n            position: strategy,\n            left: 0,\n            top: 0\n        };\n        if (!elements.floating) {\n            return initialStyles;\n        }\n        const x = roundByDPR(elements.floating, data.x);\n        const y = roundByDPR(elements.floating, data.y);\n        if (transform) {\n            return {\n                ...initialStyles,\n                transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n                ...getDPR(elements.floating) >= 1.5 && {\n                    willChange: \"transform\"\n                }\n            };\n        }\n        return {\n            position: strategy,\n            left: x,\n            top: y\n        };\n    }, [\n        strategy,\n        transform,\n        elements.floating,\n        data.x,\n        data.y\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            floatingStyles\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        floatingStyles\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUU7QUFDOEc7QUFDcEo7QUFDb0I7QUFDYjtBQUV0Qzs7Ozs7Q0FLQyxHQUNELE1BQU1BLFFBQVFtQixDQUFBQTtJQUNaLFNBQVNDLE1BQU1DLEtBQUs7UUFDbEIsT0FBTyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPO0lBQ3ZDO0lBQ0EsT0FBTztRQUNMRyxNQUFNO1FBQ05MO1FBQ0FNLElBQUdDLEtBQUs7WUFDTixNQUFNLEVBQ0pDLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUcsT0FBT1QsWUFBWSxhQUFhQSxRQUFRTyxTQUFTUDtZQUNyRCxJQUFJUSxXQUFXUCxNQUFNTyxVQUFVO2dCQUM3QixJQUFJQSxRQUFRRSxPQUFPLElBQUksTUFBTTtvQkFDM0IsT0FBTzVCLHVEQUFPQSxDQUFDO3dCQUNiMEIsU0FBU0EsUUFBUUUsT0FBTzt3QkFDeEJEO29CQUNGLEdBQUdILEVBQUUsQ0FBQ0M7Z0JBQ1I7Z0JBQ0EsT0FBTyxDQUFDO1lBQ1YsT0FBTyxJQUFJQyxTQUFTO2dCQUNsQixPQUFPMUIsdURBQU9BLENBQUM7b0JBQ2IwQjtvQkFDQUM7Z0JBQ0YsR0FBR0gsRUFBRSxDQUFDQztZQUNSO1lBQ0EsT0FBTyxDQUFDO1FBQ1Y7SUFDRjtBQUNGO0FBRUEsSUFBSUksUUFBUSxPQUFPQyxhQUFhLGNBQWNmLGtEQUFlQSxHQUFHQyw0Q0FBU0E7QUFFekUsZ0ZBQWdGO0FBQ2hGLFlBQVk7QUFDWixTQUFTZSxVQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxPQUFPQyxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxjQUFj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QUNaLElBQUk7UUFBQ0Q7UUFBYUM7S0FBVztJQUM3QixNQUFNWSxpQkFBaUJ0RiwwQ0FBYSxDQUFDO1FBQ25DLE1BQU11RixnQkFBZ0I7WUFDcEJDLFVBQVU1QztZQUNWNkMsTUFBTTtZQUNOQyxLQUFLO1FBQ1A7UUFDQSxJQUFJLENBQUM1QyxTQUFTRyxRQUFRLEVBQUU7WUFDdEIsT0FBT3NDO1FBQ1Q7UUFDQSxNQUFNOUIsSUFBSXRCLFdBQVdXLFNBQVNHLFFBQVEsRUFBRUssS0FBS0csQ0FBQztRQUM5QyxNQUFNQyxJQUFJdkIsV0FBV1csU0FBU0csUUFBUSxFQUFFSyxLQUFLSSxDQUFDO1FBQzlDLElBQUlQLFdBQVc7WUFDYixPQUFPO2dCQUNMLEdBQUdvQyxhQUFhO2dCQUNoQnBDLFdBQVcsZUFBZU0sSUFBSSxTQUFTQyxJQUFJO2dCQUMzQyxHQUFJN0IsT0FBT2lCLFNBQVNHLFFBQVEsS0FBSyxPQUFPO29CQUN0QzBDLFlBQVk7Z0JBQ2QsQ0FBQztZQUNIO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xILFVBQVU1QztZQUNWNkMsTUFBTWhDO1lBQ05pQyxLQUFLaEM7UUFDUDtJQUNGLEdBQUc7UUFBQ2Q7UUFBVU87UUFBV0wsU0FBU0csUUFBUTtRQUFFSyxLQUFLRyxDQUFDO1FBQUVILEtBQUtJLENBQUM7S0FBQztJQUMzRCxPQUFPMUQsMENBQWEsQ0FBQyxJQUFPO1lBQzFCLEdBQUdzRCxJQUFJO1lBQ1B3QjtZQUNBTTtZQUNBdEM7WUFDQXdDO1FBQ0YsSUFBSTtRQUFDaEM7UUFBTXdCO1FBQVFNO1FBQU10QztRQUFVd0M7S0FBZTtBQUNwRDtBQUU4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9iYW50Ly4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC1kb20vZGlzdC9mbG9hdGluZy11aS5yZWFjdC1kb20ubWpzP2M3OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXJyb3cgYXMgYXJyb3ckMSwgY29tcHV0ZVBvc2l0aW9uIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5leHBvcnQgeyBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYXJyb3ckMSh7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBwYWRkaW5nXG4gICAgICAgIH0pLmZuKHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGxlbmd0aCwgaSwga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gZ2V0RFBSKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3Qgd2luID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuIHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQnlEUFIoZWxlbWVudCwgdmFsdWUpIHtcbiAgY29uc3QgZHByID0gZ2V0RFBSKGVsZW1lbnQpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRwcikgLyBkcHI7XG59XG5cbmZ1bmN0aW9uIHVzZUxhdGVzdFJlZih2YWx1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IGV4dGVybmFsUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmc6IGV4dGVybmFsRmxvYXRpbmdcbiAgICB9ID0ge30sXG4gICAgdHJhbnNmb3JtID0gdHJ1ZSxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZCxcbiAgICBvcGVuXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0cmF0ZWd5LFxuICAgIHBsYWNlbWVudCxcbiAgICBtaWRkbGV3YXJlRGF0YToge30sXG4gICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgW2xhdGVzdE1pZGRsZXdhcmUsIHNldExhdGVzdE1pZGRsZXdhcmVdID0gUmVhY3QudXNlU3RhdGUobWlkZGxld2FyZSk7XG4gIGlmICghZGVlcEVxdWFsKGxhdGVzdE1pZGRsZXdhcmUsIG1pZGRsZXdhcmUpKSB7XG4gICAgc2V0TGF0ZXN0TWlkZGxld2FyZShtaWRkbGV3YXJlKTtcbiAgfVxuICBjb25zdCBbX3JlZmVyZW5jZSwgX3NldFJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW19mbG9hdGluZywgX3NldEZsb2F0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtfc2V0UmVmZXJlbmNlXSk7XG4gIGNvbnN0IHNldEZsb2F0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IGZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldEZsb2F0aW5nKG5vZGUpO1xuICAgIH1cbiAgfSwgW19zZXRGbG9hdGluZ10pO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IGV4dGVybmFsUmVmZXJlbmNlIHx8IF9yZWZlcmVuY2U7XG4gIGNvbnN0IGZsb2F0aW5nRWwgPSBleHRlcm5hbEZsb2F0aW5nIHx8IF9mbG9hdGluZztcbiAgY29uc3QgcmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmbG9hdGluZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZihkYXRhKTtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCAmJiAhZGVlcEVxdWFsKGRhdGFSZWYuY3VycmVudCwgZnVsbERhdGEpKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudCA9IGZ1bGxEYXRhO1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldERhdGEoZnVsbERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2xhdGVzdE1pZGRsZXdhcmUsIHBsYWNlbWVudCwgc3RyYXRlZ3ksIHBsYXRmb3JtUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3BlbiA9PT0gZmFsc2UgJiYgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCkge1xuICAgICAgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgc2V0RGF0YShkYXRhID0+ICh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHJlZmVyZW5jZUVsKSByZWZlcmVuY2VSZWYuY3VycmVudCA9IHJlZmVyZW5jZUVsO1xuICAgIGlmIChmbG9hdGluZ0VsKSBmbG9hdGluZ1JlZi5jdXJyZW50ID0gZmxvYXRpbmdFbDtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgZmxvYXRpbmdFbCkge1xuICAgICAgaWYgKHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlLCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZl0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuZXhwb3J0IHsgYXJyb3csIHVzZUZsb2F0aW5nIH07XG4iXSwibmFtZXMiOlsiYXJyb3ciLCJhcnJvdyQxIiwiY29tcHV0ZVBvc2l0aW9uIiwiYXV0b1BsYWNlbWVudCIsImF1dG9VcGRhdGUiLCJkZXRlY3RPdmVyZmxvdyIsImZsaXAiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0IiwicGxhdGZvcm0iLCJzaGlmdCIsInNpemUiLCJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsIlJlYWN0RE9NIiwib3B0aW9ucyIsImlzUmVmIiwidmFsdWUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuYW1lIiwiZm4iLCJzdGF0ZSIsImVsZW1lbnQiLCJwYWRkaW5nIiwiY3VycmVudCIsImluZGV4IiwiZG9jdW1lbnQiLCJkZWVwRXF1YWwiLCJhIiwiYiIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaSIsImtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXkiLCIkJHR5cGVvZiIsImdldERQUiIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyb3VuZEJ5RFBSIiwiZHByIiwiTWF0aCIsInJvdW5kIiwidXNlTGF0ZXN0UmVmIiwicmVmIiwidXNlUmVmIiwidXNlRmxvYXRpbmciLCJwbGFjZW1lbnQiLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJlbGVtZW50cyIsInJlZmVyZW5jZSIsImV4dGVybmFsUmVmZXJlbmNlIiwiZmxvYXRpbmciLCJleHRlcm5hbEZsb2F0aW5nIiwidHJhbnNmb3JtIiwid2hpbGVFbGVtZW50c01vdW50ZWQiLCJvcGVuIiwiZGF0YSIsInNldERhdGEiLCJ1c2VTdGF0ZSIsIngiLCJ5IiwibWlkZGxld2FyZURhdGEiLCJpc1Bvc2l0aW9uZWQiLCJsYXRlc3RNaWRkbGV3YXJlIiwic2V0TGF0ZXN0TWlkZGxld2FyZSIsIl9yZWZlcmVuY2UiLCJfc2V0UmVmZXJlbmNlIiwiX2Zsb2F0aW5nIiwiX3NldEZsb2F0aW5nIiwic2V0UmVmZXJlbmNlIiwidXNlQ2FsbGJhY2siLCJub2RlIiwicmVmZXJlbmNlUmVmIiwic2V0RmxvYXRpbmciLCJmbG9hdGluZ1JlZiIsInJlZmVyZW5jZUVsIiwiZmxvYXRpbmdFbCIsImRhdGFSZWYiLCJ3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiIsInBsYXRmb3JtUmVmIiwidXBkYXRlIiwiY29uZmlnIiwidGhlbiIsImZ1bGxEYXRhIiwiaXNNb3VudGVkUmVmIiwiZmx1c2hTeW5jIiwicmVmcyIsInVzZU1lbW8iLCJmbG9hdGluZ1N0eWxlcyIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJ3aWxsQ2hhbmdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\nconst sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n    const lr = [\n        \"left\",\n        \"right\"\n    ];\n    const rl = [\n        \"right\",\n        \"left\"\n    ];\n    const tb = [\n        \"top\",\n        \"bottom\"\n    ];\n    const bt = [\n        \"bottom\",\n        \"top\"\n    ];\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rl : lr;\n            return isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n            return isStart ? tb : bt;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    return {\n        ...rect,\n        top: rect.y,\n        left: rect.x,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBQ0EsU0FBU0MsYUFBYUYsU0FB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T0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU1QyxLQUFLNEM7UUFDTDlDLE9BQU84QztRQUNQN0MsUUFBUTZDO1FBQ1IvQyxNQUFNK0M7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE9BQU87UUFDTCxHQUFHQSxJQUFJO1FBQ1AvQyxLQUFLK0MsS0FBS3BELENBQUM7UUFDWEUsTUFBTWtELEtBQUtyRCxDQUFDO1FBQ1pJLE9BQU9pRCxLQUFLckQsQ0FBQyxHQUFHcUQsS0FBS0MsS0FBSztRQUMxQmpELFFBQVFnRCxLQUFLcEQsQ0FBQyxHQUFHb0QsS0FBS0UsTUFBTTtJQUM5QjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b2JhbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzPzVhZWEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiJdLCJuYW1lcyI6WyJzaWRlcyIsImFsaWdubWVudHMiLCJwbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwic2lkZSIsImNvbmNhdCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZsb29yIiwiY3JlYXRlQ29vcmRzIiwidiIsIngiLCJ5Iiwib3Bwb3NpdGVTaWRlTWFwIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwib3Bwb3NpdGVBbGlnbm1lbnRNYXAiLCJzdGFydCIsImVuZCIsImNsYW1wIiwidmFsdWUiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlQXhpcyIsImluY2x1ZGVzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEFsaWdubWVudFNpZGVzIiwicmVjdHMiLCJydGwiLCJhbGlnbm1lbnQiLCJhbGlnbm1lbnRBeGlzIiwibGVuZ3RoIiwibWFpbkFsaWdubWVudFNpZGUiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0RXhwYW5kZWRQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsInJlcGxhY2UiLCJnZXRTaWRlTGlzdCIsImlzU3RhcnQiLCJsciIsInJsIiwidGIiLCJidCIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJmbGlwQWxpZ25tZW50IiwiZGlyZWN0aW9uIiwibGlzdCIsIm1hcCIsImV4cGFuZFBhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\n        \"inline\",\n        \"contents\"\n    ].includes(display);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n    const webkit = isWebKit();\n    const css = getComputedStyle(element);\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\n        \"transform\",\n        \"perspective\",\n        \"filter\"\n    ].some((value)=>(css.willChange || \"\").includes(value)) || [\n        \"paint\",\n        \"layout\",\n        \"strict\",\n        \"content\"\n    ].some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else {\n            currentNode = getParentNode(currentNode);\n        }\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n    return [\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.pageXOffset,\n        scrollTop: element.pageYOffset\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsWUFBWUMsSUFBSTtJQUN2QixJQUFJQyxPQUFPRCxPQUFPO1FBQ2hCLE9BQU8sQ0FBQ0EsS0FBS0UsUUFBUSxJQUFJLEVBQUMsRUFBR0MsV0FBVztJQUMxQztJQUNBLHdFQUF3RTtJQUN4RSxzREFBc0Q7SUFDdEQseURBQXlEO0lBQ3pELE9BQU87QUFDVDtBQUNBLFNBQVNDLFVBQVVKLElBQUk7SUFDckIsSUFBSUs7SUFDSixPQUFPLENBQUNMLFFBQVEsT0FBTyxLQUFLLElBQUksQ0FBQ0ssc0JBQXNCTCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUlELG9CQUFvQkUsV0FBVyxLQUFLQztBQUNwSTtBQUNBLFNBQVNDLG1CQUFtQlQsSUFBSTtJQUM5QixJQUFJVTtJQUNKLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDVCxPQUFPRCxRQUFRQSxLQUFLTSxhQUFhLEdBQUdOLEtBQUtXLFFBQVEsS0FBS0gsT0FBT0csUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxLQUFLRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsT0FBT1ksS0FBSztJQUNuQixPQUFPQSxpQkFBaUJDLFFBQVFELGlCQUFpQlQsVUFBVVMsT0FBT0MsSUFBSTtBQUN4RTtBQUNBLFNBQVNDLFVBQVVGLEtBQUs7SUFDdEIsT0FBT0EsaUJBQWlCRyxXQUFXSCxpQkFBaUJULFVBQVVTLE9BQU9HLE9BQU87QUFDOUU7QUFDQSxTQUFTQyxjQUFjSixLQUFLO0lBQzFCLE9BQU9BLGlCQUFpQkssZUFBZUwsaUJBQWlCVCxVQUFVUyxPQUFPSyxXQUFXO0FBQ3RGO0FBQ0EsU0FBU0MsYUFBYU4sS0FBSztJQUN6Qix5Q0FBeUM7SUFDekMsSUFBSSxPQUFPTyxlQUFlLGFBQWE7UUFDckMsT0FBTztJQUNUO0lB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LGFBQWFYLGNBQWM3QztJQUNqQyxJQUFJOEMsc0JBQXNCVSxhQUFhO1FBQ3JDLE9BQU94RCxLQUFLTSxhQUFhLEdBQUdOLEtBQUtNLGFBQWEsQ0FBQ3FELElBQUksR0FBRzNELEtBQUsyRCxJQUFJO0lBQ2pFO0lBQ0EsSUFBSTFDLGNBQWN1QyxlQUFlbkMsa0JBQWtCbUMsYUFBYTtRQUM5RCxPQUFPQTtJQUNUO0lBQ0EsT0FBT0UsMkJBQTJCRjtBQUNwQztBQUNBLFNBQVNJLHFCQUFxQjVELElBQUksRUFBRTZELElBQUksRUFBRUMsZUFBZTtJQUN2RCxJQUFJQztJQUNKLElBQUlGLFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlDLG9CQUFvQixLQUFLLEdBQUc7UUFDOUJBLGtCQUFrQjtJQUNwQjtJQUNBLE1BQU1FLHFCQUFxQk4sMkJBQTJCMUQ7SUFDdEQsTUFBTWlFLFNBQVNELHVCQUF3QixFQUFDRCx1QkFBdUIvRCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUl5RCxxQkFBcUJKLElBQUk7SUFDL0gsTUFBTU8sTUFBTTlELFVBQVU0RDtJQUN0QixJQUFJQyxRQUFRO1FBQ1YsT0FBT0osS0FBS00sTUFBTSxDQUFDRCxLQUFLQSxJQUFJRSxjQUFjLElBQUksRUFBRSxFQUFFL0Msa0JBQWtCMkMsc0JBQXNCQSxxQkFBcUIsRUFBRSxFQUFFRSxJQUFJRyxZQUFZLElBQUlQLGtCQUFrQkYscUJBQXFCTSxJQUFJRyxZQUFZLElBQUksRUFBRTtJQUN0TTtJQUNBLE9BQU9SLEtBQUtNLE1BQU0sQ0FBQ0gsb0JBQW9CSixxQkFBcUJJLG9CQUFvQixFQUFFLEVBQUVGO0FBQ3RGO0FBRW1UIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b2JhbnQvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanM/YTVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgYFNoYWRvd1Jvb3RgIHN1cHBvcnQuXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhWydpbmxpbmUnLCAnY29udGVudHMnXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgcmV0dXJuIGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5wYWdlWE9mZnNldCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQucGFnZVlPZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgd2luLmZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyh3aW4uZnJhbWVFbGVtZW50KSA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IsIFtdLCB0cmF2ZXJzZUlmcmFtZXMpKTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yLCBnZXROb2RlTmFtZSwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGdldFdpbmRvdywgaXNDb250YWluaW5nQmxvY2ssIGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc05vZGUsIGlzT3ZlcmZsb3dFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGlzVGFibGVFbGVtZW50LCBpc1dlYktpdCB9O1xuIl0sIm5hbWVzIjpbImdldE5vZGVOYW1lIiwibm9kZSIsImlzTm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJfbm9kZSRvd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiX3JlZiIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidmFsdWUiLCJOb2RlIiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJpc092ZXJmbG93RWxlbWVudCIsImVsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwidGVzdCIsImluY2x1ZGVzIiwiaXNUYWJsZUVsZW1lbnQiLCJpc0NvbnRhaW5pbmdCbG9jayIsIndlYmtpdCIsImlzV2ViS2l0IiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluZXJUeXBlIiwiYmFja2Ryb3BGaWx0ZXIiLCJmaWx0ZXIiLCJzb21lIiwid2lsbENoYW5nZSIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsInJlc3VsdCIsImFzc2lnbmVkU2xvdCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IiLCJib2R5IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJsaXN0IiwidHJhdmVyc2VJZnJhbWVzIiwiX25vZGUkb3duZXJEb2N1bWVudDIiLCJzY3JvbGxhYmxlQW5jZXN0b3IiLCJpc0JvZHkiLCJ3aW4iLCJjb25jYXQiLCJ2aXN1YWxWaWV3cG9ydCIsImZyYW1lRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\n");

/***/ })

};
;